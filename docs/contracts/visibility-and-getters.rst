.. index:: ! visibility, external, public, private, internal

.. _visibility-and-getters:

**********************
Visibility and Getters
**********************

Solidityは2しゅるのファンクションコール（実際のEVMコールを作らないinternalのもの（"message call"とも呼ばれます）とEVMコールを作るexternalのもの）があるので、ファンクションと状態変数に対して4種類の可視性があります。

ファンクションは ``external``、``public``、``internal``、``private`` のいずれかを指定しなければいけません。状態変数には、``external`` は使えません。

``external``:
    externalのファンクションはコントラクトインターフェースの一部です。つまり、他のコントラクトからトランザクションを通じて呼び出すことができます。あるexternalのファンクション ``f`` はコントラクト内部では呼び出せません(``f()`` は動きませんが、``this.f()`` は動作します)。
    大きい配列を受け取る時、externalファンクションは場合によってより効率が良くなります。

``public``:
    externalのファンクションはコントラクトインターフェースの一部で、内部でも呼び出せますし、もしくはメッセージを通じて呼び出せます。publicの状態変数は自動的にgetter（下記参照）を生成します。

``internal``:
    internalのファンクションと状態変数は ``this`` を使わずに、コントラクト内部でのみアクセスできます（現在のコントラクトからか、それを継承したコントラクトから）。

``private``:
    privateのファンクションと状態変数はそれが定義されたコントラクト内のみで可視で、継承したコントラクトでは使えません。

.. note::
    コントラクト内側は全てブロックチェーン外側から可視です。``private`` だけが他のコントラクトがアクセスしたり変更したりするのを防いでくれます。しかし、それでもブロックチェーンの外側から可視です。

visibility specifierは状態変数の型の後、パラメータリストとファンクションの返り値リストの間に置かれます。

::

    pragma solidity >=0.4.16 <0.6.0;

    contract C {
        function f(uint a) private pure returns (uint b) { return a + 1; }
        function setData(uint a) internal { data = a; }
        uint public data;
    }

次の例では、``D`` はステートストレージ内の ``data`` の値を引き出すのに ``c.getData()`` を呼び出すことができます。しかし、``D`` は  ``f`` を呼べません。コントラクト ``E`` は ``C`` を継承しているため、``compute`` を呼び出すことができます。

::

    pragma solidity >=0.4.0 <0.6.0;

    contract C {
        uint private data;

        function f(uint a) private pure returns(uint b) { return a + 1; }
        function setData(uint a) public { data = a; }
        function getData() public view returns(uint) { return data; }
        function compute(uint a, uint b) internal pure returns (uint) { return a + b; }
    }

    // This will not compile
    contract D {
        function readData() public {
            C c = new C();
            uint local = c.f(7); // error: member `f` is not visible
            c.setData(3);
            local = c.getData();
            local = c.compute(3, 5); // error: member `compute` is not visible
        }
    }

    contract E is C {
        function g() public {
            C c = new C();
            uint val = compute(3, 5); // access to internal member (from derived to parent contract)
        }
    }

.. index:: ! getter;function, ! function;getter
.. _getter-functions:

Getter Functions
================

コンパイラは自動的に **public** の状態変数のgetterを生成します。下のコントラクトでは、コンパイラは ``data`` という引数を取らず、``uint`` 型の状態変数 ``data`` の値を返します。 状態変数は宣言された時に初期化することができます。

::

    pragma solidity >=0.4.0 <0.6.0;

    contract C {
        uint public data = 42;
    }

    contract Caller {
        C c = new C();
        function f() public view returns (uint) {
            return c.data();
        }
    }

getterはexternalの可視性を持っています。ある記号が内部的にアクセス(``this.`` なし)されたら、それは状態変数と評価されます。もし外部的にアクセス(``this.`` あり)されたら、それはファンクションと評価されます。

::

    pragma solidity >=0.4.0 <0.6.0;

    contract C {
        uint public data;
        function x() public returns (uint) {
            data = 3; // internal access
            return this.data(); // external access
        }
    }

もし ``public`` の配列型の状態変数を持っていたら、getterではその配列の1要素しか取り出すことができません。配列全体を返したときにガスが高くならない様にこの仕組みはあります。どの要素を返すか、例えば ``data(0)`` の様に引数を使って指定することができます。もし配列全体を返したい場合は、ファンクションを作る必要があります。例えば:

::

  pragma solidity >=0.4.0 <0.6.0;

  contract arrayExample {
    // public state variable
    uint[] public myArray;

    // Getter function generated by the compiler
    /*
    function myArray(uint i) returns (uint) {
        return myArray[i];
    }
    */

    // function that returns entire array
    function getArray() returns (uint[] memory) {
        return myArray;
    }
  }

ここで、配列全体を取り出すために、1回の呼び出しで1つの要素を返す ``myArray(i)`` の代わりに、``getArray()`` を使うことができます。

次の例はもっと複雑です。

::

    pragma solidity >=0.4.0 <0.6.0;

    contract Complex {
        struct Data {
            uint a;
            bytes3 b;
            mapping (uint => uint) map;
        }
        mapping (uint => mapping(bool => Data[])) public data;
    }

これは次の形のファンクションを生成します。マッピング用のキーを渡す良い方法がないので、構造体のマッピングは省略します。

::

    function data(uint arg1, bool arg2, uint arg3) public returns (uint a, bytes3 b) {
        a = data[arg1][arg2][arg3].a;
        b = data[arg1][arg2][arg3].b;
    }
