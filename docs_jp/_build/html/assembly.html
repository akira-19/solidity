

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Solidity Assembly &mdash; Solidity 0.5.4 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Miscellaneous" href="miscellaneous.html" />
    <link rel="prev" title="Contracts" href="contracts.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Solidity
          

          
          </a>

          
            
            
              <div class="version">
                0.5.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
    
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction-to-smart-contracts.html">Introduction to Smart Contracts</a></li>
<li class="toctree-l1"><a class="reference internal" href="installing-solidity.html">Installing the Solidity Compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="solidity-by-example.html">Solidity by Example</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="solidity-in-depth.html">Solidity in Depth</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="layout-of-source-files.html">Layout of a Solidity Source File</a></li>
<li class="toctree-l2"><a class="reference internal" href="structure-of-a-contract.html">Structure of a Contract</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="units-and-global-variables.html">Units and Globally Available Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="control-structures.html">Expressions and Control Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="contracts.html">Contracts</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Solidity Assembly</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#inline-assembly">Inline Assembly</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#syntax">Syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="#example">Example</a></li>
<li class="toctree-l4"><a class="reference internal" href="#opcodes">Opcodes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#literals">Literals</a></li>
<li class="toctree-l4"><a class="reference internal" href="#functional-style">Functional Style</a></li>
<li class="toctree-l4"><a class="reference internal" href="#access-to-external-variables-functions-and-libraries">Access to External Variables, Functions and Libraries</a></li>
<li class="toctree-l4"><a class="reference internal" href="#labels">Labels</a></li>
<li class="toctree-l4"><a class="reference internal" href="#declaring-assembly-local-variables">Declaring Assembly-Local Variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="#assignments">Assignments</a></li>
<li class="toctree-l4"><a class="reference internal" href="#if">If</a></li>
<li class="toctree-l4"><a class="reference internal" href="#switch">Switch</a></li>
<li class="toctree-l4"><a class="reference internal" href="#loops">Loops</a></li>
<li class="toctree-l4"><a class="reference internal" href="#functions">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#things-to-avoid">Things to Avoid</a></li>
<li class="toctree-l4"><a class="reference internal" href="#conventions-in-solidity">Conventions in Solidity</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#standalone-assembly">Standalone Assembly</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#assembly-grammar">Assembly Grammar</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html">Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="050-breaking-changes.html">Solidity v0.5.0 Breaking Changes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="security-considerations.html">Security Considerations</a></li>
<li class="toctree-l1"><a class="reference internal" href="resources.html">Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="using-the-compiler.html">Using the compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="metadata.html">Contract Metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="abi-spec.html">Contract ABI Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="yul.html">Yul</a></li>
<li class="toctree-l1"><a class="reference internal" href="style-guide.html">Style Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="common-patterns.html">Common Patterns</a></li>
<li class="toctree-l1"><a class="reference internal" href="bugs.html">List of Known Bugs</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="frequently-asked-questions.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="lll.html">LLL</a></li>
</ul>

            
          
    <a href="genindex.html">Keyword Index</a>
  
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Solidity</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="solidity-in-depth.html">Solidity in Depth</a> &raquo;</li>
        
      <li>Solidity Assembly</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/assembly.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="solidity-assembly">
<h1>Solidity Assembly<a class="headerlink" href="#solidity-assembly" title="Permalink to this headline">¶</a></h1>
<p id="index-0">SolidityはSolidityなしで使えるアセンブリ言語を定義しており、更にSolidityのソースコード内で”インラインアセンブリ”も使用可能です。このガイドではまずどの様にインラインアセンブリを使用するのか、スタンドアローンアセンブリとどう違うのか、そしてアセンブリ自体の説明をしていきます。</p>
<div class="section" id="inline-assembly">
<span id="id1"></span><h2>Inline Assembly<a class="headerlink" href="#inline-assembly" title="Permalink to this headline">¶</a></h2>
<p>仮想マシンの様な言語のインラインアセンブリで、Solidityの宣言をインターリーブできます。これにより細かいコントールを得ることができます。特にライブラリを作って言語を便利にする時に有用です。</p>
<p>EVMはスタックマシンなので、正確なスタック位置の指定や正確なスタック位置のopcodeに引数を与えるのは難しいです。Solidityのインラインアセンブリはこれらの問題や、マニュアルアセンブリを書いている時に出てくる問題に対して役にたちます。</p>
<p>インラインアセンブリは下記の特徴があります:</p>
<ul class="simple">
<li>functional-style opcodes: <code class="docutils literal notranslate"><span class="pre">mul(1,</span> <span class="pre">add(2,</span> <span class="pre">3))</span></code></li>
<li>assembly-local variables: <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">add(2,</span> <span class="pre">3)</span>&#160; <span class="pre">let</span> <span class="pre">y</span> <span class="pre">:=</span> <span class="pre">mload(0x40)</span>&#160; <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">add(x,</span> <span class="pre">y)</span></code></li>
<li>外部の変数にアクセス: <code class="docutils literal notranslate"><span class="pre">function</span> <span class="pre">f(uint</span> <span class="pre">x)</span> <span class="pre">public</span> <span class="pre">{</span> <span class="pre">assembly</span> <span class="pre">{</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">sub(x,</span> <span class="pre">1)</span> <span class="pre">}</span> <span class="pre">}</span></code></li>
<li>ループ: <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">{</span> <span class="pre">let</span> <span class="pre">i</span> <span class="pre">:=</span> <span class="pre">0</span> <span class="pre">}</span> <span class="pre">lt(i,</span> <span class="pre">x)</span> <span class="pre">{</span> <span class="pre">i</span> <span class="pre">:=</span> <span class="pre">add(i,</span> <span class="pre">1)</span> <span class="pre">}</span> <span class="pre">{</span> <span class="pre">y</span> <span class="pre">:=</span> <span class="pre">mul(2,</span> <span class="pre">y)</span> <span class="pre">}</span></code></li>
<li>if文: <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">slt(x,</span> <span class="pre">0)</span> <span class="pre">{</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">sub(0,</span> <span class="pre">x)</span> <span class="pre">}</span></code></li>
<li>switch分: <code class="docutils literal notranslate"><span class="pre">switch</span> <span class="pre">x</span> <span class="pre">case</span> <span class="pre">0</span> <span class="pre">{</span> <span class="pre">y</span> <span class="pre">:=</span> <span class="pre">mul(x,</span> <span class="pre">2)</span> <span class="pre">}</span> <span class="pre">default</span> <span class="pre">{</span> <span class="pre">y</span> <span class="pre">:=</span> <span class="pre">0</span> <span class="pre">}</span></code></li>
<li>ファンクションコール: <code class="docutils literal notranslate"><span class="pre">function</span> <span class="pre">f(x)</span> <span class="pre">-&gt;</span> <span class="pre">y</span> <span class="pre">{</span> <span class="pre">switch</span> <span class="pre">x</span> <span class="pre">case</span> <span class="pre">0</span> <span class="pre">{</span> <span class="pre">y</span> <span class="pre">:=</span> <span class="pre">1</span> <span class="pre">}</span> <span class="pre">default</span> <span class="pre">{</span> <span class="pre">y</span> <span class="pre">:=</span> <span class="pre">mul(x,</span> <span class="pre">f(sub(x,</span> <span class="pre">1)))</span> <span class="pre">}</span>&#160;&#160; <span class="pre">}</span></code></li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">インラインアセンブリはEVMに低レベルでアクセスする方法です。そのため、Solidityの大事な安全に関する機能やチェックをバイパスします。必要がある時のみ、またこの機能について知識がある時のみ使用する方が良いでしょう。</p>
</div>
<div class="section" id="syntax">
<h3>Syntax<a class="headerlink" href="#syntax" title="Permalink to this headline">¶</a></h3>
<p>アセンブリはコメント、リテラル、識別子をSolidityと同じ方法でパースします。そのため、普段使っている <code class="docutils literal notranslate"><span class="pre">//</span></code> と <code class="docutils literal notranslate"><span class="pre">/*</span> <span class="pre">*/</span></code> は使用可能です。インラインアセンブリは <code class="docutils literal notranslate"><span class="pre">assembly</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code> で書かれており、中括弧の中では下記が使用可能です（詳細は後述のセクションを参照ください）:</p>
<blockquote>
<div><ul class="simple">
<li>リテラル 例： <code class="docutils literal notranslate"><span class="pre">0x123</span></code>、<code class="docutils literal notranslate"><span class="pre">42</span></code>、<code class="docutils literal notranslate"><span class="pre">&quot;abc&quot;</span></code> (文字列は32文字まで)</li>
<li>ファンクション式のopcode 例: <code class="docutils literal notranslate"><span class="pre">add(1,</span> <span class="pre">mlod(0))</span></code></li>
<li>変数の宣言 例: <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">7</span></code>, <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">add(y,</span> <span class="pre">3)</span></code> or <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">x</span></code> (空（0）の初期値は割り当て済み)</li>
<li>識別子 (インラインアセンブリで使われたassembly-local 変数と外部のもの) 例: <code class="docutils literal notranslate"><span class="pre">add(3,</span> <span class="pre">x)</span></code>, <code class="docutils literal notranslate"><span class="pre">sstore(x_slot,</span> <span class="pre">2)</span></code></li>
<li>値の割り当て 例: <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">:=</span> <span class="pre">add(y,</span> <span class="pre">3)</span></code></li>
<li>ローカルの変数が内部でスコープされているブロック 例: <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">let</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">3</span> <span class="pre">{</span> <span class="pre">let</span> <span class="pre">y</span> <span class="pre">:=</span> <span class="pre">add(x,</span> <span class="pre">1)</span> <span class="pre">}</span> <span class="pre">}</span></code></li>
</ul>
</div></blockquote>
<p>下記の機能はスタンドアローンのアセンブリでのみ使用可能です:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">dup1</span></code>、<code class="docutils literal notranslate"><span class="pre">swap1</span></code>、、、を介した直接的なスタックのコントロール</li>
<li>ダイレクトなスタックの割り当て (in “instruction style”) 例: <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">=:</span> <span class="pre">x</span></code></li>
<li>ラベル 例: <code class="docutils literal notranslate"><span class="pre">name:</span></code></li>
<li>ジャンプopcode</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">スタンドアローンのアセンブリは後方互換性をサポートしますが、ここではドキュメント化しません。</p>
</div>
<p>要求しない限り、<code class="docutils literal notranslate"><span class="pre">assembly</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code> ブロックの最後に、スタックはバランスしなければいけません。もしバランスしていなかったら、コンパイラは警告を発します。</p>
</div>
<div class="section" id="example">
<h3>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h3>
<p>下記の例は、別のコントラクトのコードにアクセスするライブラリのコード例で、<code class="docutils literal notranslate"><span class="pre">bytes</span></code> 変数にそのコードを載せています。”生のSolidity” ではこれはできません。アセンブリライブラリはSolidityという言語をより良くするために使用されます。</p>
<div class="code highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">library</span> <span class="n">GetCode</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">at</span><span class="p">(</span><span class="kt">address</span> <span class="n">_addr</span><span class="p">)</span> <span class="kr">public</span> <span class="kr">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes</span> <span class="kr">memory</span> <span class="n">o_code</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">assembly</span> <span class="p">{</span>
            <span class="c1">// retrieve the size of the code, this needs assembly</span>
            <span class="ow">let</span> <span class="nv">size</span> <span class="o">:=</span> <span class="nf">extcodesize</span><span class="p">(</span><span class="n">_addr</span><span class="p">)</span>
            <span class="c1">// allocate output byte array - this could also be done without assembly</span>
            <span class="c1">// by using o_code = new bytes(size)</span>
            <span class="n">o_code</span> <span class="o">:=</span> <span class="nf">mload</span><span class="p">(</span><span class="mh">0x40</span><span class="p">)</span>
            <span class="c1">// new &quot;memory end&quot; including padding</span>
            <span class="nf">mstore</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span> <span class="nf">add</span><span class="p">(</span><span class="n">o_code</span><span class="p">,</span> <span class="nf">and</span><span class="p">(</span><span class="nf">add</span><span class="p">(</span><span class="nf">add</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">),</span> <span class="mh">0x1f</span><span class="p">),</span> <span class="nf">not</span><span class="p">(</span><span class="mh">0x1f</span><span class="p">))))</span>
            <span class="c1">// store length in memory</span>
            <span class="nf">mstore</span><span class="p">(</span><span class="n">o_code</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
            <span class="c1">// actually retrieve the code, this needs assembly</span>
            <span class="nf">extcodecopy</span><span class="p">(</span><span class="n">_addr</span><span class="p">,</span> <span class="nf">add</span><span class="p">(</span><span class="n">o_code</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>オプティマイザが効率的なコードを生成するのに失敗した場合にもインラインアセンブリは有用です。例えば:</p>
<div class="code highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">library</span> <span class="n">VectorSum</span> <span class="p">{</span>
    <span class="c1">// This function is less efficient because the optimizer currently fails to</span>
    <span class="c1">// remove the bounds checks in array access.</span>
    <span class="kd">function</span> <span class="n">sumSolidity</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="kr">memory</span> <span class="n">_data</span><span class="p">)</span> <span class="kr">public</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">o_sum</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_data</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">o_sum</span> <span class="o">+=</span> <span class="n">_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">// We know that we only access the array in bounds, so we can avoid the check.</span>
    <span class="c1">// 0x20 needs to be added to an array because the first slot contains the</span>
    <span class="c1">// array length.</span>
    <span class="kd">function</span> <span class="n">sumAsm</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="kr">memory</span> <span class="n">_data</span><span class="p">)</span> <span class="kr">public</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">o_sum</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_data</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">assembly</span> <span class="p">{</span>
                <span class="n">o_sum</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="n">o_sum</span><span class="p">,</span> <span class="nf">mload</span><span class="p">(</span><span class="nf">add</span><span class="p">(</span><span class="nf">add</span><span class="p">(</span><span class="n">_data</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">),</span> <span class="nf">mul</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">))))</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Same as above, but accomplish the entire code within inline assembly.</span>
    <span class="kd">function</span> <span class="n">sumPureAsm</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="kr">memory</span> <span class="n">_data</span><span class="p">)</span> <span class="kr">public</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">o_sum</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">assembly</span> <span class="p">{</span>
           <span class="c1">// Load the length (first 32 bytes)</span>
           <span class="ow">let</span> <span class="nv">len</span> <span class="o">:=</span> <span class="nf">mload</span><span class="p">(</span><span class="n">_data</span><span class="p">)</span>

           <span class="c1">// Skip over the length field.</span>
           <span class="c1">//</span>
           <span class="c1">// Keep temporary variable so it can be incremented in place.</span>
           <span class="c1">//</span>
           <span class="c1">// NOTE: incrementing _data would result in an unusable</span>
           <span class="c1">//       _data variable after this assembly block</span>
           <span class="ow">let</span> <span class="nv">data</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="n">_data</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">)</span>

           <span class="c1">// Iterate until the bound is not met.</span>
           <span class="nf">for</span>
               <span class="p">{</span> <span class="ow">let</span> <span class="nv">end</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nf">mul</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">))</span> <span class="p">}</span>
               <span class="nf">lt</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
               <span class="p">{</span> <span class="n">data</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">)</span> <span class="p">}</span>
           <span class="p">{</span>
               <span class="n">o_sum</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="n">o_sum</span><span class="p">,</span> <span class="nf">mload</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
           <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="opcodes">
<span id="id2"></span><h3>Opcodes<a class="headerlink" href="#opcodes" title="Permalink to this headline">¶</a></h3>
<p>このドキュメントではEthereum Virtual Machineについて完全には説明しませんが、下記のリストはEVMのopcodeのリファレンスとして使用できます。</p>
<p>opcodeが引数をとる場合（常にスタックの上からとります）、括弧の中に引数が入ります。
引数の順番はnon-functional styleでは逆さまに入っています（後述します）。
<code class="docutils literal notranslate"><span class="pre">-</span></code> がついているopcodeは何もスタック上にプッシュしません（結果も返しません）。<code class="docutils literal notranslate"><span class="pre">*</span></code> がついているopcodeは特別で、他のopcodeは1つだけスタック上にプッシュします（”返り値”）。
<code class="docutils literal notranslate"><span class="pre">F</span></code>、<code class="docutils literal notranslate"><span class="pre">H</span></code>、<code class="docutils literal notranslate"><span class="pre">B</span></code>、<code class="docutils literal notranslate"><span class="pre">C</span></code> がついているopcodeはそれぞれFrontier、Homestead、Byzantium、Constantinople から導入されました。Constantinopleは未だプラニングの段階ですので、そのマークがついているインストラクションは無効なインストラクションの例外を投げます。</p>
<p>下記で、<code class="docutils literal notranslate"><span class="pre">mem[a...b)</span></code> は 位置 <code class="docutils literal notranslate"><span class="pre">a</span></code> から始まって、<code class="docutils literal notranslate"><span class="pre">b</span></code> で終わる（bは含まない）メモリのバイトを表しており、<code class="docutils literal notranslate"><span class="pre">storage[p]</span></code> は 位置 <code class="docutils literal notranslate"><span class="pre">p</span></code> でのストレージの内容を表しています。</p>
<p><code class="docutils literal notranslate"><span class="pre">pushi</span></code> と <code class="docutils literal notranslate"><span class="pre">jumpdest</span></code> のopcodeは直接は使用できません。</p>
<p>グラマー上、opcodeは事前に定義された識別子として表されます。</p>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="5%" />
<col width="3%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Instruction</th>
<th class="head">&#160;</th>
<th class="head">&#160;</th>
<th class="head">Explanation</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td rowspan="2">stop</td>
<td rowspan="2"><cite>-</cite></td>
<td rowspan="2">F</td>
<td rowspan="2">stop execution, identical to return(0,0)</td>
</tr>
<tr class="row-odd"></tr>
<tr class="row-even"><td>add(x, y)</td>
<td>&#160;</td>
<td>F</td>
<td>x + y</td>
</tr>
<tr class="row-odd"><td>sub(x, y)</td>
<td>&#160;</td>
<td>F</td>
<td>x - y</td>
</tr>
<tr class="row-even"><td>mul(x, y)</td>
<td>&#160;</td>
<td>F</td>
<td>x * y</td>
</tr>
<tr class="row-odd"><td>div(x, y)</td>
<td>&#160;</td>
<td>F</td>
<td>x / y</td>
</tr>
<tr class="row-even"><td>sdiv(x, y)</td>
<td>&#160;</td>
<td>F</td>
<td>x / y, for signed numbers in two’s complement</td>
</tr>
<tr class="row-odd"><td>mod(x, y)</td>
<td>&#160;</td>
<td>F</td>
<td>x % y</td>
</tr>
<tr class="row-even"><td>smod(x, y)</td>
<td>&#160;</td>
<td>F</td>
<td>x % y, for signed numbers in two’s complement</td>
</tr>
<tr class="row-odd"><td>exp(x, y)</td>
<td>&#160;</td>
<td>F</td>
<td>x to the power of y</td>
</tr>
<tr class="row-even"><td>not(x)</td>
<td>&#160;</td>
<td>F</td>
<td>~x, every bit of x is negated</td>
</tr>
<tr class="row-odd"><td>lt(x, y)</td>
<td>&#160;</td>
<td>F</td>
<td>1 if x &lt; y, 0 otherwise</td>
</tr>
<tr class="row-even"><td>gt(x, y)</td>
<td>&#160;</td>
<td>F</td>
<td>1 if x &gt; y, 0 otherwise</td>
</tr>
<tr class="row-odd"><td>slt(x, y)</td>
<td>&#160;</td>
<td>F</td>
<td>1 if x &lt; y, 0 otherwise, for signed numbers in two’s complement</td>
</tr>
<tr class="row-even"><td>sgt(x, y)</td>
<td>&#160;</td>
<td>F</td>
<td>1 if x &gt; y, 0 otherwise, for signed numbers in two’s complement</td>
</tr>
<tr class="row-odd"><td>eq(x, y)</td>
<td>&#160;</td>
<td>F</td>
<td>1 if x == y, 0 otherwise</td>
</tr>
<tr class="row-even"><td>iszero(x)</td>
<td>&#160;</td>
<td>F</td>
<td>1 if x == 0, 0 otherwise</td>
</tr>
<tr class="row-odd"><td>and(x, y)</td>
<td>&#160;</td>
<td>F</td>
<td>bitwise and of x and y</td>
</tr>
<tr class="row-even"><td>or(x, y)</td>
<td>&#160;</td>
<td>F</td>
<td>bitwise or of x and y</td>
</tr>
<tr class="row-odd"><td>xor(x, y)</td>
<td>&#160;</td>
<td>F</td>
<td>bitwise xor of x and y</td>
</tr>
<tr class="row-even"><td>byte(n, x)</td>
<td>&#160;</td>
<td>F</td>
<td>nth byte of x, where the most significant byte is the 0th byte</td>
</tr>
<tr class="row-odd"><td>shl(x, y)</td>
<td>&#160;</td>
<td>C</td>
<td>logical shift left y by x bits</td>
</tr>
<tr class="row-even"><td>shr(x, y)</td>
<td>&#160;</td>
<td>C</td>
<td>logical shift right y by x bits</td>
</tr>
<tr class="row-odd"><td>sar(x, y)</td>
<td>&#160;</td>
<td>C</td>
<td>arithmetic shift right y by x bits</td>
</tr>
<tr class="row-even"><td>addmod(x, y, m)</td>
<td>&#160;</td>
<td>F</td>
<td>(x + y) % m with arbitrary precision arithmetic</td>
</tr>
<tr class="row-odd"><td>mulmod(x, y, m)</td>
<td>&#160;</td>
<td>F</td>
<td>(x * y) % m with arbitrary precision arithmetic</td>
</tr>
<tr class="row-even"><td>signextend(i, x)</td>
<td>&#160;</td>
<td>F</td>
<td>sign extend from (i*8+7)th bit counting from least significant</td>
</tr>
<tr class="row-odd"><td>keccak256(p, n)</td>
<td>&#160;</td>
<td>F</td>
<td>keccak(mem[p…(p+n)))</td>
</tr>
<tr class="row-even"><td>jump(label)</td>
<td><cite>-</cite></td>
<td>F</td>
<td>jump to label / code position</td>
</tr>
<tr class="row-odd"><td>jumpi(label, cond)</td>
<td><cite>-</cite></td>
<td>F</td>
<td>jump to label if cond is nonzero</td>
</tr>
<tr class="row-even"><td>pc</td>
<td>&#160;</td>
<td>F</td>
<td>current position in code</td>
</tr>
<tr class="row-odd"><td>pop(x)</td>
<td><cite>-</cite></td>
<td>F</td>
<td>remove the element pushed by x</td>
</tr>
<tr class="row-even"><td>dup1 … dup16</td>
<td>&#160;</td>
<td>F</td>
<td>copy nth stack slot to the top (counting from top)</td>
</tr>
<tr class="row-odd"><td>swap1 … swap16</td>
<td><cite>*</cite></td>
<td>F</td>
<td>swap topmost and nth stack slot below it</td>
</tr>
<tr class="row-even"><td>mload(p)</td>
<td>&#160;</td>
<td>F</td>
<td>mem[p…(p+32))</td>
</tr>
<tr class="row-odd"><td>mstore(p, v)</td>
<td><cite>-</cite></td>
<td>F</td>
<td>mem[p…(p+32)) := v</td>
</tr>
<tr class="row-even"><td>mstore8(p, v)</td>
<td><cite>-</cite></td>
<td>F</td>
<td>mem[p] := v &amp; 0xff (only modifies a single byte)</td>
</tr>
<tr class="row-odd"><td>sload(p)</td>
<td>&#160;</td>
<td>F</td>
<td>storage[p]</td>
</tr>
<tr class="row-even"><td>sstore(p, v)</td>
<td><cite>-</cite></td>
<td>F</td>
<td>storage[p] := v</td>
</tr>
<tr class="row-odd"><td>msize</td>
<td>&#160;</td>
<td>F</td>
<td>size of memory, i.e. largest accessed memory index</td>
</tr>
<tr class="row-even"><td>gas</td>
<td>&#160;</td>
<td>F</td>
<td>gas still available to execution</td>
</tr>
<tr class="row-odd"><td>address</td>
<td>&#160;</td>
<td>F</td>
<td>address of the current contract / execution context</td>
</tr>
<tr class="row-even"><td>balance(a)</td>
<td>&#160;</td>
<td>F</td>
<td>wei balance at address a</td>
</tr>
<tr class="row-odd"><td>caller</td>
<td>&#160;</td>
<td>F</td>
<td>call sender (excluding <code class="docutils literal notranslate"><span class="pre">delegatecall</span></code>)</td>
</tr>
<tr class="row-even"><td>callvalue</td>
<td>&#160;</td>
<td>F</td>
<td>wei sent together with the current call</td>
</tr>
<tr class="row-odd"><td>calldataload(p)</td>
<td>&#160;</td>
<td>F</td>
<td>call data starting from position p (32 bytes)</td>
</tr>
<tr class="row-even"><td>calldatasize</td>
<td>&#160;</td>
<td>F</td>
<td>size of call data in bytes</td>
</tr>
<tr class="row-odd"><td>calldatacopy(t, f, s)</td>
<td><cite>-</cite></td>
<td>F</td>
<td>copy s bytes from calldata at position f to mem at position t</td>
</tr>
<tr class="row-even"><td>codesize</td>
<td>&#160;</td>
<td>F</td>
<td>size of the code of the current contract / execution context</td>
</tr>
<tr class="row-odd"><td>codecopy(t, f, s)</td>
<td><cite>-</cite></td>
<td>F</td>
<td>copy s bytes from code at position f to mem at position t</td>
</tr>
<tr class="row-even"><td>extcodesize(a)</td>
<td>&#160;</td>
<td>F</td>
<td>size of the code at address a</td>
</tr>
<tr class="row-odd"><td>extcodecopy(a, t, f, s)</td>
<td><cite>-</cite></td>
<td>F</td>
<td>like codecopy(t, f, s) but take code at address a</td>
</tr>
<tr class="row-even"><td>returndatasize</td>
<td>&#160;</td>
<td>B</td>
<td>size of the last returndata</td>
</tr>
<tr class="row-odd"><td>returndatacopy(t, f, s)</td>
<td><cite>-</cite></td>
<td>B</td>
<td>copy s bytes from returndata at position f to mem at position t</td>
</tr>
<tr class="row-even"><td>extcodehash(a)</td>
<td>&#160;</td>
<td>C</td>
<td>code hash of address a</td>
</tr>
<tr class="row-odd"><td>create(v, p, n)</td>
<td>&#160;</td>
<td>F</td>
<td>create new contract with code mem[p…(p+n)) and send v wei
and return the new address</td>
</tr>
<tr class="row-even"><td>create2(v, p, n, s)</td>
<td>&#160;</td>
<td>C</td>
<td>create new contract with code mem[p…(p+n)) at address
keccak256(0xff . this . s . keccak256(mem[p…(p+n)))
and send v wei and return the new address, where <code class="docutils literal notranslate"><span class="pre">0xff</span></code> is a
8 byte value, <code class="docutils literal notranslate"><span class="pre">this</span></code> is the current contract’s address
as a 20 byte value and <code class="docutils literal notranslate"><span class="pre">s</span></code> is a big-endian 256-bit value</td>
</tr>
<tr class="row-odd"><td>call(g, a, v, in,
insize, out, outsize)</td>
<td>&#160;</td>
<td>F</td>
<td>call contract at address a with input mem[in…(in+insize))
providing g gas and v wei and output area
mem[out…(out+outsize)) returning 0 on error (eg. out of gas)
and 1 on success</td>
</tr>
<tr class="row-even"><td>callcode(g, a, v, in,
insize, out, outsize)</td>
<td>&#160;</td>
<td>F</td>
<td>identical to <code class="docutils literal notranslate"><span class="pre">call</span></code> but only use the code from a and stay
in the context of the current contract otherwise</td>
</tr>
<tr class="row-odd"><td>delegatecall(g, a, in,
insize, out, outsize)</td>
<td>&#160;</td>
<td>H</td>
<td>identical to <code class="docutils literal notranslate"><span class="pre">callcode</span></code> but also keep <code class="docutils literal notranslate"><span class="pre">caller</span></code>
and <code class="docutils literal notranslate"><span class="pre">callvalue</span></code></td>
</tr>
<tr class="row-even"><td>staticcall(g, a, in,
insize, out, outsize)</td>
<td>&#160;</td>
<td>B</td>
<td>identical to <code class="docutils literal notranslate"><span class="pre">call(g,</span> <span class="pre">a,</span> <span class="pre">0,</span> <span class="pre">in,</span> <span class="pre">insize,</span> <span class="pre">out,</span> <span class="pre">outsize)</span></code> but do
not allow state modifications</td>
</tr>
<tr class="row-odd"><td>return(p, s)</td>
<td><cite>-</cite></td>
<td>F</td>
<td>end execution, return data mem[p…(p+s))</td>
</tr>
<tr class="row-even"><td>revert(p, s)</td>
<td><cite>-</cite></td>
<td>B</td>
<td>end execution, revert state changes, return data mem[p…(p+s))</td>
</tr>
<tr class="row-odd"><td>selfdestruct(a)</td>
<td><cite>-</cite></td>
<td>F</td>
<td>end execution, destroy current contract and send funds to a</td>
</tr>
<tr class="row-even"><td>invalid</td>
<td><cite>-</cite></td>
<td>F</td>
<td>end execution with invalid instruction</td>
</tr>
<tr class="row-odd"><td>log0(p, s)</td>
<td><cite>-</cite></td>
<td>F</td>
<td>log without topics and data mem[p…(p+s))</td>
</tr>
<tr class="row-even"><td>log1(p, s, t1)</td>
<td><cite>-</cite></td>
<td>F</td>
<td>log with topic t1 and data mem[p…(p+s))</td>
</tr>
<tr class="row-odd"><td>log2(p, s, t1, t2)</td>
<td><cite>-</cite></td>
<td>F</td>
<td>log with topics t1, t2 and data mem[p…(p+s))</td>
</tr>
<tr class="row-even"><td>log3(p, s, t1, t2, t3)</td>
<td><cite>-</cite></td>
<td>F</td>
<td>log with topics t1, t2, t3 and data mem[p…(p+s))</td>
</tr>
<tr class="row-odd"><td>log4(p, s, t1, t2, t3,
t4)</td>
<td><cite>-</cite></td>
<td>F</td>
<td>log with topics t1, t2, t3, t4 and data mem[p…(p+s))</td>
</tr>
<tr class="row-even"><td>origin</td>
<td>&#160;</td>
<td>F</td>
<td>transaction sender</td>
</tr>
<tr class="row-odd"><td>gasprice</td>
<td>&#160;</td>
<td>F</td>
<td>gas price of the transaction</td>
</tr>
<tr class="row-even"><td>blockhash(b)</td>
<td>&#160;</td>
<td>F</td>
<td>hash of block nr b - only for last 256 blocks excluding current</td>
</tr>
<tr class="row-odd"><td>coinbase</td>
<td>&#160;</td>
<td>F</td>
<td>current mining beneficiary</td>
</tr>
<tr class="row-even"><td>timestamp</td>
<td>&#160;</td>
<td>F</td>
<td>timestamp of the current block in seconds since the epoch</td>
</tr>
<tr class="row-odd"><td>number</td>
<td>&#160;</td>
<td>F</td>
<td>current block number</td>
</tr>
<tr class="row-even"><td>difficulty</td>
<td>&#160;</td>
<td>F</td>
<td>difficulty of the current block</td>
</tr>
<tr class="row-odd"><td>gaslimit</td>
<td>&#160;</td>
<td>F</td>
<td>block gas limit of the current block</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="literals">
<h3>Literals<a class="headerlink" href="#literals" title="Permalink to this headline">¶</a></h3>
<p>10進数か16進数の表記をつけることにより整数の定数を使用することができます。そして、適切な <code class="docutils literal notranslate"><span class="pre">PUSHi</span></code> インストラクションが自動的に生成されます。下記のコードは2と3を足して5になり、文字列”abc”とのビット積をとります。
最終的な値はローカル変数の <code class="docutils literal notranslate"><span class="pre">x</span></code> に割り当てられます。
文字列は左詰めで保存され、32バイト以下でなければいけません。</p>
<div class="code highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="k">assembly</span> <span class="p">{</span> <span class="ow">let</span> <span class="nv">x</span> <span class="o">:=</span> <span class="nf">and</span><span class="p">(</span><span class="s">&quot;abc&quot;</span><span class="p">,</span> <span class="nf">add</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="functional-style">
<h3>Functional Style<a class="headerlink" href="#functional-style" title="Permalink to this headline">¶</a></h3>
<p>opcodeのシーケンスでは、あるopcodeの実際の引数が何であるか見るのが大変なことがままあります。下記の例では、位置 <code class="docutils literal notranslate"><span class="pre">0x80</span></code> にあるメモリの内容に <code class="docutils literal notranslate"><span class="pre">3</span></code> が足されます。</p>
<div class="code highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="mi">3</span> <span class="mh">0x80</span> <span class="n">mload</span> <span class="n">add</span> <span class="mh">0x80</span> <span class="n">mstore</span>
</pre></div>
</div>
<p>Solidityのインラインアセンブリは下記のように書かれる”ファンクショナルスタイル”の表記を持っています:</p>
<div class="code highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="n">mstore</span><span class="p">(</span><span class="mh">0x80</span><span class="p">,</span> <span class="n">add</span><span class="p">(</span><span class="n">mload</span><span class="p">(</span><span class="mh">0x80</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
<p>右から左に読むと、完全に同じ定数とopcodeのシーケンスとなりますが、とても読みやすいです。</p>
<p>もしスタックのレイアウトが気になるなら、覚えておいて欲しいのは、シンタックス的にファンクションもしくはopcodeの最初の引数はスタックの一番上に置かれるということです。</p>
</div>
<div class="section" id="access-to-external-variables-functions-and-libraries">
<h3>Access to External Variables, Functions and Libraries<a class="headerlink" href="#access-to-external-variables-functions-and-libraries" title="Permalink to this headline">¶</a></h3>
<p>Solidityの変数や他の識別子にはその名前でアクセスすることができます。
メモリに保存されている変数に関してはスタックに値ではなくアドレスをプッシュします。ストレージに保存されている変数はこれとは異なります。全てのストレージのスロットをおそらく占有しないので、”アドレス”はスロットとスロット内のバイトオフセットで構成されています。変数 <code class="docutils literal notranslate"><span class="pre">x</span></code> でポイントされているスロットを読み出すには <code class="docutils literal notranslate"><span class="pre">x_slot</span></code> を使用してください。バイトオフセットを読み出すには、<code class="docutils literal notranslate"><span class="pre">x_offset</span></code> を使用してください。</p>
<p>Solidityのローカル変数は割り当て可能です。例えば:</p>
<div class="code highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">11</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="n">b</span><span class="p">;</span>
    <span class="kd">function</span> <span class="n">f</span><span class="p">(</span><span class="kt">uint</span> <span class="n">x</span><span class="p">)</span> <span class="kr">public</span> <span class="kr">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">assembly</span> <span class="p">{</span>
            <span class="n">r</span> <span class="o">:=</span> <span class="nf">mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nf">sload</span><span class="p">(</span><span class="n">b_slot</span><span class="p">))</span> <span class="c1">// ignore the offset, we know it is zero</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">256ビット未満の型の変数（例えば、<code class="docutils literal notranslate"><span class="pre">uint64</span></code>、<code class="docutils literal notranslate"><span class="pre">address</span></code>、<code class="docutils literal notranslate"><span class="pre">bytes16</span></code>、<code class="docutils literal notranslate"><span class="pre">byte</span></code>）にアクセスする場合、型のエンコーディングの一部ではないビットに対してどんな想定もできません。特にゼロと想定してはいけません。
安全のために、コンテキスト内で使う前に常にデータを適切にクリアしてください:
<code class="docutils literal notranslate"><span class="pre">uint32</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">f();</span> <span class="pre">assembly</span> <span class="pre">{</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">and(x,</span> <span class="pre">0xffffffff)</span> <span class="pre">/*</span> <span class="pre">now</span> <span class="pre">use</span> <span class="pre">x</span> <span class="pre">*/</span> <span class="pre">}</span></code>
符号付の型をクリアするのに <code class="docutils literal notranslate"><span class="pre">signextend</span></code> opcodeが使用できます。</p>
</div>
</div>
<div class="section" id="labels">
<h3>Labels<a class="headerlink" href="#labels" title="Permalink to this headline">¶</a></h3>
<p>ラベルのサポートはSolidity 0.5.0版で削除されました。
ファンクション、ループ、if文、switch文を代わりに使用してください。</p>
</div>
<div class="section" id="declaring-assembly-local-variables">
<h3>Declaring Assembly-Local Variables<a class="headerlink" href="#declaring-assembly-local-variables" title="Permalink to this headline">¶</a></h3>
<p>変数を宣言するのに、<code class="docutils literal notranslate"><span class="pre">let</span></code> キーワードを使用することができます。letはインラインアセンブリ内でのみ、実際には現在の <code class="docutils literal notranslate"><span class="pre">{...}</span></code>-block内でのみのスコープです。
<code class="docutils literal notranslate"><span class="pre">let</span></code> は新しい変数のためのスタックのスロットを作り、ブロックの最後に達したら自動的に削除されます。
その変数には初期値を与える必要があります。ただの <code class="docutils literal notranslate"><span class="pre">0</span></code> でも良いですが、複雑なファンクショナルスタイルの式でも構いません。</p>
<div class="code highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">f</span><span class="p">(</span><span class="kt">uint</span> <span class="n">x</span><span class="p">)</span> <span class="kr">public</span> <span class="kr">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">assembly</span> <span class="p">{</span>
            <span class="ow">let</span> <span class="nv">v</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="nf">mstore</span><span class="p">(</span><span class="mh">0x80</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="ow">let</span> <span class="nv">y</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nf">sload</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">b</span> <span class="o">:=</span> <span class="n">y</span>
            <span class="p">}</span> <span class="c1">// y is &quot;deallocated&quot; here</span>
            <span class="n">b</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="p">}</span> <span class="c1">// v is &quot;deallocated&quot; here</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="assignments">
<h3>Assignments<a class="headerlink" href="#assignments" title="Permalink to this headline">¶</a></h3>
<p>値の割り当てはアセンブリのローカル変数とファンクションのローカル変数へ可能です。メモリやストレージの変数を割り当てる時に注意したいのは、それはポインタを変えるだけで、データを変えているわけではないということです。</p>
<p>1つの値に落ち着く式しか変数に割り当てることはできません。
もし複数の値を返すファンクションから受け取った値を変数に割り当てたいときは、複数の変数を用意しなければいけません。</p>
<div class="code highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="n">let</span> <span class="n">v</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="n">let</span> <span class="n">g</span> <span class="o">:=</span> <span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="kd">function</span> <span class="n">f</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">{</span> <span class="p">}</span>
    <span class="n">let</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">:=</span> <span class="n">f</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="if">
<h3>If<a class="headerlink" href="#if" title="Permalink to this headline">¶</a></h3>
<p>if文は条件分岐で使用できます。
“else”部分はありません。複数の条件分岐があるのであれば、”switch”の使用を検討してください（下記参照）。</p>
<div class="code highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="k">if</span> <span class="n">eq</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nf">revert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ボディには波括弧が必要です。</p>
</div>
<div class="section" id="switch">
<h3>Switch<a class="headerlink" href="#switch" title="Permalink to this headline">¶</a></h3>
<p>基本的な”if/else”文として、switch文が使用可能です。
ある式の値をとって、それをいくつかの定数と比較します。
条件に合う定数の分岐が選ばれます。
間違いを起こしやすいいくつかのプログラミング言語とは異なり、操作フローはある条件から次の条件へコンテニューしません。フォールバックもしくは <code class="docutils literal notranslate"><span class="pre">default</span></code> というデフォルトの条件が使えます。</p>
<div class="code highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="n">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="n">switch</span> <span class="n">calldataload</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">case</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">:=</span> <span class="n">calldataload</span><span class="p">(</span><span class="mh">0x24</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="kr">default</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">:=</span> <span class="n">calldataload</span><span class="p">(</span><span class="mh">0x44</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">sstore</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">div</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>条件のリストでは波括弧は必要ありませんが、ボディでは必要となります。</p>
</div>
<div class="section" id="loops">
<h3>Loops<a class="headerlink" href="#loops" title="Permalink to this headline">¶</a></h3>
<p>アセンブリは単純なforループをサポートしています。forループは初期化部分、条件、イテレーション後のパートを含むヘッダを持っています。条件はファンクショナルスタイルの式である必要がありますが、他の2つはブロックです。初期化部分で変数を宣言した場合、この変数のスコープは本体（条件、イテレーション後のパートを含む）に拡張されます。</p>
<p>次の例ではメモリ内のある領域の合計を計算しています。</p>
<div class="code highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="n">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="p">{</span> <span class="n">let</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span> <span class="p">}</span> <span class="n">lt</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">)</span> <span class="p">{</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">)</span> <span class="p">}</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">:=</span> <span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mload</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>　forループはwhileループの様に書くこともできます:単純に初期化部分とイテレーション後のパートを空にします。</p>
<div class="code highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="n">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="n">let</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="p">{</span> <span class="p">}</span> <span class="n">lt</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="p">{</span>     <span class="c1">// while(i &lt; 0x100)</span>
        <span class="n">x</span> <span class="o">:=</span> <span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mload</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="n">i</span> <span class="o">:=</span> <span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<p>アセンブリは低レベルファンクションの定義もできます。
このファンクションは引数（とリターンPC）をスタックからとってきます。また、スタックに結果をプットします。ファンクションの呼び出しはファンクショナルスタイルの実行のopcodeと同様な方法に見えます。</p>
<p>ファンクションはどこでも定義することができて、宣言されたブロック内がスコープになります。ファンクション内では、ファンクション外で宣言されたローカル変数にはアクセスできません。明示的な <code class="docutils literal notranslate"><span class="pre">return</span></code> の宣言はありません。</p>
<p>複数の値を返すファンクションをコールする場合、<code class="docutils literal notranslate"><span class="pre">a,</span> <span class="pre">b</span> <span class="pre">:=</span> <span class="pre">f(x)</span></code> or <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">a,</span> <span class="pre">b</span> <span class="pre">:=</span> <span class="pre">f(x)</span></code> を使って、その値をタプルに割り当てなければいけません。</p>
<p>下記の例では二乗と乗算を使った累乗の計算をしています。</p>
<div class="code highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="kd">function</span> <span class="n">power</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exponent</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">result</span> <span class="p">{</span>
        <span class="n">switch</span> <span class="n">exponent</span>
        <span class="n">case</span> <span class="mi">0</span> <span class="p">{</span> <span class="n">result</span> <span class="o">:=</span> <span class="mi">1</span> <span class="p">}</span>
        <span class="n">case</span> <span class="mi">1</span> <span class="p">{</span> <span class="n">result</span> <span class="o">:=</span> <span class="n">base</span> <span class="p">}</span>
        <span class="kr">default</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">:=</span> <span class="n">power</span><span class="p">(</span><span class="n">mul</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">base</span><span class="p">),</span> <span class="n">div</span><span class="p">(</span><span class="n">exponent</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">switch</span> <span class="n">mod</span><span class="p">(</span><span class="n">exponent</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">case</span> <span class="mi">1</span> <span class="p">{</span> <span class="n">result</span> <span class="o">:=</span> <span class="n">mul</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span> <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="things-to-avoid">
<h3>Things to Avoid<a class="headerlink" href="#things-to-avoid" title="Permalink to this headline">¶</a></h3>
<p>インラインアセンブリはかなり高いレベルに見えるかもしれませんが、実際は非常に低レベルです。ファンクションコール、ループ、if文、switch文は単純なルールの書き換えで変換されます。その後アセンブラがするのはファンクショナルスタイルのopcodeを再度並び替え、変数アクセスのためのスタックハイトを数え、ブロックの最後になったらアセンブリローカル変数のためのスタックのスロットを削除するということだけです。</p>
</div>
<div class="section" id="conventions-in-solidity">
<h3>Conventions in Solidity<a class="headerlink" href="#conventions-in-solidity" title="Permalink to this headline">¶</a></h3>
<p>EVMアセンブリと異なり、Solidityは <code class="docutils literal notranslate"><span class="pre">uint24</span></code> の様な256ビットより小さい型を識別できます。効率的にするために、ほとんどの算術演算はその型を256ビットの値として扱い、はみ出た分のビットは必要な時に処理します。例えば、メモリに書き込まれる直前や、比較演算がされる時です。つまり、もしインラインアセンブリ内の変数にアクセスする時には、まずマニュアルでそのはみ出たビットを処理する必要があるかもしれません。</p>
<p>Solidityはメモリはとてもシンプルな方法で管理しています。
メモリ内の <code class="docutils literal notranslate"><span class="pre">0x40</span></code> に”free memory pointer”があります。メモリを振り分ける時に、このポインタが示しているメモリから始めて、順にアップデートしていくだけです。
そのメモリが以前に使われていたかどうかの保証はないので、その中身がゼロであると仮定はできません。
メモリを解放したり、好きなところにメモリを割り当てる内蔵機能は付いていません。
下記はメモリの割り当てのアセンブリの例です:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="n">allocate</span><span class="p">(</span><span class="n">length</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pos</span> <span class="p">{</span>
  <span class="n">pos</span> <span class="o">:=</span> <span class="n">mload</span><span class="p">(</span><span class="mh">0x40</span><span class="p">)</span>
  <span class="n">mstore</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span> <span class="n">add</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">length</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>メモリの最初の64バイトは短期間の割り当てのための”scratch space”として使うことができます。フリーメモリポインタ（ <code class="docutils literal notranslate"><span class="pre">0x60</span></code> から始まる様な）の32バイト後はずっと0であるはずで、空の動的メモリ配列の初期値として使われます。
つまり、割り当て可能なメモリは <code class="docutils literal notranslate"><span class="pre">0x80</span></code> から始まり、それはフリーメモリポインタの初期値です。</p>
<p>Solidityのメモリ配列の要素は常に32バイトの倍数を占めています（これは <code class="docutils literal notranslate"><span class="pre">byte[]</span></code> では同じですが、<code class="docutils literal notranslate"><span class="pre">bytes</span></code> と <code class="docutils literal notranslate"><span class="pre">string</span></code> では違います）。多次元メモリ配列はメモリ配列のポインタです。動的配列の長さは配列の最初のスロットに保存され、その他に配列の要素が続きます。</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">静的サイズのメモリ配列は長さの領域を持っていません。しかし、今後静的配列と動的配列の互換性のために追加されるかもしれません。</p>
</div>
</div>
</div>
<div class="section" id="standalone-assembly">
<h2>Standalone Assembly<a class="headerlink" href="#standalone-assembly" title="Permalink to this headline">¶</a></h2>
<p>上記でインラインアセンブリとして紹介したアセンブリ言語はスタンドアローンとしても使用可能で、実はSolidityのコンパイラとの中間言語として使用する予定です。ここでは、いくつか達成したいことがあります:</p>
<ol class="arabic simple">
<li>その中で書かれたプログラムはSolidityからコンパイラを通じて生成されたとしても読んで理解できるものであるべきです。</li>
<li>アセンブリからバイトコードへの変換は可能な限り”サプライズ”を含まない様にするべきです。</li>
<li>制御フローは形式的検証や最適化をしやすくするために、簡単に検知されるべきです。</li>
</ol>
<p>最初と最後の目標を達成するためにアセンブリでは <code class="docutils literal notranslate"><span class="pre">for</span></code> ループ、<code class="docutils literal notranslate"><span class="pre">if</span></code>、<code class="docutils literal notranslate"><span class="pre">switch</span></code> 文の様な高レベルの概念やファンクションコールが使えます。明示的な <code class="docutils literal notranslate"><span class="pre">SWAP</span></code>、<code class="docutils literal notranslate"><span class="pre">DUP</span></code>、<code class="docutils literal notranslate"><span class="pre">JUMP</span></code>、<code class="docutils literal notranslate"><span class="pre">JUMPI</span></code> を使わないアセンブリのプログラムを書くことが可能であるべきです。なぜなら初めの2つはデータフローを分かりにくくし、後の2つは制御フローを分かりにくくするからです。
さらに、<code class="docutils literal notranslate"><span class="pre">mul(add(x,</span> <span class="pre">y),</span> <span class="pre">7)</span></code> という形のファンクショナルステートメントは <code class="docutils literal notranslate"><span class="pre">7</span> <span class="pre">y</span> <span class="pre">x</span> <span class="pre">add</span> <span class="pre">mul</span></code> の様なピュアなopcodeより好ましいです。なぜならば、最初の式の方がどっちのオペランドにどっちのopcodeを使うのか分かりやすいからです。</p>
<p>2つ目の目標に関しては、とても標準的な方法でより高いレベルの概念からバイトコードにコンパイルすることで達成します。
アセンブラによって行われる唯一の非ローカル演算は、ユーザー定義の識別子（ファンクション、変数など）の名前検索です。その演算ではとてもシンプルで標準的なスコープのルールに則り、また標準的な方法でスタックからのローカル変数の削除します。</p>
<p>Scoping: 宣言された識別子（ラベル、変数、ファンクション、アセンブリ）は宣言されたブロック内（現在のブロックの内側のネストされたブロックも含む）のみがスコープとなります。たとえスコープ内だったとしてもファンクションの垣根を超えてローカル変数にはアクセスできません。シャドーイングは使えません。
ローカル変数は宣言前には使えませんが、ファンクションやアセンブリは使用可能です。アセンブリはランタイムコードを返したり、コントラクトの作成に使われる特別なブロックです。アウターのアセンブリの識別子はサブアセンブリの中では使えません。</p>
<p>もし制御フローが最後のブロックを通ったら、ブロック内で宣言されたローカル変数の数だけポップの命令が挿入されます。
ローカル変数がリファレンスされる時は、コードジェネレータはスタック内でのその変数の相対的な位置を把握している必要があり、そのためいわゆるブロックハイトをトラックしています。ブロックの最後に全てのローカル変数は削除されるので、スタックハイトはブロックの前後で同じのはずです。もし同じでない場合、コンパイルは失敗します。</p>
<p><code class="docutils literal notranslate"><span class="pre">switch</span></code>、<code class="docutils literal notranslate"><span class="pre">for</span></code>、ファンクションを使えば、手動で <code class="docutils literal notranslate"><span class="pre">jump</span></code> もしくは <code class="docutils literal notranslate"><span class="pre">jumpi</span></code> を使わずに複雑なコードが書けるはずです。これにより制御フローの分析がとても簡単になり、形式的検証や最適化が改善されます。</p>
<p>さらに、手動でのジャンプができると、スタックハイトの計算はむしろ複雑になります。全てのスタック上のローカル変数の位置は既知である必要あり、そうでなければ、ローカル変数への参照やブロックの最後に自動でスタックからローカル変数を削除する機能はちゃんと動作しません。</p>
<p>Example:</p>
<p>Solidityからアセンブリへのコンパイル例を見てみましょう。
下記のラインタイムバイトコードを考えます:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">C</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="n">f</span><span class="p">(</span><span class="kt">uint</span> <span class="n">x</span><span class="p">)</span> <span class="kr">public</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>以下のアセンブリが生成されます:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="n">mstore</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">)</span> <span class="c1">// store the &quot;free memory pointer&quot;</span>
  <span class="c1">// function dispatcher</span>
  <span class="n">switch</span> <span class="n">div</span><span class="p">(</span><span class="n">calldataload</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">226</span><span class="p">))</span>
  <span class="n">case</span> <span class="mh">0xb3de648b</span> <span class="p">{</span>
    <span class="n">let</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">f</span><span class="p">(</span><span class="n">calldataload</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
    <span class="n">let</span> <span class="n">ret</span> <span class="o">:=</span> <span class="err">$</span><span class="n">allocate</span><span class="p">(</span><span class="mh">0x20</span><span class="p">)</span>
    <span class="n">mstore</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
    <span class="k">return</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="kr">default</span> <span class="p">{</span> <span class="nf">revert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">}</span>
  <span class="c1">// memory allocator</span>
  <span class="kd">function</span> <span class="err">$</span><span class="n">allocate</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pos</span> <span class="p">{</span>
    <span class="n">pos</span> <span class="o">:=</span> <span class="n">mload</span><span class="p">(</span><span class="mh">0x40</span><span class="p">)</span>
    <span class="n">mstore</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span> <span class="n">add</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
  <span class="p">}</span>
  <span class="c1">// the contract function</span>
  <span class="kd">function</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">y</span> <span class="p">{</span>
    <span class="n">y</span> <span class="o">:=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="p">{</span> <span class="n">let</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span> <span class="p">}</span> <span class="n">lt</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span> <span class="p">{</span>
      <span class="n">y</span> <span class="o">:=</span> <span class="n">mul</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="assembly-grammar">
<h3>Assembly Grammar<a class="headerlink" href="#assembly-grammar" title="Permalink to this headline">¶</a></h3>
<p>パーサのタスクは下記の通りです:</p>
<ul class="simple">
<li>バイトストリームをトークンストリームにし、C++スタイルのコメントを破棄します（参照ソースには特別なコメントがありますが、ここでは割愛します）。</li>
<li>下記のグラマーに従って、トークンストリームをASTにします。</li>
<li>識別子をその識別子が定義されたブロックと一緒に登録します（ASTノードへの注記）。どこから変数にアクセスできるか注意してください。</li>
</ul>
<p>アセンブリの字句解析器はSolidityで定義されたものに従います。</p>
<p>ホワイトスペース（空白文字、タブ、改行）はトークンの範囲を決めるのに使用されます。コメントは標準のJavaScript/C++のコメントで、ホワイトスペースと同様に変換されます。</p>
<p>Grammar:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="n">AssemblyBlock</span> <span class="o">=</span> <span class="s">&#39;{&#39;</span> <span class="n">AssemblyItem</span><span class="o">*</span> <span class="s">&#39;}&#39;</span>
<span class="n">AssemblyItem</span> <span class="o">=</span>
    <span class="n">Identifier</span> <span class="o">|</span>
    <span class="n">AssemblyBlock</span> <span class="o">|</span>
    <span class="n">AssemblyExpression</span> <span class="o">|</span>
    <span class="n">AssemblyLocalDefinition</span> <span class="o">|</span>
    <span class="n">AssemblyAssignment</span> <span class="o">|</span>
    <span class="n">AssemblyStackAssignment</span> <span class="o">|</span>
    <span class="n">LabelDefinition</span> <span class="o">|</span>
    <span class="n">AssemblyIf</span> <span class="o">|</span>
    <span class="n">AssemblySwitch</span> <span class="o">|</span>
    <span class="n">AssemblyFunctionDefinition</span> <span class="o">|</span>
    <span class="n">AssemblyFor</span> <span class="o">|</span>
    <span class="s">&#39;break&#39;</span> <span class="o">|</span>
    <span class="s">&#39;continue&#39;</span> <span class="o">|</span>
    <span class="n">SubAssembly</span>
<span class="n">AssemblyExpression</span> <span class="o">=</span> <span class="n">AssemblyCall</span> <span class="o">|</span> <span class="n">Identifier</span> <span class="o">|</span> <span class="n">AssemblyLiteral</span>
<span class="n">AssemblyLiteral</span> <span class="o">=</span> <span class="n">NumberLiteral</span> <span class="o">|</span> <span class="n">StringLiteral</span> <span class="o">|</span> <span class="n">HexLiteral</span>
<span class="n">Identifier</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">-</span><span class="n">zA</span><span class="o">-</span><span class="n">Z_</span><span class="err">$</span><span class="p">]</span> <span class="p">[</span><span class="n">a</span><span class="o">-</span><span class="n">zA</span><span class="o">-</span><span class="n">Z_0</span><span class="o">-</span><span class="mi">9</span><span class="p">]</span><span class="o">*</span>
<span class="n">AssemblyCall</span> <span class="o">=</span> <span class="n">Identifier</span> <span class="s">&#39;(&#39;</span> <span class="p">(</span> <span class="n">AssemblyExpression</span> <span class="p">(</span> <span class="s">&#39;,&#39;</span> <span class="n">AssemblyExpression</span> <span class="p">)</span><span class="o">*</span> <span class="p">)</span><span class="o">?</span> <span class="s">&#39;)&#39;</span>
<span class="n">AssemblyLocalDefinition</span> <span class="o">=</span> <span class="s">&#39;let&#39;</span> <span class="n">IdentifierOrList</span> <span class="p">(</span> <span class="s">&#39;:=&#39;</span> <span class="n">AssemblyExpression</span> <span class="p">)</span><span class="o">?</span>
<span class="n">AssemblyAssignment</span> <span class="o">=</span> <span class="n">IdentifierOrList</span> <span class="s">&#39;:=&#39;</span> <span class="n">AssemblyExpression</span>
<span class="n">IdentifierOrList</span> <span class="o">=</span> <span class="n">Identifier</span> <span class="o">|</span> <span class="s">&#39;(&#39;</span> <span class="n">IdentifierList</span> <span class="s">&#39;)&#39;</span>
<span class="n">IdentifierList</span> <span class="o">=</span> <span class="n">Identifier</span> <span class="p">(</span> <span class="s">&#39;,&#39;</span> <span class="n">Identifier</span><span class="p">)</span><span class="o">*</span>
<span class="n">AssemblyStackAssignment</span> <span class="o">=</span> <span class="s">&#39;=:&#39;</span> <span class="n">Identifier</span>
<span class="n">LabelDefinition</span> <span class="o">=</span> <span class="n">Identifier</span> <span class="s">&#39;:&#39;</span>
<span class="n">AssemblyIf</span> <span class="o">=</span> <span class="s">&#39;if&#39;</span> <span class="n">AssemblyExpression</span> <span class="n">AssemblyBlock</span>
<span class="n">AssemblySwitch</span> <span class="o">=</span> <span class="s">&#39;switch&#39;</span> <span class="n">AssemblyExpression</span> <span class="n">AssemblyCase</span><span class="o">*</span>
    <span class="p">(</span> <span class="s">&#39;default&#39;</span> <span class="n">AssemblyBlock</span> <span class="p">)</span><span class="o">?</span>
<span class="n">AssemblyCase</span> <span class="o">=</span> <span class="s">&#39;case&#39;</span> <span class="n">AssemblyExpression</span> <span class="n">AssemblyBlock</span>
<span class="n">AssemblyFunctionDefinition</span> <span class="o">=</span> <span class="s">&#39;function&#39;</span> <span class="n">Identifier</span> <span class="s">&#39;(&#39;</span> <span class="n">IdentifierList</span><span class="o">?</span> <span class="s">&#39;)&#39;</span>
    <span class="p">(</span> <span class="s">&#39;-&gt;&#39;</span> <span class="s">&#39;(&#39;</span> <span class="n">IdentifierList</span> <span class="s">&#39;)&#39;</span> <span class="p">)</span><span class="o">?</span> <span class="n">AssemblyBlock</span>
<span class="n">AssemblyFor</span> <span class="o">=</span> <span class="s">&#39;for&#39;</span> <span class="p">(</span> <span class="n">AssemblyBlock</span> <span class="o">|</span> <span class="n">AssemblyExpression</span> <span class="p">)</span>
    <span class="n">AssemblyExpression</span> <span class="p">(</span> <span class="n">AssemblyBlock</span> <span class="o">|</span> <span class="n">AssemblyExpression</span> <span class="p">)</span> <span class="n">AssemblyBlock</span>
<span class="n">SubAssembly</span> <span class="o">=</span> <span class="s">&#39;assembly&#39;</span> <span class="n">Identifier</span> <span class="n">AssemblyBlock</span>
<span class="n">NumberLiteral</span> <span class="o">=</span> <span class="n">HexNumber</span> <span class="o">|</span> <span class="n">DecimalNumber</span>
<span class="n">HexLiteral</span> <span class="o">=</span> <span class="s">&#39;hex&#39;</span> <span class="p">(</span><span class="s">&#39;&quot;&#39;</span> <span class="p">([</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="n">a</span><span class="o">-</span><span class="n">fA</span><span class="o">-</span><span class="n">F</span><span class="p">]{</span><span class="mi">2</span><span class="p">})</span><span class="o">*</span> <span class="s">&#39;&quot;&#39;</span> <span class="o">|</span> <span class="s">&#39;</span><span class="se">\&#39;</span><span class="s">&#39;</span> <span class="p">([</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="n">a</span><span class="o">-</span><span class="n">fA</span><span class="o">-</span><span class="n">F</span><span class="p">]{</span><span class="mi">2</span><span class="p">})</span><span class="o">*</span> <span class="s">&#39;</span><span class="se">\&#39;</span><span class="s">&#39;</span><span class="p">)</span>
<span class="n">StringLiteral</span> <span class="o">=</span> <span class="s">&#39;&quot;&#39;</span> <span class="p">([</span><span class="o">^</span><span class="s">&quot;</span><span class="se">\r\n\\</span><span class="s">] | &#39;</span><span class="se">\\</span><span class="s">&#39; .)* &#39;&quot;&#39;</span>
<span class="n">HexNumber</span> <span class="o">=</span> <span class="s">&#39;0x&#39;</span> <span class="p">[</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="n">a</span><span class="o">-</span><span class="n">fA</span><span class="o">-</span><span class="n">F</span><span class="p">]</span><span class="o">+</span>
<span class="n">DecimalNumber</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="p">]</span><span class="o">+</span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="miscellaneous.html" class="btn btn-neutral float-right" title="Miscellaneous" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="contracts.html" class="btn btn-neutral float-left" title="Contracts" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016-2019, Ethereum

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>