

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Contracts &mdash; Solidity 0.5.4 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Solidity Assembly" href="assembly.html" />
    <link rel="prev" title="Expressions and Control Structures" href="control-structures.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Solidity
          

          
          </a>

          
            
            
              <div class="version">
                0.5.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
    
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction-to-smart-contracts.html">Introduction to Smart Contracts</a></li>
<li class="toctree-l1"><a class="reference internal" href="installing-solidity.html">Installing the Solidity Compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="solidity-by-example.html">Solidity by Example</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="solidity-in-depth.html">Solidity in Depth</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="layout-of-source-files.html">Layout of a Solidity Source File</a></li>
<li class="toctree-l2"><a class="reference internal" href="structure-of-a-contract.html">Structure of a Contract</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="units-and-global-variables.html">Units and Globally Available Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="control-structures.html">Expressions and Control Structures</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Contracts</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#creating-contracts">Creating Contracts</a></li>
<li class="toctree-l3"><a class="reference internal" href="#visibility-and-getters">Visibility and Getters</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#getter-functions">Getter Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#function-modifiers">Function Modifiers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#constant-state-variables">Constant State Variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="#functions">Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#function-parameters-and-return-variables">Function Parameters and Return Variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="#view-functions">View Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pure-functions">Pure Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fallback-function">Fallback Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#function-overloading">Function Overloading</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#events">Events</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#low-level-interface-to-logs">Low-Level Interface to Logs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#additional-resources-for-understanding-events">Additional Resources for Understanding Events</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#inheritance">Inheritance</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#constructors">Constructors</a></li>
<li class="toctree-l4"><a class="reference internal" href="#arguments-for-base-constructors">Arguments for Base Constructors</a></li>
<li class="toctree-l4"><a class="reference internal" href="#multiple-inheritance-and-linearization">Multiple Inheritance and Linearization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inheriting-different-kinds-of-members-of-the-same-name">Inheriting Different Kinds of Members of the Same Name</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#abstract-contracts">Abstract Contracts</a></li>
<li class="toctree-l3"><a class="reference internal" href="#interfaces">Interfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="#libraries">Libraries</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#call-protection-for-libraries">Call Protection For Libraries</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#using-for">Using For</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="assembly.html">Solidity Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html">Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="050-breaking-changes.html">Solidity v0.5.0 Breaking Changes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="security-considerations.html">Security Considerations</a></li>
<li class="toctree-l1"><a class="reference internal" href="resources.html">Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="using-the-compiler.html">Using the compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="metadata.html">Contract Metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="abi-spec.html">Contract ABI Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="yul.html">Yul</a></li>
<li class="toctree-l1"><a class="reference internal" href="style-guide.html">Style Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="common-patterns.html">Common Patterns</a></li>
<li class="toctree-l1"><a class="reference internal" href="bugs.html">List of Known Bugs</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="frequently-asked-questions.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="lll.html">LLL</a></li>
</ul>

            
          
    <a href="genindex.html">Keyword Index</a>
  
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Solidity</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="solidity-in-depth.html">Solidity in Depth</a> &raquo;</li>
        
      <li>Contracts</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/contracts.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="contracts">
<span id="index-0"></span><span id="id1"></span><h1>Contracts<a class="headerlink" href="#contracts" title="Permalink to this headline">¶</a></h1>
<p>Solidityに置けるコントラクトはオブジェクト指向の言語におけるクラスに似ています。コントラクトは永続的な状態変数とそれを変更するファンクションを保持しています。異なるコントラクト上（インスタンス上）のファンクションコールはEVMのファンクションコールとなり、その結果コンテクストが変わり、状態変数にアクセスできなくなります。コントラクトとそのファンクションは呼び出さないと動きません。Ethereumには”cron”の様に特定のイベントで自動的にファンクションを呼び出す機能はありません。</p>
<div class="section" id="creating-contracts">
<span id="index-1"></span><h2>Creating Contracts<a class="headerlink" href="#creating-contracts" title="Permalink to this headline">¶</a></h2>
<p>コントラクトはEthreumトランザクションを通じて”外部から”、もしくはSolidityコントラクトの内側から作成可能です。</p>
<p><a class="reference external" href="https://remix.ethereum.org/">Remix</a> の様なIDEはUIの要素を使って、シームレスに生成プロセスを作ります。</p>
<p>Ethreum上にプログラムでコントラクトを作成するにはJavaScript API <a class="reference external" href="https://github.com/ethereum/web3.js">web3.js</a> を使うのがベストです。
web3.jsは簡単にコントラクトを作るための <a class="reference external" href="https://web3js.readthedocs.io/en/1.0/web3-eth-contract.html#new-contract">web3.eth.Contract</a> というファンクションを持っています。</p>
<p>コントラクトが作られた時、<a class="reference internal" href="#constructor"><span class="std std-ref">constructor</span></a>  ( <code class="docutils literal notranslate"><span class="pre">constructor</span></code> キーワードで宣言されるファンクション)が一度だけ実行されます。</p>
<p>コンストラクタはオプションです。1つのコンストラクタだけ使えます。つまりオーバーロードはサポートされていません。</p>
<p>コンストラクタが実行された後、最終的なコントラクトのコードがブロックチェーン上にデプロイされます。このコードは全てのpublic、externalのファンクションを含んでおり、全てのファンクションはファンクションコールを通じてそのコードからアクセスできます。デプロイされたコードはコンストラクタもしくはコンストラクタによって呼ばれたinternalのファンクションだけ含んでいません。</p>
<p id="index-2">内部的にはコントラクトのコードの後、コンストラクタの引数は <a class="reference internal" href="abi-spec.html#abi"><span class="std std-ref">ABI encoded</span></a> されて渡されますが、もし <code class="docutils literal notranslate"><span class="pre">web3.js</span></code> を使っているのであればきにする必要はありません。</p>
<p>もしコントラクトが別のコントラクトを作りたい場合、作成されたコントラクトのソースコード（とそのバイナリ）は作成者によって把握されている必要があります。
つまり、cyclic creation dependenciesは出来ないということです。</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">22</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">OwnedToken</span> <span class="p">{</span>
    <span class="c1">// `TokenCreator` is a contract type that is defined below.</span>
    <span class="c1">// It is fine to reference it as long as it is not used</span>
    <span class="c1">// to create a new contract.</span>
    <span class="n">TokenCreator</span> <span class="n">creator</span><span class="p">;</span>
    <span class="kt">address</span> <span class="n">owner</span><span class="p">;</span>
    <span class="kt">bytes32</span> <span class="n">name</span><span class="p">;</span>

    <span class="c1">// This is the constructor which registers the</span>
    <span class="c1">// creator and the assigned name.</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="kt">bytes32</span> <span class="n">_name</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="c1">// State variables are accessed via their name</span>
        <span class="c1">// and not via e.g. `this.owner`. Functions can</span>
        <span class="c1">// be accessed directly or through `this.f`,</span>
        <span class="c1">// but the latter provides an external view</span>
        <span class="c1">// to the function. Especially in the constructor,</span>
        <span class="c1">// you should not access functions externally,</span>
        <span class="c1">// because the function does not exist yet.</span>
        <span class="c1">// See the next section for details.</span>
        <span class="n">owner</span> <span class="o">=</span> <span class="nb">msg.sender</span><span class="p">;</span>

        <span class="c1">// We do an explicit type conversion from `address`</span>
        <span class="c1">// to `TokenCreator` and assume that the type of</span>
        <span class="c1">// the calling contract is `TokenCreator`, there is</span>
        <span class="c1">// no real way to check that.</span>
        <span class="n">creator</span> <span class="o">=</span> <span class="n">TokenCreator</span><span class="p">(</span><span class="nb">msg.sender</span><span class="p">);</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">_name</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">changeName</span><span class="p">(</span><span class="kt">bytes32</span> <span class="n">newName</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="c1">// Only the creator can alter the name --</span>
        <span class="c1">// the comparison is possible since contracts</span>
        <span class="c1">// are explicitly convertible to addresses.</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">msg.sender</span> <span class="o">==</span> <span class="kt">address</span><span class="p">(</span><span class="n">creator</span><span class="p">))</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">newName</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nf">transfer</span><span class="p">(</span><span class="kt">address</span> <span class="n">newOwner</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="c1">// Only the current owner can transfer the token.</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">msg.sender</span> <span class="o">!=</span> <span class="n">owner</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

        <span class="c1">// We ask the creator contract if the transfer</span>
        <span class="c1">// should proceed by using a function of the</span>
        <span class="c1">// `TokenCreator` contract defined below. If</span>
        <span class="c1">// the call fails (e.g. due to out-of-gas),</span>
        <span class="c1">// the execution also fails here.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">creator</span><span class="p">.</span><span class="n">isTokenTransferOK</span><span class="p">(</span><span class="n">owner</span><span class="p">,</span> <span class="n">newOwner</span><span class="p">))</span>
            <span class="n">owner</span> <span class="o">=</span> <span class="n">newOwner</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">TokenCreator</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">createToken</span><span class="p">(</span><span class="kt">bytes32</span> <span class="n">name</span><span class="p">)</span>
       <span class="kr">public</span>
       <span class="k">returns</span> <span class="p">(</span><span class="n">OwnedToken</span> <span class="n">tokenAddress</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Create a new `Token` contract and return its address.</span>
        <span class="c1">// From the JavaScript side, the return type is</span>
        <span class="c1">// `address`, as this is the closest type available in</span>
        <span class="c1">// the ABI.</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">OwnedToken</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">changeName</span><span class="p">(</span><span class="n">OwnedToken</span> <span class="n">tokenAddress</span><span class="p">,</span> <span class="kt">bytes32</span> <span class="n">name</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="c1">// Again, the external type of `tokenAddress` is</span>
        <span class="c1">// simply `address`.</span>
        <span class="n">tokenAddress</span><span class="p">.</span><span class="n">changeName</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Perform checks to determine if transferring a token to the</span>
    <span class="c1">// `OwnedToken` contract should proceed</span>
    <span class="kd">function</span> <span class="n">isTokenTransferOK</span><span class="p">(</span><span class="kt">address</span> <span class="n">currentOwner</span><span class="p">,</span> <span class="kt">address</span> <span class="n">newOwner</span><span class="p">)</span>
        <span class="kr">public</span>
        <span class="kr">pure</span>
        <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span> <span class="n">ok</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Check an arbitrary condition to see if transfer should proceed</span>
        <span class="k">return</span> <span class="nf">keccak256</span><span class="p">(</span><span class="nb">abi.encodePacked</span><span class="p">(</span><span class="n">currentOwner</span><span class="p">,</span> <span class="n">newOwner</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x7f</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="visibility-and-getters">
<span id="index-3"></span><span id="id2"></span><h2>Visibility and Getters<a class="headerlink" href="#visibility-and-getters" title="Permalink to this headline">¶</a></h2>
<p>Solidityは2しゅるのファンクションコール（実際のEVMコールを作らないinternalのもの（”message call”とも呼ばれます）とEVMコールを作るexternalのもの）があるので、ファンクションと状態変数に対して4種類の可視性があります。</p>
<p>ファンクションは <code class="docutils literal notranslate"><span class="pre">external</span></code>、<code class="docutils literal notranslate"><span class="pre">public</span></code>、<code class="docutils literal notranslate"><span class="pre">internal</span></code>、<code class="docutils literal notranslate"><span class="pre">private</span></code> のいずれかを指定しなければいけません。状態変数には、<code class="docutils literal notranslate"><span class="pre">external</span></code> は使えません。</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">external</span></code>:</dt>
<dd>externalのファンクションはコントラクトインターフェースの一部です。つまり、他のコントラクトからトランザクションを通じて呼び出すことができます。あるexternalのファンクション <code class="docutils literal notranslate"><span class="pre">f</span></code> はコントラクト内部では呼び出せません(<code class="docutils literal notranslate"><span class="pre">f()</span></code> は動きませんが、<code class="docutils literal notranslate"><span class="pre">this.f()</span></code> は動作します)。
大きい配列を受け取る時、externalファンクションは場合によってより効率が良くなります。</dd>
<dt><code class="docutils literal notranslate"><span class="pre">public</span></code>:</dt>
<dd>externalのファンクションはコントラクトインターフェースの一部で、内部でも呼び出せますし、もしくはメッセージを通じて呼び出せます。publicの状態変数は自動的にgetter（下記参照）を生成します。</dd>
<dt><code class="docutils literal notranslate"><span class="pre">internal</span></code>:</dt>
<dd>internalのファンクションと状態変数は <code class="docutils literal notranslate"><span class="pre">this</span></code> を使わずに、コントラクト内部でのみアクセスできます（現在のコントラクトからか、それを継承したコントラクトから）。</dd>
<dt><code class="docutils literal notranslate"><span class="pre">private</span></code>:</dt>
<dd>privateのファンクションと状態変数はそれが定義されたコントラクト内のみで可視で、継承したコントラクトでは使えません。</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">コントラクト内側は全てブロックチェーン外側から可視です。<code class="docutils literal notranslate"><span class="pre">private</span></code> だけが他のコントラクトがアクセスしたり変更したりするのを防いでくれます。しかし、それでもブロックチェーンの外側から可視です。</p>
</div>
<p>visibility specifierは状態変数の型の後、パラメータリストとファンクションの返り値リストの間に置かれます。</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">f</span><span class="p">(</span><span class="kt">uint</span> <span class="n">a</span><span class="p">)</span> <span class="kr">private</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="n">setData</span><span class="p">(</span><span class="kt">uint</span> <span class="n">a</span><span class="p">)</span> <span class="kr">internal</span> <span class="p">{</span> <span class="n">data</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">uint</span> <span class="kr">public</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>次の例では、<code class="docutils literal notranslate"><span class="pre">D</span></code> はステートストレージ内の <code class="docutils literal notranslate"><span class="pre">data</span></code> の値を引き出すのに <code class="docutils literal notranslate"><span class="pre">c.getData()</span></code> を呼び出すことができます。しかし、<code class="docutils literal notranslate"><span class="pre">D</span></code> は  <code class="docutils literal notranslate"><span class="pre">f</span></code> を呼べません。コントラクト <code class="docutils literal notranslate"><span class="pre">E</span></code> は <code class="docutils literal notranslate"><span class="pre">C</span></code> を継承しているため、<code class="docutils literal notranslate"><span class="pre">compute</span></code> を呼び出すことができます。</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="kr">private</span> <span class="n">data</span><span class="p">;</span>

    <span class="kd">function</span> <span class="n">f</span><span class="p">(</span><span class="kt">uint</span> <span class="n">a</span><span class="p">)</span> <span class="kr">private</span> <span class="kr">pure</span> <span class="k">returns</span><span class="p">(</span><span class="kt">uint</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="n">setData</span><span class="p">(</span><span class="kt">uint</span> <span class="n">a</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span> <span class="n">data</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="n">getData</span><span class="p">()</span> <span class="kr">public</span> <span class="kr">view</span> <span class="k">returns</span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span><span class="p">;</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="n">compute</span><span class="p">(</span><span class="kt">uint</span> <span class="n">a</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">b</span><span class="p">)</span> <span class="kr">internal</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// This will not compile</span>
<span class="kd">contract</span> <span class="n">D</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">readData</span><span class="p">()</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="n">C</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="n">C</span><span class="p">();</span>
        <span class="kt">uint</span> <span class="n">local</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">f</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span> <span class="c1">// error: member `f` is not visible</span>
        <span class="n">c</span><span class="p">.</span><span class="n">setData</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
        <span class="n">local</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">getData</span><span class="p">();</span>
        <span class="n">local</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">compute</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">// error: member `compute` is not visible</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">E</span> <span class="kr">is</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">g</span><span class="p">()</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="n">C</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="n">C</span><span class="p">();</span>
        <span class="kt">uint</span> <span class="n">val</span> <span class="o">=</span> <span class="n">compute</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">// access to internal member (from derived to parent contract)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="getter-functions">
<span id="index-4"></span><span id="id3"></span><h3>Getter Functions<a class="headerlink" href="#getter-functions" title="Permalink to this headline">¶</a></h3>
<p>コンパイラは自動的に <strong>public</strong> の状態変数のgetterを生成します。下のコントラクトでは、コンパイラは <code class="docutils literal notranslate"><span class="pre">data</span></code> という引数を取らず、<code class="docutils literal notranslate"><span class="pre">uint</span></code> 型の状態変数 <code class="docutils literal notranslate"><span class="pre">data</span></code> の値を返します。 状態変数は宣言された時に初期化することができます。</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="kr">public</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">Caller</span> <span class="p">{</span>
    <span class="n">C</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="n">C</span><span class="p">();</span>
    <span class="kd">function</span> <span class="n">f</span><span class="p">()</span> <span class="kr">public</span> <span class="kr">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>getterはexternalの可視性を持っています。ある記号が内部的にアクセス(<code class="docutils literal notranslate"><span class="pre">this.</span></code> なし)されたら、それは状態変数と評価されます。もし外部的にアクセス(<code class="docutils literal notranslate"><span class="pre">this.</span></code> あり)されたら、それはファンクションと評価されます。</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="kr">public</span> <span class="n">data</span><span class="p">;</span>
    <span class="kd">function</span> <span class="n">x</span><span class="p">()</span> <span class="kr">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">data</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// internal access</span>
        <span class="k">return</span> <span class="nb">this</span><span class="p">.</span><span class="n">data</span><span class="p">();</span> <span class="c1">// external access</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>もし <code class="docutils literal notranslate"><span class="pre">public</span></code> の配列型の状態変数を持っていたら、getterではその配列の1要素しか取り出すことができません。配列全体を返したときにガスが高くならない様にこの仕組みはあります。どの要素を返すか、例えば <code class="docutils literal notranslate"><span class="pre">data(0)</span></code> の様に引数を使って指定することができます。もし配列全体を返したい場合は、ファンクションを作る必要があります。例えば:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">arrayExample</span> <span class="p">{</span>
  <span class="c1">// public state variable</span>
  <span class="kt">uint</span><span class="p">[]</span> <span class="kr">public</span> <span class="n">myArray</span><span class="p">;</span>

  <span class="c1">// Getter function generated by the compiler</span>
  <span class="cm">/*</span>
<span class="cm">  function myArray(uint i) returns (uint) {</span>
<span class="cm">      return myArray[i];</span>
<span class="cm">  }</span>
<span class="cm">  */</span>

  <span class="c1">// function that returns entire array</span>
  <span class="kd">function</span> <span class="n">getArray</span><span class="p">()</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="kr">memory</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">myArray</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ここで、配列全体を取り出すために、1回の呼び出しで1つの要素を返す <code class="docutils literal notranslate"><span class="pre">myArray(i)</span></code> の代わりに、<code class="docutils literal notranslate"><span class="pre">getArray()</span></code> を使うことができます。</p>
<p>次の例はもっと複雑です。</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">Complex</span> <span class="p">{</span>
    <span class="kd">struct</span> <span class="n">Data</span> <span class="p">{</span>
        <span class="kt">uint</span> <span class="n">a</span><span class="p">;</span>
        <span class="kt">bytes3</span> <span class="n">b</span><span class="p">;</span>
        <span class="kd">mapping</span> <span class="p">(</span><span class="kt">uint</span> <span class="o">=&gt;</span> <span class="kt">uint</span><span class="p">)</span> <span class="n">map</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">mapping</span> <span class="p">(</span><span class="kt">uint</span> <span class="o">=&gt;</span> <span class="kd">mapping</span><span class="p">(</span><span class="kt">bool</span> <span class="o">=&gt;</span> <span class="n">Data</span><span class="p">[]))</span> <span class="kr">public</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これは次の形のファンクションを生成します。マッピング用のキーを渡す良い方法がないので、構造体のマッピングは省略します。</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="n">data</span><span class="p">(</span><span class="kt">uint</span> <span class="n">arg1</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">arg2</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">arg3</span><span class="p">)</span> <span class="kr">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">a</span><span class="p">,</span> <span class="kt">bytes3</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">arg1</span><span class="p">][</span><span class="n">arg2</span><span class="p">][</span><span class="n">arg3</span><span class="p">].</span><span class="n">a</span><span class="p">;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">arg1</span><span class="p">][</span><span class="n">arg2</span><span class="p">][</span><span class="n">arg3</span><span class="p">].</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="function-modifiers">
<span id="modifiers"></span><span id="index-5"></span><h2>Function Modifiers<a class="headerlink" href="#function-modifiers" title="Permalink to this headline">¶</a></h2>
<p>modifierはファンクションの挙動を簡単に変えるのに使うことができます。例えば、ファンクションの実行前に自動的にある条件をチェックできます。modifierは継承可能なコントラクトのプロパティで、継承されたコントラクトによってオーバーライドされるかもしれません。</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">^</span><span class="mf">0.5</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">owned</span> <span class="p">{</span>
    <span class="kd">constructor</span><span class="p">()</span> <span class="kr">public</span> <span class="p">{</span> <span class="n">owner</span> <span class="o">=</span> <span class="nb">msg.sender</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">address</span> <span class="kr">payable</span> <span class="n">owner</span><span class="p">;</span>

    <span class="c1">// This contract only defines a modifier but does not use</span>
    <span class="c1">// it: it will be used in derived contracts.</span>
    <span class="c1">// The function body is inserted where the special symbol</span>
    <span class="c1">// `_;` in the definition of a modifier appears.</span>
    <span class="c1">// This means that if the owner calls this function, the</span>
    <span class="c1">// function is executed and otherwise, an exception is</span>
    <span class="c1">// thrown.</span>
    <span class="kd">modifier</span> <span class="n">onlyOwner</span> <span class="p">{</span>
        <span class="nf">require</span><span class="p">(</span>
            <span class="nb">msg.sender</span> <span class="o">==</span> <span class="n">owner</span><span class="p">,</span>
            <span class="s">&quot;Only owner can call this function.&quot;</span>
        <span class="p">);</span>
        <span class="kr">_</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">mortal</span> <span class="kr">is</span> <span class="n">owned</span> <span class="p">{</span>
    <span class="c1">// This contract inherits the `onlyOwner` modifier from</span>
    <span class="c1">// `owned` and applies it to the `close` function, which</span>
    <span class="c1">// causes that calls to `close` only have an effect if</span>
    <span class="c1">// they are made by the stored owner.</span>
    <span class="kd">function</span> <span class="n">close</span><span class="p">()</span> <span class="kr">public</span> <span class="n">onlyOwner</span> <span class="p">{</span>
        <span class="nb">selfdestruct</span><span class="p">(</span><span class="n">owner</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">priced</span> <span class="p">{</span>
    <span class="c1">// Modifiers can receive arguments:</span>
    <span class="kd">modifier</span> <span class="n">costs</span><span class="p">(</span><span class="kt">uint</span> <span class="n">price</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">msg.value</span> <span class="o">&gt;=</span> <span class="n">price</span><span class="p">)</span> <span class="p">{</span>
            <span class="kr">_</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">Register</span> <span class="kr">is</span> <span class="n">priced</span><span class="p">,</span> <span class="n">owned</span> <span class="p">{</span>
    <span class="kd">mapping</span> <span class="p">(</span><span class="kt">address</span> <span class="o">=&gt;</span> <span class="kt">bool</span><span class="p">)</span> <span class="n">registeredAddresses</span><span class="p">;</span>
    <span class="kt">uint</span> <span class="n">price</span><span class="p">;</span>

    <span class="kd">constructor</span><span class="p">(</span><span class="kt">uint</span> <span class="n">initialPrice</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span> <span class="n">price</span> <span class="o">=</span> <span class="n">initialPrice</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// It is important to also provide the</span>
    <span class="c1">// `payable` keyword here, otherwise the function will</span>
    <span class="c1">// automatically reject all Ether sent to it.</span>
    <span class="kd">function</span> <span class="n">register</span><span class="p">()</span> <span class="kr">public</span> <span class="kr">payable</span> <span class="n">costs</span><span class="p">(</span><span class="n">price</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">registeredAddresses</span><span class="p">[</span><span class="nb">msg.sender</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">changePrice</span><span class="p">(</span><span class="kt">uint</span> <span class="n">_price</span><span class="p">)</span> <span class="kr">public</span> <span class="n">onlyOwner</span> <span class="p">{</span>
        <span class="n">price</span> <span class="o">=</span> <span class="n">_price</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">Mutex</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="n">locked</span><span class="p">;</span>
    <span class="kd">modifier</span> <span class="n">noReentrancy</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">require</span><span class="p">(</span>
            <span class="o">!</span><span class="n">locked</span><span class="p">,</span>
            <span class="s">&quot;Reentrant call.&quot;</span>
        <span class="p">);</span>
        <span class="n">locked</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="kr">_</span><span class="p">;</span>
        <span class="n">locked</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">/// This function is protected by a mutex, which means that</span>
    <span class="c1">/// reentrant calls from within `msg.sender.call` cannot call `f` again.</span>
    <span class="c1">/// The `return 7` statement assigns 7 to the return value but still</span>
    <span class="c1">/// executes the statement `locked = false` in the modifier.</span>
    <span class="kd">function</span> <span class="n">f</span><span class="p">()</span> <span class="kr">public</span> <span class="n">noReentrancy</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="kt">bool</span> <span class="n">success</span><span class="p">,)</span> <span class="o">=</span> <span class="nb">msg.sender</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
        <span class="nf">require</span><span class="p">(</span><span class="n">success</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">7</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>複数のmodifierはホワイトスペースで分けられたリストで明記されあるファンクションに適用されます。書かれた順番に評価されます。</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">以前のSolidityでは <code class="docutils literal notranslate"><span class="pre">return</span></code> はmodifierを持つファンクションの中では異なった挙動をしていました。</p>
</div>
<p>modifierもしくはファンクション本体からの明示的なreturnは現在のmodifierもしくはファンクション本体からしか出ません。返ってきた変数は割り当てられ、制御フローは先に処理されたmodifierの”_”の後に続きます。</p>
<p>modifierの引数に任意の式が使えます。このコンテキストに置いて、ファンクションから可視の全ての記号はmodifierでも可視です。modifierで処理される記号はファンクションからは可視ではありません（オーバーライドで変わってしまう可能性があるため）。</p>
</div>
<div class="section" id="constant-state-variables">
<span id="index-6"></span><h2>Constant State Variables<a class="headerlink" href="#constant-state-variables" title="Permalink to this headline">¶</a></h2>
<p>状態変数は <code class="docutils literal notranslate"><span class="pre">constant</span></code> として宣言することができます。この場合、コンパイル時に定数となる式で値が割り当てされている必要があります。ストレージ、ブロックチェーンデータ (例: <code class="docutils literal notranslate"><span class="pre">now</span></code>、<code class="docutils literal notranslate"><span class="pre">address(this).balance</span></code>、<code class="docutils literal notranslate"><span class="pre">block.number</span></code>)、
実行データ (<code class="docutils literal notranslate"><span class="pre">msg.value</span></code>、<code class="docutils literal notranslate"><span class="pre">gasleft()</span></code>) にアクセスする式、もしくは外部のコントラクトを呼び出す式は使えません。メモリ位置の変更に影響があるかもしれない式は使えますが、メモリのオブジェクトに影響があるかもしれない式は使えません。組み込みファンクションの <code class="docutils literal notranslate"><span class="pre">keccak256</span></code>、<code class="docutils literal notranslate"><span class="pre">sha256</span></code>、<code class="docutils literal notranslate"><span class="pre">ripemd160</span></code>、<code class="docutils literal notranslate"><span class="pre">ecrecover</span></code>、<code class="docutils literal notranslate"><span class="pre">addmod</span></code>、<code class="docutils literal notranslate"><span class="pre">mulmod</span></code> は使用可能です（ <code class="docutils literal notranslate"><span class="pre">keccak256</span></code> の例外は外部コントラクトを呼び出しますが）。</p>
<p>メモリ位置への影響を許容する理由としては、lookup-tablesの様な複雑なオブジェクトの作成が可能であるべきだからです。
ただ、この機能はまだ完全に使用可能というわけではありません。</p>
<p>コンパイラはこの変数のためのストレージスロットを保持しません。結果は全て各定数式で置き換えられます（オプティマイザによって1つの値に計算されるかもしれません）。</p>
<p>全ての型の定数がここで実行される訳ではありません。値型と文字列だけサポートされています。</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="kr">constant</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">32</span><span class="o">**</span><span class="mi">22</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span>
    <span class="kt">string</span> <span class="kr">constant</span> <span class="n">text</span> <span class="o">=</span> <span class="s">&quot;abc&quot;</span><span class="p">;</span>
    <span class="kt">bytes32</span> <span class="kr">constant</span> <span class="n">myHash</span> <span class="o">=</span> <span class="nf">keccak256</span><span class="p">(</span><span class="s">&quot;abc&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="functions">
<span id="index-7"></span><span id="id4"></span><h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="function-parameters-and-return-variables">
<span id="function-parameters-return-variables"></span><h3>Function Parameters and Return Variables<a class="headerlink" href="#function-parameters-and-return-variables" title="Permalink to this headline">¶</a></h3>
<p>JavaScriptに見られる様に、ファンクションは入力としてパラメータをとります。JavaScriptやCと違い、ファンクションは任意の数の値を出力できます。</p>
<div class="section" id="function-parameters">
<h4>Function Parameters<a class="headerlink" href="#function-parameters" title="Permalink to this headline">¶</a></h4>
<p>ファンクションのパラメータは変数と同じ様に宣言されます。使われなかったパラメータは省略されます。</p>
<p>例えば、もし2つの整数でexternal callをしたい場合、次の様にできます:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">Simple</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="n">sum</span><span class="p">;</span>
    <span class="kd">function</span> <span class="n">taker</span><span class="p">(</span><span class="kt">uint</span> <span class="n">_a</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">_b</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="n">sum</span> <span class="o">=</span> <span class="n">_a</span> <span class="o">+</span> <span class="n">_b</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ファンクションパラメータはローカル変数としても使えますし、その値を割り当てすることもできます。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><a class="reference internal" href="control-structures.html#external-function-calls"><span class="std std-ref">external function</span></a> は入力パラメータとして多次元配列を受け入れません。この機能に関しては、ソースファイルに <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">experimental</span> <span class="pre">ABIEncoderV2;</span></code> を追加して、新しい実験的な <code class="docutils literal notranslate"><span class="pre">ABIEncoderV2</span></code> 機能を有効にすれば使うことができます。</p>
<p class="last"><a class="reference internal" href="control-structures.html#external-function-calls"><span class="std std-ref">internal function</span></a> はこの機能を有効にしなくても多次元配列を使うことができます。</p>
</div>
</div>
<div class="section" id="return-variables">
<span id="index-8"></span><h4>Return Variables<a class="headerlink" href="#return-variables" title="Permalink to this headline">¶</a></h4>
<p>ファンクションの返り値は <code class="docutils literal notranslate"><span class="pre">returns</span></code> キーワードの後、同じシンタックスで宣言されます。</p>
<p>例えば2つの結果が欲しい時: ファンクションパラメータとして渡された2つの整数の和と積が欲しい時、次の様に書けます:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">Simple</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">arithmetic</span><span class="p">(</span><span class="kt">uint</span> <span class="n">_a</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">_b</span><span class="p">)</span>
        <span class="kr">public</span>
        <span class="kr">pure</span>
        <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">o_sum</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">o_product</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">o_sum</span> <span class="o">=</span> <span class="n">_a</span> <span class="o">+</span> <span class="n">_b</span><span class="p">;</span>
        <span class="n">o_product</span> <span class="o">=</span> <span class="n">_a</span> <span class="o">*</span> <span class="n">_b</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>返り値の名前は省略可能です。返り値は他のローカル変数として使えます。返り値は <a class="reference internal" href="control-structures.html#default-value"><span class="std std-ref">default value</span></a> で初期化されており、明示的に値をセットしない限りその値を持ちます。</p>
<p>明示的に変数に値を割り当て、<code class="docutils literal notranslate"><span class="pre">return;</span></code> を使うか、直接 <code class="docutils literal notranslate"><span class="pre">return</span></code> に返り値（1つもしくは <a class="reference internal" href="#multi-return"><span class="std std-ref">multiple ones</span></a> ）を入れるかいずれかが可能です:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">Simple</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">arithmetic</span><span class="p">(</span><span class="kt">uint</span> <span class="n">_a</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">_b</span><span class="p">)</span>
        <span class="kr">public</span>
        <span class="kr">pure</span>
        <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">o_sum</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">o_product</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">_a</span> <span class="o">+</span> <span class="n">_b</span><span class="p">,</span> <span class="n">_a</span> <span class="o">*</span> <span class="n">_b</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これは返り値を変数に割り当てて <code class="docutils literal notranslate"><span class="pre">return;</span></code> を使って返す方法と結果は同じです。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">internalでないファンクションからいくつかの型は返すことはできません。特に多次元動的配列と構造体です。ソースファイルに <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">experimental</span>
<span class="pre">ABIEncoderV2;</span></code> を加えて新しい実験的な <code class="docutils literal notranslate"><span class="pre">ABIEncoderV2</span></code> 機能を有効にすればもっと他の型も使える様になります。しかし、<code class="docutils literal notranslate"><span class="pre">mapping</span></code> 型はそれでも1つのコントラクト内でしか扱うことができず、転送することはできません。</p>
</div>
</div>
<div class="section" id="returning-multiple-values">
<span id="multi-return"></span><h4>Returning Multiple Values<a class="headerlink" href="#returning-multiple-values" title="Permalink to this headline">¶</a></h4>
<p>ファンクションが複数の返り値の型を持つ時、<code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">(v0,</span> <span class="pre">v1,</span> <span class="pre">...,</span> <span class="pre">vn)</span></code> という宣言が複数の型を返すのに使用されます。
要素の数は返す値の数と同じでなければいけません。</p>
</div>
</div>
<div class="section" id="view-functions">
<span id="index-9"></span><span id="id5"></span><h3>View Functions<a class="headerlink" href="#view-functions" title="Permalink to this headline">¶</a></h3>
<p>ステートを変えない場合ファンクションは <code class="docutils literal notranslate"><span class="pre">view</span></code> を宣言できます。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">もしコンパイラのEVMターゲットかByzantiumより新しい場合、EVM実行の一部としてステートの変更をさせないopcode <code class="docutils literal notranslate"><span class="pre">STATICCALL</span></code> が <code class="docutils literal notranslate"><span class="pre">view</span></code> ファンクションに使われます。ライブラリの <code class="docutils literal notranslate"><span class="pre">view</span></code> ファンクションには <code class="docutils literal notranslate"><span class="pre">DELEGATECALL</span></code> が使用されます。なぜなら、<code class="docutils literal notranslate"><span class="pre">DELEGATECALL</span></code> と <code class="docutils literal notranslate"><span class="pre">STATICCALL</span></code> が一緒になったものは存在しないからです。つまり、ライブラリの <code class="docutils literal notranslate"><span class="pre">view</span></code> ファンクションはステートの変更を妨げるランタイムチェックを持っていないということです。ライブラリのコードは普通はコンパイル時に既知であり、static checkerがコンパイル時にチェックするため、これはセキュリティ的に問題ないはずです。</p>
</div>
<p>下記のリストはステートを変更すると考えられます。</p>
<ol class="arabic simple">
<li>状態変数を書く。</li>
<li><a class="reference internal" href="#events"><span class="std std-ref">イベントのemit</span></a>。</li>
<li><a class="reference internal" href="control-structures.html#creating-contracts"><span class="std std-ref">他のコントラクトを作る</span></a>。</li>
<li><code class="docutils literal notranslate"><span class="pre">selfdestruct</span></code> を使う</li>
<li>callを通じてEtherを送る。</li>
<li><code class="docutils literal notranslate"><span class="pre">view</span></code> や <code class="docutils literal notranslate"><span class="pre">pure</span></code> の付いていないファンクションを呼び出す。</li>
<li>低レベルcallを使う。</li>
<li>あるopcodeの入ったインラインアセンブリを使う。</li>
</ol>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">^</span><span class="mf">0.5</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">f</span><span class="p">(</span><span class="kt">uint</span> <span class="n">a</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">b</span><span class="p">)</span> <span class="kr">public</span> <span class="kr">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="mi">42</span><span class="p">)</span> <span class="o">+</span> <span class="nb">now</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">ファンクションで <code class="docutils literal notranslate"><span class="pre">constant</span></code> は <code class="docutils literal notranslate"><span class="pre">view</span></code> のエイリアスとして使われていましたが、バージョン0.5.0でドロップされました。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">getterメソッドは自動的に <code class="docutils literal notranslate"><span class="pre">view</span></code> がつきます。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">バージョン0.5.0以前ではコンパイラは <code class="docutils literal notranslate"><span class="pre">view</span></code> ファンクションに <code class="docutils literal notranslate"><span class="pre">STATICCALL</span></code> を使っていませんでした。
これは、無効な明示的型変換を使うことで、<code class="docutils literal notranslate"><span class="pre">view</span></code> ファンクションでのステートの変更を可能にしていました。
<code class="docutils literal notranslate"><span class="pre">STATICCALL</span></code> を <code class="docutils literal notranslate"><span class="pre">view</span></code> ファンクションに使うことで、EVM上ではステートの変更を行うことができなくなりました。</p>
</div>
</div>
<div class="section" id="pure-functions">
<span id="index-10"></span><span id="id6"></span><h3>Pure Functions<a class="headerlink" href="#pure-functions" title="Permalink to this headline">¶</a></h3>
<p>何も読まない、ステートも変更しない場合、ファンクションで <code class="docutils literal notranslate"><span class="pre">pure</span></code> を宣言できます。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">コンパイラのEVMターゲットがByzantium以降であれば、opcode <code class="docutils literal notranslate"><span class="pre">STATICCALL</span></code> が使えます。ステートが読まれないかは保証しませんが、少なくともステートが変更されていないことは保証されます。</p>
</div>
<p>ステートを変更する上記のリストに加えて、下記はステートを読み込むとされる処理のリストです。</p>
<ol class="arabic simple">
<li>状態変数から読み込む。</li>
<li><code class="docutils literal notranslate"><span class="pre">address(this).balance</span></code> もしくは <code class="docutils literal notranslate"><span class="pre">&lt;address&gt;.balance</span></code> にアクセスする。</li>
<li><code class="docutils literal notranslate"><span class="pre">block</span></code>、<code class="docutils literal notranslate"><span class="pre">tx</span></code>、<code class="docutils literal notranslate"><span class="pre">msg</span></code> ( <code class="docutils literal notranslate"><span class="pre">msg.sig</span></code> と <code class="docutils literal notranslate"><span class="pre">msg.data</span></code> は除く)のどれかにアクセスする。</li>
<li><code class="docutils literal notranslate"><span class="pre">pure</span></code> が付いていないファンクションを呼び出す。</li>
<li>あるopcodeの入ったインラインアセンブリを使う。</li>
</ol>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">^</span><span class="mf">0.5</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">f</span><span class="p">(</span><span class="kt">uint</span> <span class="n">a</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">b</span><span class="p">)</span> <span class="kr">public</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="mi">42</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Pureファンクションは <a class="reference internal" href="control-structures.html#assert-and-require"><span class="std std-ref">エラーが起きた</span></a> 時に、潜在的なステートの変更を元に戻すため <cite>revert()</cite> と <cite>require()</cite> を使えます。</p>
<p>ステートを元に戻すのは”ステートの変更”とは見なされません。
なぜなら、<code class="docutils literal notranslate"><span class="pre">view</span></code> もしくは <code class="docutils literal notranslate"><span class="pre">pure</span></code> がないコードで以前に作られたステートへの変更だけがrevertされていたためです。さらに、そのコードは <code class="docutils literal notranslate"><span class="pre">revert</span></code> をキャッチし、受け渡ししないオプションがあります。</p>
<p>この挙動は <code class="docutils literal notranslate"><span class="pre">STATICCALL</span></code> opcodeにも合っています。</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">EVMレベルではファンクションがステートを読み込むことを止めることはできません。できるのは書き込みを止めることだけです（ <code class="docutils literal notranslate"><span class="pre">view</span></code> がEVMレベルで強制されますが、<code class="docutils literal notranslate"><span class="pre">pure</span></code> はされません）。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">バージョン0.5.0以前ではコンパイラは <code class="docutils literal notranslate"><span class="pre">pure</span></code> ファンクションに <code class="docutils literal notranslate"><span class="pre">STATICCALL</span></code> を使っていませんでした。
これは、無効な明示的型変換を使うことで、<code class="docutils literal notranslate"><span class="pre">view</span></code> ファンクションでのステートの変更を可能にしていました。
<code class="docutils literal notranslate"><span class="pre">STATICCALL</span></code> を <code class="docutils literal notranslate"><span class="pre">pure</span></code> ファンクションに使うことで、EVM上ではステートの変更を行うことができなくなりました。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">バージョン0.4.17以前では、コンパイラは <code class="docutils literal notranslate"><span class="pre">pure</span></code> にステートを読まなせないということを強制していませんでした。
コンパイル時の型チェックで、コントラクト型間での無効な明示的変換を避けることができます。なぜなら、コンパイラがそのタイプのコントラクトはステートを変える操作をしないと証明するからです。ただ、ランタイム時に呼ばれるコントラクトに関しては実際にそのタイプかどうかはチェックしません。</p>
</div>
</div>
<div class="section" id="fallback-function">
<span id="index-11"></span><span id="id7"></span><h3>Fallback Function<a class="headerlink" href="#fallback-function" title="Permalink to this headline">¶</a></h3>
<p>コントラクトは1つだけ名前の付いていないファンクションを持つことができます。そのファンクションは引数を持てず、何も返せません。そして可視性は <code class="docutils literal notranslate"><span class="pre">external</span></code> である必要があります。
もし、他のファンクションが与えられたファンクションの識別子になかった場合（もしくは何のデータも渡されなかった場合）、そのコントラクトが呼ばれた時に実行されます。</p>
<p>さらに、このファンクションはコントラクトが（データなしの）Etherを受け取った時は実行されます。Etherを受け取って、コントラクトのトータルバランスにそれを追加するにはフォールバックファンクションは <code class="docutils literal notranslate"><span class="pre">payable</span></code> でなければいけません。もしそのようなファンクションがない場合、コントラクトは通常のトランザクションを通じてEtherを受け取れず、例外を投げます。</p>
<p>最悪の場合、フォールバックファンクションは2300ガスだけを利用可能（例えば <cite>send</cite> か <cite>transfer</cite> を使うのに）とします。基本的なログの機能以外に他の演算のための余力をほとんど残しません。下記の演算は固定で2300ガス以上使う演算です。</p>
<ul class="simple">
<li>ストレージに書き込む</li>
<li>コントラクトを作る</li>
<li>ガスを多く使う外部ファンクションを呼び出す</li>
<li>Etherを送る</li>
</ul>
<p>他のファンクションのように、フォールバックファンクションは十分なガスが渡される限り、複雑な演算も実行可能です。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">フォールバックファンクションは引数を持てませんが、呼び出しで供給されたペイロードを引き出すのに、<code class="docutils literal notranslate"><span class="pre">msg.data</span></code> を使うことができます。</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">呼び出し元が利用不可なファンクションを呼び出した時にもフォールバックファンクションは実行されます。Etherを受け取るためだけにフォールバックファンクションを実行したい場合、不正な呼び出しを防ぐために <code class="docutils literal notranslate"><span class="pre">require(msg.data.length</span> <span class="pre">==</span> <span class="pre">0)</span></code> を追加した方が良いでしょう。</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Etherを直接受け取る（ファンクションコール、つまり <code class="docutils literal notranslate"><span class="pre">send</span></code> か <code class="docutils literal notranslate"><span class="pre">transfer</span></code> を伴わない）が、フォールバックファンクションを定義しないコントラクトは例外を投げ、Etherを送り返します（Solidityバージョン0.4.0以前では違いました）。そのため、コントラクトでEtherを受け取りたい場合、payableのフォールバックファンクションを実装しなければいけません。</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>payableフォールバックファンクションがないコントラクトは <cite>coinbase transaction</cite> (もしくは <cite>miner block reward</cite>)として、もしくは <code class="docutils literal notranslate"><span class="pre">selfdestruct</span></code> の送り先としてEtherを受け取ることができます。</p>
<p>コントラクトはそのようなEtherの送金に関して何の反応もできないため、それを拒否することもできません。
これはEVMの設計であるため、Solidityではどうにもできません。</p>
<p class="last">これは、<code class="docutils literal notranslate"><span class="pre">address(this).balance</span></code> がコントラクト内で処理された手動の会計処理の合計より高くなりうることを意味しています（フォールバックファンクションでアプデートされるカウンタを持っているということです）。</p>
</div>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">^</span><span class="mf">0.5</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">Test</span> <span class="p">{</span>
    <span class="c1">// This function is called for all messages sent to</span>
    <span class="c1">// this contract (there is no other function).</span>
    <span class="c1">// Sending Ether to this contract will cause an exception,</span>
    <span class="c1">// because the fallback function does not have the `payable`</span>
    <span class="c1">// modifier.</span>
    <span class="kd">function</span><span class="p">()</span> <span class="kr">external</span> <span class="p">{</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">uint</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// This contract keeps all Ether sent to it with no way</span>
<span class="c1">// to get it back.</span>
<span class="kd">contract</span> <span class="n">Sink</span> <span class="p">{</span>
    <span class="kd">function</span><span class="p">()</span> <span class="kr">external</span> <span class="kr">payable</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">Caller</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">callTest</span><span class="p">(</span><span class="n">Test</span> <span class="n">test</span><span class="p">)</span> <span class="kr">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="kt">bool</span> <span class="n">success</span><span class="p">,)</span> <span class="o">=</span> <span class="kt">address</span><span class="p">(</span><span class="n">test</span><span class="p">).</span><span class="nf">call</span><span class="p">(</span><span class="nb">abi.encodeWithSignature</span><span class="p">(</span><span class="s">&quot;nonExistingFunction()&quot;</span><span class="p">));</span>
        <span class="nf">require</span><span class="p">(</span><span class="n">success</span><span class="p">);</span>
        <span class="c1">// results in test.x becoming == 1.</span>

        <span class="c1">// address(test) will not allow to call ``send`` directly, since ``test`` has no payable</span>
        <span class="c1">// fallback function. It has to be converted to the ``address payable`` type via an</span>
        <span class="c1">// intermediate conversion to ``uint160`` to even allow calling ``send`` on it.</span>
        <span class="kt">address</span> <span class="kr">payable</span> <span class="n">testPayable</span> <span class="o">=</span> <span class="kt">address</span><span class="p">(</span><span class="kt">uint160</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="n">test</span><span class="p">)));</span>

        <span class="c1">// If someone sends ether to that contract,</span>
        <span class="c1">// the transfer will fail, i.e. this returns false here.</span>
        <span class="k">return</span> <span class="n">testPayable</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="mi">2</span> <span class="kc">ether</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="function-overloading">
<span id="overload-function"></span><span id="index-12"></span><h3>Function Overloading<a class="headerlink" href="#function-overloading" title="Permalink to this headline">¶</a></h3>
<p>コントラクトは異なるパラメータを持つ、同じ名前のファンクションを複数持つことができます。
このプロセスは”オーバーロード”といわれ、継承されたファンクションにも適用されます。
コントラクト <code class="docutils literal notranslate"><span class="pre">A</span></code> のスコープに入っているファンクション <code class="docutils literal notranslate"><span class="pre">f</span></code> のオーバーロードの例を下記に示します。</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">A</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">f</span><span class="p">(</span><span class="kt">uint</span> <span class="n">_in</span><span class="p">)</span> <span class="kr">public</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">out</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">_in</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">f</span><span class="p">(</span><span class="kt">uint</span> <span class="n">_in</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">_really</span><span class="p">)</span> <span class="kr">public</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">out</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_really</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">_in</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>オーバーロードされたファンクションは外部インターフェースの中にもあります。もし2つの外部的に可視なファンクションが外部としての型ではなく、Solidityの型として異なる場合エラーになります。</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="c1">// This will not compile</span>
<span class="kd">contract</span> <span class="n">A</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">f</span><span class="p">(</span><span class="n">B</span> <span class="n">_in</span><span class="p">)</span> <span class="kr">public</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="n">B</span> <span class="n">out</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">_in</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">f</span><span class="p">(</span><span class="kt">address</span> <span class="n">_in</span><span class="p">)</span> <span class="kr">public</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">address</span> <span class="n">out</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">_in</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">B</span> <span class="p">{</span>
<span class="p">}</span>
</pre></div>
</div>
<p>両方の <code class="docutils literal notranslate"><span class="pre">f</span></code> ファンクションはABIとしてはアドレス型を受け入れてオーバーロードしますが、Solidity内では違うものとして考えられます。</p>
<div class="section" id="overload-resolution-and-argument-matching">
<h4>Overload resolution and Argument matching<a class="headerlink" href="#overload-resolution-and-argument-matching" title="Permalink to this headline">¶</a></h4>
<p>オーバーロードされたファンクションは、現在のスコープ内のファンクションの宣言をファンクションコール内で渡された引数に合わせることによって選択されます。
全ての引数が暗示的に期待する型に変換できる場合、ファンクションはオーバーロードの候補として選ばれます。もし候補がなければ、そのresolutionは失敗します。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">返ってくるパラメータはオーバーロードresolutionに考慮されません。</p>
</div>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">A</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">f</span><span class="p">(</span><span class="kt">uint8</span> <span class="n">_in</span><span class="p">)</span> <span class="kr">public</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint8</span> <span class="n">out</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">_in</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">f</span><span class="p">(</span><span class="kt">uint256</span> <span class="n">_in</span><span class="p">)</span> <span class="kr">public</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint256</span> <span class="n">out</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">_in</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">50</span></code> <code class="docutils literal notranslate"><span class="pre">uint8</span></code> と <code class="docutils literal notranslate"><span class="pre">uint256</span></code> どちらにも暗示的に変換できるため、<code class="docutils literal notranslate"><span class="pre">f(50)</span></code> の呼び出しは型エラーを生成します。
一方で、<code class="docutils literal notranslate"><span class="pre">256</span></code> は暗示的に <code class="docutils literal notranslate"><span class="pre">uint8</span></code> に変換できないため <code class="docutils literal notranslate"><span class="pre">f(256)</span></code> は <code class="docutils literal notranslate"><span class="pre">f(uint256)</span></code> オーバーロードします。</p>
</div>
</div>
</div>
<div class="section" id="events">
<span id="index-13"></span><span id="id8"></span><h2>Events<a class="headerlink" href="#events" title="Permalink to this headline">¶</a></h2>
<p>SolidityのイベントでEVMのログ機能からデータを抽出します。アプリケーションはEthereumクライアントのRPCインターフェースを通じてイベントをsubscribeします。</p>
<p>イベントは継承可能なコントラクトのメンバです。イベントを呼び出すと、トランザクションのログ内に引数を保存します（ブロックチェーン上の特別なデータ構造です）。これらのログはコントラクトアドレスに結びつき、ブロックにアクセスできる限りそこに保存されます（FrontierとHomesteadからは永久にアクセス出来ますが、Serenityで変わる可能性があります）。ログとイベントデータはコントラクトからはアクセス出来ません（そのイベントを作ったコントラクトからもです）。</p>
<p>simple payment verification (SPV)にログをリクエスト出来るので、もし外部からその様なverificationでコントラクトを作った場合、そのSPVからその様なログが実際にブロックチェーン上に存在するかチェックすることができます。コントラクトは直近256ブロック分のハッシュしか見れないので、ブロックヘッダを渡す必要があります。</p>
<p>最大3つのパラメータに <code class="docutils literal notranslate"><span class="pre">indexed</span></code> 属性を追加することができます。それはログのデータの代わりに <a class="reference internal" href="abi-spec.html#abi-events"><span class="std std-ref">“topics”</span></a> で知られる特別なデータ構造を追加します。インデックスされた引数として配列（<code class="docutils literal notranslate"><span class="pre">string</span></code> と <a href="#id9"><span class="problematic" id="id10">``</span></a>bytes``を含む）を使う場合、Keccak-256ハッシュをtopicとして代わりに保存します。なぜならtopic一つの単語（32バイト）しか保存できないからです。</p>
<p>全ての <code class="docutils literal notranslate"><span class="pre">indexed</span></code> 属性が付いていないパラメータはログのデータ部に <a class="reference internal" href="abi-spec.html#abi"><span class="std std-ref">ABI-encoded</span></a> されます。

topicを使うとイベントを検索することができます。例えば、あるイベントに関してブロックシーケンスをフィルターできます。イベントから出たコントラクトアドレスでもイベントをフィルターできます。</p>
<p>例えば以下のコードではあるアドレス値でtopicにマッチするログをフィルターするためにweb3.js <code class="docutils literal notranslate"><span class="pre">subscribe(&quot;logs&quot;)</span></code>
<a class="reference external" href="https://web3js.readthedocs.io/en/1.0/web3-eth-subscribe.html#subscribe-logs">method</a> が使われています。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">options</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">fromBlock</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="nx">address</span><span class="o">:</span> <span class="nx">web3</span><span class="p">.</span><span class="nx">eth</span><span class="p">.</span><span class="nx">defaultAccount</span><span class="p">,</span>
    <span class="nx">topics</span><span class="o">:</span> <span class="p">[</span><span class="s2">&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="kc">null</span><span class="p">]</span>
<span class="p">};</span>
<span class="nx">web3</span><span class="p">.</span><span class="nx">eth</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="s1">&#39;logs&#39;</span><span class="p">,</span> <span class="nx">options</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">error</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">error</span><span class="p">)</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
<span class="p">})</span>
    <span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">log</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">log</span><span class="p">);</span>
    <span class="p">})</span>
    <span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&quot;changed&quot;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">log</span><span class="p">)</span> <span class="p">{</span>
<span class="p">});</span>
</pre></div>
</div>
<p>イベントを <code class="docutils literal notranslate"><span class="pre">anonymous</span></code> で宣言していなければ、イベントの署名のハッシュはtopicの1つとなります。つまり、特定のanonymousイベントに関しては名前でフィルターできません。</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">21</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">ClientReceipt</span> <span class="p">{</span>
    <span class="kd">event</span> <span class="n">Deposit</span><span class="p">(</span>
        <span class="kt">address</span> <span class="kr">indexed</span> <span class="n">_from</span><span class="p">,</span>
        <span class="kt">bytes32</span> <span class="kr">indexed</span> <span class="n">_id</span><span class="p">,</span>
        <span class="kt">uint</span> <span class="n">_value</span>
    <span class="p">);</span>

    <span class="kd">function</span> <span class="n">deposit</span><span class="p">(</span><span class="kt">bytes32</span> <span class="n">_id</span><span class="p">)</span> <span class="kr">public</span> <span class="kr">payable</span> <span class="p">{</span>
        <span class="c1">// Events are emitted using `emit`, followed by</span>
        <span class="c1">// the name of the event and the arguments</span>
        <span class="c1">// (if any) in parentheses. Any such invocation</span>
        <span class="c1">// (even deeply nested) can be detected from</span>
        <span class="c1">// the JavaScript API by filtering for `Deposit`.</span>
        <span class="kr">emit</span> <span class="n">Deposit</span><span class="p">(</span><span class="nb">msg.sender</span><span class="p">,</span> <span class="n">_id</span><span class="p">,</span> <span class="nb">msg.value</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>下記はJavaScript APIにおける使用例です。</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="n">abi</span> <span class="o">=</span> <span class="cm">/* abi as generated by the compiler */</span><span class="p">;</span>
<span class="kd">var</span> <span class="n">ClientReceipt</span> <span class="o">=</span> <span class="n">web3</span><span class="p">.</span><span class="n">eth</span><span class="p">.</span><span class="kd">contract</span><span class="p">(</span><span class="n">abi</span><span class="p">);</span>
<span class="kd">var</span> <span class="n">clientReceipt</span> <span class="o">=</span> <span class="n">ClientReceipt</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="s">&quot;0x1234...ab67&quot;</span> <span class="cm">/* address */</span><span class="p">);</span>

<span class="kd">var</span> <span class="kd">event</span> <span class="o">=</span> <span class="n">clientReceipt</span><span class="p">.</span><span class="n">Deposit</span><span class="p">();</span>

<span class="c1">// watch for changes</span>
<span class="kd">event</span><span class="p">.</span><span class="n">watch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">result</span><span class="p">){</span>
    <span class="c1">// result contains non-indexed arguments and topics</span>
    <span class="c1">// given to the `Deposit` call.</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
        <span class="n">console</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="p">});</span>


<span class="c1">// Or pass a callback to start watching immediately</span>
<span class="kd">var</span> <span class="kd">event</span> <span class="o">=</span> <span class="n">clientReceipt</span><span class="p">.</span><span class="n">Deposit</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
        <span class="n">console</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
<p>上記の出力は以下の様になります（トリムされています）。</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
   <span class="nt">&quot;returnValues&quot;</span><span class="p">:</span> <span class="p">{</span>
       <span class="nt">&quot;_from&quot;</span><span class="p">:</span> <span class="s2">&quot;0x1111…FFFFCCCC&quot;</span><span class="p">,</span>
       <span class="nt">&quot;_id&quot;</span><span class="p">:</span> <span class="s2">&quot;0x50…sd5adb20&quot;</span><span class="p">,</span>
       <span class="nt">&quot;_value&quot;</span><span class="p">:</span> <span class="s2">&quot;0x420042&quot;</span>
   <span class="p">},</span>
   <span class="nt">&quot;raw&quot;</span><span class="p">:</span> <span class="p">{</span>
       <span class="nt">&quot;data&quot;</span><span class="p">:</span> <span class="s2">&quot;0x7f…91385&quot;</span><span class="p">,</span>
       <span class="nt">&quot;topics&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;0xfd4…b4ead7&quot;</span><span class="p">,</span> <span class="s2">&quot;0x7f…1a91385&quot;</span><span class="p">]</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="low-level-interface-to-logs">
<span id="index-14"></span><h3>Low-Level Interface to Logs<a class="headerlink" href="#low-level-interface-to-logs" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">log0</span></code>、<code class="docutils literal notranslate"><span class="pre">log1</span></code>、<code class="docutils literal notranslate"><span class="pre">log2</span></code>、<code class="docutils literal notranslate"><span class="pre">log3</span></code>、<code class="docutils literal notranslate"><span class="pre">log4</span></code> ファンクションを使うことで、ログ機能の低レベルインターフェースにアクセスすることが可能です。<code class="docutils literal notranslate"><span class="pre">logi</span></code> は <code class="docutils literal notranslate"><span class="pre">bytes32</span></code> 型の <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">1</span></code> パラメータをとります。最初の引数はログのデータ部として使用され、他はtopicとして使用されます。上記のイベントコールは下記と同じ様に実行されます。</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">10</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">f</span><span class="p">()</span> <span class="kr">public</span> <span class="kr">payable</span> <span class="p">{</span>
        <span class="kt">uint256</span> <span class="n">_id</span> <span class="o">=</span> <span class="mh">0x420042</span><span class="p">;</span>
        <span class="n">log3</span><span class="p">(</span>
            <span class="kt">bytes32</span><span class="p">(</span><span class="nb">msg.value</span><span class="p">),</span>
            <span class="kt">bytes32</span><span class="p">(</span><span class="mh">0x50cb9fe53daa9737b786ab3646f04d0150dc50ef4e75f59509d83667ad5adb20</span><span class="p">),</span>
            <span class="kt">bytes32</span><span class="p">(</span><span class="kt">uint256</span><span class="p">(</span><span class="nb">msg.sender</span><span class="p">)),</span>
            <span class="kt">bytes32</span><span class="p">(</span><span class="n">_id</span><span class="p">)</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ここで、長い16進数の値はイベントの署名である <code class="docutils literal notranslate"><span class="pre">keccak256(&quot;Deposit(address,bytes32,uint256)&quot;)</span></code> と等しいです。</p>
</div>
<div class="section" id="additional-resources-for-understanding-events">
<h3>Additional Resources for Understanding Events<a class="headerlink" href="#additional-resources-for-understanding-events" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/ethereum/wiki/wiki/JavaScript-API#contract-events">Javascript documentation</a></li>
<li><a class="reference external" href="https://github.com/debris/smart-exchange/blob/master/lib/contracts/SmartExchange.sol">Example usage of events</a></li>
<li><a class="reference external" href="https://github.com/debris/smart-exchange/blob/master/lib/exchange_transactions.js">How to access them in js</a></li>
</ul>
</div>
</div>
<div class="section" id="inheritance">
<span id="index-15"></span><h2>Inheritance<a class="headerlink" href="#inheritance" title="Permalink to this headline">¶</a></h2>
<p>Solidityはポリモフィズムを含めた多重継承をサポートしています。</p>
<p>全てのファンクションコールは仮想です。つまりコントラクト名が明示的に与えられた場合、<code class="docutils literal notranslate"><span class="pre">super</span></code> が使われた場合を除いて、最後に派生されたファンクションが呼ばれます。</p>
<p>あるコントラクトがある他のコントラクトを継承するとき、1つのコントラクトだけがブロックチェーン上に生成されます。全てのベースコントラクトからのコードは生成したコントラクトにコンパイルされます。</p>
<p>継承のシステム全般は <a class="reference external" href="https://docs.python.org/3/tutorial/classes.html#inheritance">Python</a> にとても似ています。特に多重継承は似ていますが、いくつかの <a class="reference internal" href="#multi-inheritance"><span class="std std-ref">違い</span></a> もあります。</p>
<p>詳細は下記の例で示します。</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">^</span><span class="mf">0.5</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">owned</span> <span class="p">{</span>
    <span class="kd">constructor</span><span class="p">()</span> <span class="kr">public</span> <span class="p">{</span> <span class="n">owner</span> <span class="o">=</span> <span class="nb">msg.sender</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">address</span> <span class="kr">payable</span> <span class="n">owner</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Use `is` to derive from another contract. Derived</span>
<span class="c1">// contracts can access all non-private members including</span>
<span class="c1">// internal functions and state variables. These cannot be</span>
<span class="c1">// accessed externally via `this`, though.</span>
<span class="kd">contract</span> <span class="n">mortal</span> <span class="kr">is</span> <span class="n">owned</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">kill</span><span class="p">()</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">msg.sender</span> <span class="o">==</span> <span class="n">owner</span><span class="p">)</span> <span class="nb">selfdestruct</span><span class="p">(</span><span class="n">owner</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// These abstract contracts are only provided to make the</span>
<span class="c1">// interface known to the compiler. Note the function</span>
<span class="c1">// without body. If a contract does not implement all</span>
<span class="c1">// functions it can only be used as an interface.</span>
<span class="kd">contract</span> <span class="n">Config</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">lookup</span><span class="p">(</span><span class="kt">uint</span> <span class="n">id</span><span class="p">)</span> <span class="kr">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">address</span> <span class="n">adr</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">NameReg</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">register</span><span class="p">(</span><span class="kt">bytes32</span> <span class="n">name</span><span class="p">)</span> <span class="kr">public</span><span class="p">;</span>
    <span class="kd">function</span> <span class="n">unregister</span><span class="p">()</span> <span class="kr">public</span><span class="p">;</span>
 <span class="p">}</span>

<span class="c1">// Multiple inheritance is possible. Note that `owned` is</span>
<span class="c1">// also a base class of `mortal`, yet there is only a single</span>
<span class="c1">// instance of `owned` (as for virtual inheritance in C++).</span>
<span class="kd">contract</span> <span class="n">named</span> <span class="kr">is</span> <span class="n">owned</span><span class="p">,</span> <span class="n">mortal</span> <span class="p">{</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="kt">bytes32</span> <span class="n">name</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="n">Config</span> <span class="n">config</span> <span class="o">=</span> <span class="n">Config</span><span class="p">(</span><span class="mh">0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970</span><span class="p">);</span>
        <span class="n">NameReg</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="mi">1</span><span class="p">)).</span><span class="n">register</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Functions can be overridden by another function with the same name and</span>
    <span class="c1">// the same number/types of inputs.  If the overriding function has different</span>
    <span class="c1">// types of output parameters, that causes an error.</span>
    <span class="c1">// Both local and message-based function calls take these overrides</span>
    <span class="c1">// into account.</span>
    <span class="kd">function</span> <span class="n">kill</span><span class="p">()</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">msg.sender</span> <span class="o">==</span> <span class="n">owner</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Config</span> <span class="n">config</span> <span class="o">=</span> <span class="n">Config</span><span class="p">(</span><span class="mh">0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970</span><span class="p">);</span>
            <span class="n">NameReg</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="mi">1</span><span class="p">)).</span><span class="n">unregister</span><span class="p">();</span>
            <span class="c1">// It is still possible to call a specific</span>
            <span class="c1">// overridden function.</span>
            <span class="n">mortal</span><span class="p">.</span><span class="n">kill</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// If a constructor takes an argument, it needs to be</span>
<span class="c1">// provided in the header (or modifier-invocation-style at</span>
<span class="c1">// the constructor of the derived contract (see below)).</span>
<span class="kd">contract</span> <span class="n">PriceFeed</span> <span class="kr">is</span> <span class="n">owned</span><span class="p">,</span> <span class="n">mortal</span><span class="p">,</span> <span class="n">named</span><span class="p">(</span><span class="s">&quot;GoldFeed&quot;</span><span class="p">)</span> <span class="p">{</span>
   <span class="kd">function</span> <span class="n">updateInfo</span><span class="p">(</span><span class="kt">uint</span> <span class="n">newInfo</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nb">msg.sender</span> <span class="o">==</span> <span class="n">owner</span><span class="p">)</span> <span class="n">info</span> <span class="o">=</span> <span class="n">newInfo</span><span class="p">;</span>
   <span class="p">}</span>

   <span class="kd">function</span> <span class="n">get</span><span class="p">()</span> <span class="kr">public</span> <span class="kr">view</span> <span class="k">returns</span><span class="p">(</span><span class="kt">uint</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">info</span><span class="p">;</span> <span class="p">}</span>

   <span class="kt">uint</span> <span class="n">info</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上記注目して頂きたいのですが、破壊の要求を”転送”するのに <code class="docutils literal notranslate"><span class="pre">mortal.kill()</span></code> を呼んでいます。これは下記の例で見られる様に問題があります:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">22</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">owned</span> <span class="p">{</span>
    <span class="kd">constructor</span><span class="p">()</span> <span class="kr">public</span> <span class="p">{</span> <span class="n">owner</span> <span class="o">=</span> <span class="nb">msg.sender</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">address</span> <span class="kr">payable</span> <span class="n">owner</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">mortal</span> <span class="kr">is</span> <span class="n">owned</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">kill</span><span class="p">()</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">msg.sender</span> <span class="o">==</span> <span class="n">owner</span><span class="p">)</span> <span class="nb">selfdestruct</span><span class="p">(</span><span class="n">owner</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">Base1</span> <span class="kr">is</span> <span class="n">mortal</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">kill</span><span class="p">()</span> <span class="kr">public</span> <span class="p">{</span> <span class="cm">/* do cleanup 1 */</span> <span class="n">mortal</span><span class="p">.</span><span class="n">kill</span><span class="p">();</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">Base2</span> <span class="kr">is</span> <span class="n">mortal</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">kill</span><span class="p">()</span> <span class="kr">public</span> <span class="p">{</span> <span class="cm">/* do cleanup 2 */</span> <span class="n">mortal</span><span class="p">.</span><span class="n">kill</span><span class="p">();</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">Final</span> <span class="kr">is</span> <span class="n">Base1</span><span class="p">,</span> <span class="n">Base2</span> <span class="p">{</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Final.kill()</span></code> のコールは、最後にオーバーライドされたものとして <code class="docutils literal notranslate"><span class="pre">Base2.kill</span></code> を呼び出し、このファンクションは <code class="docutils literal notranslate"><span class="pre">Base1.kill</span></code> をバイパスします。なぜなら、そのファンクションは <code class="docutils literal notranslate"><span class="pre">Base1</span></code> を把握していないからです。これの回避策は <code class="docutils literal notranslate"><span class="pre">super</span></code> を使うことです:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">22</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">owned</span> <span class="p">{</span>
    <span class="kd">constructor</span><span class="p">()</span> <span class="kr">public</span> <span class="p">{</span> <span class="n">owner</span> <span class="o">=</span> <span class="nb">msg.sender</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">address</span> <span class="kr">payable</span> <span class="n">owner</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">mortal</span> <span class="kr">is</span> <span class="n">owned</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">kill</span><span class="p">()</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">msg.sender</span> <span class="o">==</span> <span class="n">owner</span><span class="p">)</span> <span class="nb">selfdestruct</span><span class="p">(</span><span class="n">owner</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">Base1</span> <span class="kr">is</span> <span class="n">mortal</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">kill</span><span class="p">()</span> <span class="kr">public</span> <span class="p">{</span> <span class="cm">/* do cleanup 1 */</span> <span class="nb">super</span><span class="p">.</span><span class="n">kill</span><span class="p">();</span> <span class="p">}</span>
<span class="p">}</span>


<span class="kd">contract</span> <span class="n">Base2</span> <span class="kr">is</span> <span class="n">mortal</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">kill</span><span class="p">()</span> <span class="kr">public</span> <span class="p">{</span> <span class="cm">/* do cleanup 2 */</span> <span class="nb">super</span><span class="p">.</span><span class="n">kill</span><span class="p">();</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">Final</span> <span class="kr">is</span> <span class="n">Base1</span><span class="p">,</span> <span class="n">Base2</span> <span class="p">{</span>
<span class="p">}</span>
</pre></div>
</div>
<p>もし <code class="docutils literal notranslate"><span class="pre">Base2</span></code> が <code class="docutils literal notranslate"><span class="pre">super</span></code> のファンクションを呼び出しても、単純にベースコントラクトの内の1つのこのファンクションを呼び出しません。最終的な継承図の中のベースコントラクトの次のコントラクトのファンクションを呼び出します。そのため、<code class="docutils literal notranslate"><span class="pre">Base1.kill()</span></code> を呼び出します（最終的な継承の順番は、最後に継承されたコントラクトから始まります: Final、Base2、Base1、mortal、owned）。
superを使った時に呼び出される実際のファンクションは、型が分かっていても、そのクラスのコンテキストの中ではわかりません。これは一般的な仮想メソッドの検索に似ています。</p>
<div class="section" id="constructors">
<span id="constructor"></span><span id="index-16"></span><h3>Constructors<a class="headerlink" href="#constructors" title="Permalink to this headline">¶</a></h3>
<p>コンストラクタは <code class="docutils literal notranslate"><span class="pre">constructor</span></code> キーワードで宣言され、コントラクト生成時に実行される任意のファンクションで、コントラクトの初期化コードを実行できます。</p>
<p>コンストラクタが実行される前に、インラインで初期化していれば状態変数はその値で初期化され、していなければ0になります。</p>
<p>コンストラクタが実行された後、コントラクトの最終的なコードがブロックチェーンにデプロイされます。コードのデプロイはコードの長さに比例して追加のガスコストがかかります。
このコードはpublicインターフェースの一部でありファンクション全てと、ファンクションコールを通じてアクセスできるファンクションを含んでいます。
このコードはコンストラクタのコードと、コンストラクタからのみ呼ばれるinternalのファンクションは含んでいません。</p>
<p>コンストラクタは <code class="docutils literal notranslate"><span class="pre">public</span></code> か <code class="docutils literal notranslate"><span class="pre">internal</span></code> です。もし、コンストラクタがなかったら、コントラクトはデフォルトのコンストラクタ（ <code class="docutils literal notranslate"><span class="pre">constructor()</span> <span class="pre">public</span> <span class="pre">{}</span></code> と等価の）を想定します。例えば:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">^</span><span class="mf">0.5</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">A</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="kr">public</span> <span class="n">a</span><span class="p">;</span>

    <span class="kd">constructor</span><span class="p">(</span><span class="kt">uint</span> <span class="n">_a</span><span class="p">)</span> <span class="kr">internal</span> <span class="p">{</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">_a</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">B</span> <span class="kr">is</span> <span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">constructor</span><span class="p">()</span> <span class="kr">public</span> <span class="p">{}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>コンストラクタを <code class="docutils literal notranslate"><span class="pre">internal</span></code> でセットすると、そのコントラクトは <a class="reference internal" href="#abstract-contract"><span class="std std-ref">abstract</span></a> になります。</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">0.4.22以前ではコンストラクタはコントラクトと同じ名前のファンクションとして定義されていました。このシンタックスは非推奨となり、バージョン0.5.0で使えなくなりました。</p>
</div>
</div>
<div class="section" id="arguments-for-base-constructors">
<span id="index-17"></span><h3>Arguments for Base Constructors<a class="headerlink" href="#arguments-for-base-constructors" title="Permalink to this headline">¶</a></h3>
<p>全てのベースコントラクトのコンストラクタは下記で説明される線形ルールに則り呼び出されます。もしベースコンストラクタが引数を持っていたら、継承したコントラクトはその全てを指定する必要があります。
2通りの方法でできます:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">22</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">Base</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="n">x</span><span class="p">;</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="kt">uint</span> <span class="n">_x</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span> <span class="n">x</span> <span class="o">=</span> <span class="n">_x</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Either directly specify in the inheritance list...</span>
<span class="kd">contract</span> <span class="n">Derived1</span> <span class="kr">is</span> <span class="n">Base</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">constructor</span><span class="p">()</span> <span class="kr">public</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="c1">// or through a &quot;modifier&quot; of the derived constructor.</span>
<span class="kd">contract</span> <span class="n">Derived2</span> <span class="kr">is</span> <span class="n">Base</span> <span class="p">{</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="kt">uint</span> <span class="n">_y</span><span class="p">)</span> <span class="n">Base</span><span class="p">(</span><span class="n">_y</span> <span class="o">*</span> <span class="n">_y</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>1つ目の方法は直接継承のリストに入れることです(<code class="docutils literal notranslate"><span class="pre">is</span> <span class="pre">Base(7)</span></code>)。もう1つの方法は継承したコンストラクタの一部としてmodifierを呼び出します(<code class="docutils literal notranslate"><span class="pre">Base(_y</span> <span class="pre">*</span> <span class="pre">_y)</span></code>)。もしコンストラクタの引数が定数で、コントラクトの挙動を決めるもしくは表現するものである場合、最初の方法の方が便利です。もしベースのコンストラクタの引数が継承したコントラクトによるのであれば、2つ目の方法を使う必要があります。引数は継承のリスト、もしくは継承したコンストラクタのmodifierスタイルで与えられる必要があります。
両方で引数を指定するとエラーとなります。</p>
<p>もし継承したコントラクトがベースコントラクトのコンストラクタに対する引数を決めなかった場合、そのコントラクトは抽象コントラクトになります。</p>
</div>
<div class="section" id="multiple-inheritance-and-linearization">
<span id="multi-inheritance"></span><span id="index-18"></span><h3>Multiple Inheritance and Linearization<a class="headerlink" href="#multiple-inheritance-and-linearization" title="Permalink to this headline">¶</a></h3>
<p>多重継承ができる言語はいくつかの問題を扱わなければいけません。1つは <a class="reference external" href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem">Diamond Problem</a> です。SolidityはPythonに似ていて、”<a class="reference external" href="https://en.wikipedia.org/wiki/C3_linearization">C3 Linearization</a>”を使っており、ベースクラスのdirected acyclic graph (DAG)で特定の順番にさせています。これはmonotonicityの理想的な性質を実現していますが、いくつかの継承図を許可していません。
特に、<code class="docutils literal notranslate"><span class="pre">is</span></code> で与えられたベースクラスの順番が重要です。直のベースコントラクトを”一番ベースになるもの”から”最後に継承されるもの”の順で並べなければいけません。
これはPythonとは逆の順序であることに気をつけて下さい。</p>
<p>これを説明する別のシンプルな方法は、異なるコントラクトで何度か定義されたファンクションが呼ばれる時、ベースコントラクトは縦型探索で右から左に調べて（Pythonだと左から右）、最初にマッチしたところで止まります。もしすでにベースコントラクトが検索済みだった場合、それはスキップされます。</p>
<p>下記のコードでは、Solidityは”Linearization of inheritance graph impossible”というエラーを出します。</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">X</span> <span class="p">{}</span>
<span class="kd">contract</span> <span class="n">A</span> <span class="kr">is</span> <span class="n">X</span> <span class="p">{}</span>
<span class="c1">// This will not compile</span>
<span class="kd">contract</span> <span class="n">C</span> <span class="kr">is</span> <span class="n">A</span><span class="p">,</span> <span class="n">X</span> <span class="p">{}</span>
</pre></div>
</div>
<p>この理由は、<code class="docutils literal notranslate"><span class="pre">A</span></code> をオーバーライドするのに <code class="docutils literal notranslate"><span class="pre">C</span></code> は <code class="docutils literal notranslate"><span class="pre">X</span></code> をリクエストしましたが、<code class="docutils literal notranslate"><span class="pre">A</span></code>　自体は <code class="docutils literal notranslate"><span class="pre">X</span></code> をオーバーライドしようとしたので、矛盾が生まれたことです。</p>
</div>
<div class="section" id="inheriting-different-kinds-of-members-of-the-same-name">
<h3>Inheriting Different Kinds of Members of the Same Name<a class="headerlink" href="#inheriting-different-kinds-of-members-of-the-same-name" title="Permalink to this headline">¶</a></h3>
<p>継承の結果、同じ名前のファンクションとmodifierがあるコントラクトになった場合、エラーになります。
このエラーは同じイベント名とmodifier名、同じイベント名とファンクション名でも起きます。
例外として、状態変数のgetterはpublicファンクションをオーバーライドできます。</p>
</div>
</div>
<div class="section" id="abstract-contracts">
<span id="abstract-contract"></span><span id="index-19"></span><h2>Abstract Contracts<a class="headerlink" href="#abstract-contracts" title="Permalink to this headline">¶</a></h2>
<p>アブストラクトとなるコントラクトは少なくとも1つのファンクションは下記の様に実行部がないものを持っています（ファンクションのヘッダーが <code class="docutils literal notranslate"><span class="pre">;</span></code> で終わっていることを確認して下さい）:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">Feline</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">utterance</span><span class="p">()</span> <span class="kr">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes32</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>その様なコントラクトはコンパイルできません（実行できるファンクションが一緒にあったとしても）が、ベースコントラクトとして使用することができます:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">Feline</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">utterance</span><span class="p">()</span> <span class="kr">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes32</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">Cat</span> <span class="kr">is</span> <span class="n">Feline</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">utterance</span><span class="p">()</span> <span class="kr">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes32</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;miaow&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>もしあるコントラクトがアブストラクトを継承し、全ての非実行のファンクションをオーバーライドした上で、実行しなかった場合、そのコントラクト自体がアブストラクトになります。</p>
<p>シンタックスはとても似ていますが、実行しないファンクションは <a class="reference internal" href="types.html#function-types"><span class="std std-ref">Function Type</span></a> とは違うということに注意してください。</p>
<p>実行しないファンクションの例（ファンクションの宣言）です:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="n">foo</span><span class="p">(</span><span class="kt">address</span><span class="p">)</span> <span class="kr">external</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">address</span><span class="p">);</span>
</pre></div>
</div>
<p>ファンクション型の例です（変数の型が <code class="docutils literal notranslate"><span class="pre">function</span></code> である変数の宣言）:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="p">(</span><span class="kt">address</span><span class="p">)</span> <span class="kr">external</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">address</span><span class="p">)</span> <span class="n">foo</span><span class="p">;</span>
</pre></div>
</div>
<p>アブストラクトコントラクトは、より良い拡張性を持つ実装や、自己文書化、<a class="reference external" href="https://en.wikipedia.org/wiki/Template_method_pattern">Template method</a> の様なファシリテーションパターン、コード複製の削除を、コントラクトの定義から切り離します。
アブストラクトコントラクトはインターフェースに置いてメソッド定義が便利なのと同じ様に便利です。これがアブストラクトコントラクトの作成者が「自分の子は全てこのメソッドを実行する」と言うための方法です。</p>
</div>
<div class="section" id="interfaces">
<span id="index-20"></span><span id="id11"></span><h2>Interfaces<a class="headerlink" href="#interfaces" title="Permalink to this headline">¶</a></h2>
<p>インターフェースはアブストラクトコントラクトに似ていますが、どんなファンクションも実行することはできません。他の制限がこちらです。</p>
<ul class="simple">
<li>他のコントラクやインターフェースを継承できません。</li>
<li>全ての宣言されたファンクションはexternalでなければいけません。</li>
<li>コンストラクタは使えません。</li>
<li>状態変数は宣言できません。</li>
</ul>
<p>将来的にはこの制限のいくつかは撤廃されるかもしれません。</p>
<p>インターフェースは基本的にコントラクトABIが表せるものに制限され、ABIとインターフェース間の変換は、どんな情報の喪失もなく行われるはずです。</p>
<p>インターフェースはinterfaceというキーワードで表されます。</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">^</span><span class="mf">0.5</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">interface</span> <span class="n">Token</span> <span class="p">{</span>
    <span class="kd">enum</span> <span class="n">TokenType</span> <span class="p">{</span> <span class="n">Fungible</span><span class="p">,</span> <span class="n">NonFungible</span> <span class="p">}</span>
    <span class="kd">struct</span> <span class="n">Coin</span> <span class="p">{</span> <span class="kt">string</span> <span class="n">obverse</span><span class="p">;</span> <span class="kt">string</span> <span class="n">reverse</span><span class="p">;</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="nf">transfer</span><span class="p">(</span><span class="kt">address</span> <span class="n">recipient</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">amount</span><span class="p">)</span> <span class="kr">external</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>コントラクトは他のコントラクトを継承するようにインターフェースを継承できます。</p>
<p>インターフェース内で定義された型と他のコントラクトの様な構造は他のコントラクトからアクセスできます: <code class="docutils literal notranslate"><span class="pre">Token.TokenType</span></code> もしくは <code class="docutils literal notranslate"><span class="pre">Token.Coin</span></code></p>
</div>
<div class="section" id="libraries">
<span id="index-21"></span><span id="id12"></span><h2>Libraries<a class="headerlink" href="#libraries" title="Permalink to this headline">¶</a></h2>
<p>ライブラリはコントラクトに似ていますが、ある特定のアドレスに一度だけデプロイされ、<code class="docutils literal notranslate"><span class="pre">DELEGATECALL</span></code> (Homesteadまでは <code class="docutils literal notranslate"><span class="pre">CALLCODE</span></code>)を使って、そのコードを再利用するのが目的です。つまり、ライブラリのファンクションが呼び出されたら、呼び出したコントラクトのコンテキストで実行されます。<code class="docutils literal notranslate"><span class="pre">this</span></code> は呼び出したコントラクトを指しますし、特に呼び出し元のコントラクトのストレージもアクセス可能です。ライブラリは独立したソースコードなので、状態変数が明示的に渡された場合、呼び出したコントラクトの状態変数にアクセスできます（そうでないと名前をつけられません）。
ライブラリのファンクションはステートを変更しない場合（ <code class="docutils literal notranslate"><span class="pre">view</span></code> もしくは <code class="docutils literal notranslate"><span class="pre">pure</span></code> の場合）、直接呼び出すことしかできません（つまり <code class="docutils literal notranslate"><span class="pre">DELEGATECALL</span></code> を使わない）。なぜなら、ライブラリはステートレスと想定されているからです。つまり、ライブラリを破棄することはできません。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">バージョン0.4.20までは、Solidityのタイプシステムを迂回することで、ライブラリの破棄が可能でした。
そのバージョンから、ライブラリがステートを変更するファンクションを直接呼び出す <a class="reference internal" href="#call-protection"><span class="std std-ref">mechanism</span></a> を導入しました（つまり <code class="docutils literal notranslate"><span class="pre">DELEGATECALL</span></code> を使わない）。</p>
</div>
<p>ライブラリはコントラクトが使う暗示的なベースコントラクトと見做すことができます。ライブラリは継承の階層の中で明示的に可視ではないですが、ライブラリのファンクションを呼ぶのは、明示的なベースファンクションを呼ぶ様なものです（ <code class="docutils literal notranslate"><span class="pre">L</span></code> がライブラリの名前の時に <code class="docutils literal notranslate"><span class="pre">L.f()</span></code> ）。さらに、ライブラリの <code class="docutils literal notranslate"><span class="pre">internal</span></code> ファンクションはまるでライブラリがベースコントラクトであるかの様に、全てのコントラクトからアクセスできます。もちろんinternalのファンクションを呼び出すにはinternalの呼び出しのルールに従う必要があります。それは全てのinternalタイプは受け渡されて、<a class="reference internal" href="types.html#data-location"><span class="std std-ref">メモリに保存</span></a> された型は参照として渡され、コピーされないということです。
EVMでこれを実現するために、internalのライブラリファンクションのコードとその中から呼ばれるファンクションはコンパイル時に呼び出し元のコントラクトに入り、<code class="docutils literal notranslate"><span class="pre">DELEGATECALL</span></code> の代わりに通常の <code class="docutils literal notranslate"><span class="pre">JUMP</span></code> コールが使用されます。</p>
<p id="index-22">次の例ではどの様にライブラリを使うかを説明します（マニュアルメソッドに関してはより詳細な例 <a class="reference internal" href="#using-for"><span class="std std-ref">using for</span></a> を参照ください）。</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">22</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">library</span> <span class="n">Set</span> <span class="p">{</span>
  <span class="c1">// We define a new struct datatype that will be used to</span>
  <span class="c1">// hold its data in the calling contract.</span>
  <span class="kd">struct</span> <span class="n">Data</span> <span class="p">{</span> <span class="kd">mapping</span><span class="p">(</span><span class="kt">uint</span> <span class="o">=&gt;</span> <span class="kt">bool</span><span class="p">)</span> <span class="n">flags</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Note that the first parameter is of type &quot;storage</span>
  <span class="c1">// reference&quot; and thus only its storage address and not</span>
  <span class="c1">// its contents is passed as part of the call.  This is a</span>
  <span class="c1">// special feature of library functions.  It is idiomatic</span>
  <span class="c1">// to call the first parameter `self`, if the function can</span>
  <span class="c1">// be seen as a method of that object.</span>
  <span class="kd">function</span> <span class="n">insert</span><span class="p">(</span><span class="n">Data</span> <span class="kr">storage</span> <span class="n">self</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">value</span><span class="p">)</span>
      <span class="kr">public</span>
      <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">flags</span><span class="p">[</span><span class="n">value</span><span class="p">])</span>
          <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// already there</span>
      <span class="n">self</span><span class="p">.</span><span class="n">flags</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="n">remove</span><span class="p">(</span><span class="n">Data</span> <span class="kr">storage</span> <span class="n">self</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">value</span><span class="p">)</span>
      <span class="kr">public</span>
      <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="p">.</span><span class="n">flags</span><span class="p">[</span><span class="n">value</span><span class="p">])</span>
          <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// not there</span>
      <span class="n">self</span><span class="p">.</span><span class="n">flags</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="n">contains</span><span class="p">(</span><span class="n">Data</span> <span class="kr">storage</span> <span class="n">self</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">value</span><span class="p">)</span>
      <span class="kr">public</span>
      <span class="kr">view</span>
      <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">flags</span><span class="p">[</span><span class="n">value</span><span class="p">];</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">C</span> <span class="p">{</span>
    <span class="n">Set</span><span class="p">.</span><span class="n">Data</span> <span class="n">knownValues</span><span class="p">;</span>

    <span class="kd">function</span> <span class="n">register</span><span class="p">(</span><span class="kt">uint</span> <span class="n">value</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="c1">// The library functions can be called without a</span>
        <span class="c1">// specific instance of the library, since the</span>
        <span class="c1">// &quot;instance&quot; will be the current contract.</span>
        <span class="nf">require</span><span class="p">(</span><span class="n">Set</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">knownValues</span><span class="p">,</span> <span class="n">value</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="c1">// In this contract, we can also directly access knownValues.flags, if we want.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>もちろん、ライブラリを使うのにこの方法に従う必要はありません。構造体型を定義しなくても使えます。ファンクションはストレージの参照型を使わなくても動きますし、どこでも複数のストレージの参照型を持つことができます。</p>
<p><code class="docutils literal notranslate"><span class="pre">Set.contains</span></code>、<code class="docutils literal notranslate"><span class="pre">Set.insert</span></code>、<code class="docutils literal notranslate"><span class="pre">Set.remove</span></code> の呼び出しは外部のコントラクト、ライブラリの呼び出し(<code class="docutils literal notranslate"><span class="pre">DELEGATECALL</span></code>)としてコンパイルされます。もしライブラリを使うなら、1つの実際のexternalのファンクションコールが実行されることを覚えておいてください。<code class="docutils literal notranslate"><span class="pre">msg.sender</span></code>、<code class="docutils literal notranslate"><span class="pre">msg.value</span></code>、<code class="docutils literal notranslate"><span class="pre">this</span></code> はその値をこのコール中に保持します（ <code class="docutils literal notranslate"><span class="pre">CALLCODE</span></code>、<code class="docutils literal notranslate"><span class="pre">msg.sender</span></code>、<code class="docutils literal notranslate"><span class="pre">msg.value</span></code> の使用方法が変わったため、Homestead以前で有効です）。</p>
<p>以下の例では、externalファンクションコールのオーバーヘッドなしでカスタム型を実行するために、<a class="reference internal" href="types.html#data-location"><span class="std std-ref">メモリに保存される型</span></a> とライブラリのinternalファンクションをどの様に使用するか示しています。</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">library</span> <span class="n">BigInt</span> <span class="p">{</span>
    <span class="kd">struct</span> <span class="n">bigint</span> <span class="p">{</span>
        <span class="kt">uint</span><span class="p">[]</span> <span class="n">limbs</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">fromUint</span><span class="p">(</span><span class="kt">uint</span> <span class="n">x</span><span class="p">)</span> <span class="kr">internal</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="n">bigint</span> <span class="kr">memory</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">r</span><span class="p">.</span><span class="n">limbs</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">uint</span><span class="p">[](</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">r</span><span class="p">.</span><span class="n">limbs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">add</span><span class="p">(</span><span class="n">bigint</span> <span class="kr">memory</span> <span class="n">_a</span><span class="p">,</span> <span class="n">bigint</span> <span class="kr">memory</span> <span class="n">_b</span><span class="p">)</span> <span class="kr">internal</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="n">bigint</span> <span class="kr">memory</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">r</span><span class="p">.</span><span class="n">limbs</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">uint</span><span class="p">[](</span><span class="n">max</span><span class="p">(</span><span class="n">_a</span><span class="p">.</span><span class="n">limbs</span><span class="p">.</span><span class="n">length</span><span class="p">,</span> <span class="n">_b</span><span class="p">.</span><span class="n">limbs</span><span class="p">.</span><span class="n">length</span><span class="p">));</span>
        <span class="kt">uint</span> <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">.</span><span class="n">limbs</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">uint</span> <span class="n">a</span> <span class="o">=</span> <span class="n">limb</span><span class="p">(</span><span class="n">_a</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
            <span class="kt">uint</span> <span class="n">b</span> <span class="o">=</span> <span class="n">limb</span><span class="p">(</span><span class="n">_b</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
            <span class="n">r</span><span class="p">.</span><span class="n">limbs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">carry</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">a</span> <span class="o">||</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">==</span> <span class="kt">uint</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">carry</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
                <span class="n">carry</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">carry</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// too bad, we have to add a limb</span>
            <span class="kt">uint</span><span class="p">[]</span> <span class="kr">memory</span> <span class="n">newLimbs</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">uint</span><span class="p">[](</span><span class="n">r</span><span class="p">.</span><span class="n">limbs</span><span class="p">.</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="kt">uint</span> <span class="n">i</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">.</span><span class="n">limbs</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
                <span class="n">newLimbs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">limbs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">newLimbs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">carry</span><span class="p">;</span>
            <span class="n">r</span><span class="p">.</span><span class="n">limbs</span> <span class="o">=</span> <span class="n">newLimbs</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">limb</span><span class="p">(</span><span class="n">bigint</span> <span class="kr">memory</span> <span class="n">_a</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">_limb</span><span class="p">)</span> <span class="kr">internal</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">_limb</span> <span class="o">&lt;</span> <span class="n">_a</span><span class="p">.</span><span class="n">limbs</span><span class="p">.</span><span class="n">length</span> <span class="o">?</span> <span class="n">_a</span><span class="p">.</span><span class="n">limbs</span><span class="p">[</span><span class="n">_limb</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">max</span><span class="p">(</span><span class="kt">uint</span> <span class="n">a</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">b</span><span class="p">)</span> <span class="kr">private</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kn">using</span> <span class="n">BigInt</span> <span class="k">for</span> <span class="n">BigInt</span><span class="p">.</span><span class="n">bigint</span><span class="p">;</span>

    <span class="kd">function</span> <span class="n">f</span><span class="p">()</span> <span class="kr">public</span> <span class="kr">pure</span> <span class="p">{</span>
        <span class="n">BigInt</span><span class="p">.</span><span class="n">bigint</span> <span class="kr">memory</span> <span class="n">x</span> <span class="o">=</span> <span class="n">BigInt</span><span class="p">.</span><span class="n">fromUint</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
        <span class="n">BigInt</span><span class="p">.</span><span class="n">bigint</span> <span class="kr">memory</span> <span class="n">y</span> <span class="o">=</span> <span class="n">BigInt</span><span class="p">.</span><span class="n">fromUint</span><span class="p">(</span><span class="kt">uint</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
        <span class="n">BigInt</span><span class="p">.</span><span class="n">bigint</span> <span class="kr">memory</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
        <span class="nf">assert</span><span class="p">(</span><span class="n">z</span><span class="p">.</span><span class="n">limb</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ライブラリがどこにデプロイされるかコンパイラは分からないので、アドレスはlinkerで最後のバイトコードに入れられる必要があります（リンキングのためのコマンドラインコンパイラの使い方は <a class="reference internal" href="using-the-compiler.html#commandline-compiler"><span class="std std-ref">Using the Commandline Compiler</span></a> を参照下さい）。もしアドレスが引数としてコンパイラに渡されない場合、コンパイラの16進数コードは <code class="docutils literal notranslate"><span class="pre">__Set______</span></code> (
<code class="docutils literal notranslate"><span class="pre">Set</span></code> はライブラリの名前) のプレースホルダを含みます。ライブラリコントラクトのアドレスの16進数エンコーディングによって、アドレスは手動で40個の記号で置き換えられ、埋められます。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">生成されたバイトコード上でのライブラリの手動のリンキングは推奨されません。なぜなら、36文字に制限されているからです。コントラクトが <code class="docutils literal notranslate"><span class="pre">solc</span></code> の <code class="docutils literal notranslate"><span class="pre">--libraries</span></code> オプションか、コンパイラにstandard-JSONインターフェースを使っているなら、<code class="docutils literal notranslate"><span class="pre">libraries</span></code> キーを使ってコンパイルされている時に、コンパイラにライブラリをリンクすることをお願いした方が良いです。</p>
</div>
<p>コントラクトと比べた時のライブラリの制限は:</p>
<ul class="simple">
<li>状態変数がありません</li>
<li>継承する、継承されることはありません</li>
<li>Etherを受け取ることができません</li>
</ul>
<p>(これらはいつか撤廃されるかもしれません)</p>
<div class="section" id="call-protection-for-libraries">
<span id="call-protection"></span><h3>Call Protection For Libraries<a class="headerlink" href="#call-protection-for-libraries" title="Permalink to this headline">¶</a></h3>
<p>イントロダクションで言及した通り、ライブラリのコードが <code class="docutils literal notranslate"><span class="pre">DELEGATECALL</span></code> もしくは <code class="docutils literal notranslate"><span class="pre">CALLCODE</span></code> の代わりに <code class="docutils literal notranslate"><span class="pre">CALL</span></code> で実行された時、<code class="docutils literal notranslate"><span class="pre">view</span></code> か <code class="docutils literal notranslate"><span class="pre">pure</span></code> でなければrevertします。</p>
<p>EVMではコントラクトが <code class="docutils literal notranslate"><span class="pre">CALL</span></code> で呼ばれたかどうか直接検知する方法はありませんが、そのコードが現在”どこ”で動作しているか調べる <code class="docutils literal notranslate"><span class="pre">ADDRESS</span></code> opcodeは使えます。生成されたコードは呼び出しの種類を決めるために、このアドレスとコード生成時に使われたアドレスを比較します。</p>
<p>特に、ライブラリのラインタイムコードはpushから始まります。それはコンパイル時に20バイトの0で構成されています。デプロイコードがまわっている時、この定数は現在のアドレスでメモリ内で置き換えられ、修正されたコードがコントラクトに保存されます。ランタイム時に、デプロイ時のアドレスが最初の定数となって、スタック上にプッシュされ、ディスパッチャーコードが現在のアドレスとその定数をviewでもpureでもないファンクションのために比較します。</p>
</div>
</div>
<div class="section" id="using-for">
<span id="index-23"></span><span id="id13"></span><h2>Using For<a class="headerlink" href="#using-for" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">A</span> <span class="pre">for</span> <span class="pre">B;</span></code> という指示はライブラリのファンクション（ <code class="docutils literal notranslate"><span class="pre">A</span></code> というライブラリから）をどんな型(<code class="docutils literal notranslate"><span class="pre">B</span></code>)にも加えるのに使うことができます。
このファンクションは最初のパラメータとして（Pythonの <code class="docutils literal notranslate"><span class="pre">self</span></code> の様に）、そのファンクションを呼び出したオブジェクトを受け取ります。</p>
<p><code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">A</span> <span class="pre">for</span> <span class="pre">*;</span></code> というのは、ライブラリ <code class="docutils literal notranslate"><span class="pre">A</span></code> のファンクションが <em>どんな</em> 型にも追加されるということです。</p>
<p>いずれの場合でも、最初のパラメータの型がオブジェクトの型と合わなくても、ライブラリ中の <em>全ての</em> ファンクションが追加されます。ファンクションが呼ばれた時に型はチェックされ、ファンクションのoverload resolutionが実行されます。</p>
<p><code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">A</span> <span class="pre">for</span> <span class="pre">B;</span></code> は現在の全てのファンクション内も含むコントラクト内でのみ有効です。そのコントラクトが使用されている外部のコントラクトでは使えません。この指示はファンクション内でなく、コントラクト内でのみ実行可能です。</p>
<p>ライブラリを含めることにより、ライブラリのファンクションを含むデータタイプが追加のコードなしで使える様になります。</p>
<p><a class="reference internal" href="#libraries"><span class="std std-ref">Libraries</span></a> の例を書き換えてみます:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="c1">// This is the same code as before, just without comments</span>
<span class="kd">library</span> <span class="n">Set</span> <span class="p">{</span>
  <span class="kd">struct</span> <span class="n">Data</span> <span class="p">{</span> <span class="kd">mapping</span><span class="p">(</span><span class="kt">uint</span> <span class="o">=&gt;</span> <span class="kt">bool</span><span class="p">)</span> <span class="n">flags</span><span class="p">;</span> <span class="p">}</span>

  <span class="kd">function</span> <span class="n">insert</span><span class="p">(</span><span class="n">Data</span> <span class="kr">storage</span> <span class="n">self</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">value</span><span class="p">)</span>
      <span class="kr">public</span>
      <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">flags</span><span class="p">[</span><span class="n">value</span><span class="p">])</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// already there</span>
      <span class="n">self</span><span class="p">.</span><span class="n">flags</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="n">remove</span><span class="p">(</span><span class="n">Data</span> <span class="kr">storage</span> <span class="n">self</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">value</span><span class="p">)</span>
      <span class="kr">public</span>
      <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="p">.</span><span class="n">flags</span><span class="p">[</span><span class="n">value</span><span class="p">])</span>
          <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// not there</span>
      <span class="n">self</span><span class="p">.</span><span class="n">flags</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="n">contains</span><span class="p">(</span><span class="n">Data</span> <span class="kr">storage</span> <span class="n">self</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">value</span><span class="p">)</span>
      <span class="kr">public</span>
      <span class="kr">view</span>
      <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">flags</span><span class="p">[</span><span class="n">value</span><span class="p">];</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kn">using</span> <span class="n">Set</span> <span class="k">for</span> <span class="n">Set</span><span class="p">.</span><span class="n">Data</span><span class="p">;</span> <span class="c1">// this is the crucial change</span>
    <span class="n">Set</span><span class="p">.</span><span class="n">Data</span> <span class="n">knownValues</span><span class="p">;</span>

    <span class="kd">function</span> <span class="n">register</span><span class="p">(</span><span class="kt">uint</span> <span class="n">value</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="c1">// Here, all variables of type Set.Data have</span>
        <span class="c1">// corresponding member functions.</span>
        <span class="c1">// The following function call is identical to</span>
        <span class="c1">// `Set.insert(knownValues, value)`</span>
        <span class="nf">require</span><span class="p">(</span><span class="n">knownValues</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この様に基本型を拡張することも可能です:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">library</span> <span class="n">Search</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">indexOf</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="kr">storage</span> <span class="n">self</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">value</span><span class="p">)</span>
        <span class="kr">public</span>
        <span class="kr">view</span>
        <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">self</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">value</span><span class="p">)</span> <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">return</span> <span class="kt">uint</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kn">using</span> <span class="n">Search</span> <span class="k">for</span> <span class="kt">uint</span><span class="p">[];</span>
    <span class="kt">uint</span><span class="p">[]</span> <span class="n">data</span><span class="p">;</span>

    <span class="kd">function</span> <span class="n">append</span><span class="p">(</span><span class="kt">uint</span> <span class="n">value</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="n">data</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">replace</span><span class="p">(</span><span class="kt">uint</span> <span class="n">_old</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">_new</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="c1">// This performs the library function call</span>
        <span class="kt">uint</span> <span class="n">index</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">indexOf</span><span class="p">(</span><span class="n">_old</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="kt">uint</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">data</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">_new</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">_new</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>全てのライブラリのコールは実際のEVMのファンクションコールであるということを覚えておいてください。つまり、もしメモリもしくは値型を渡す時には、<code class="docutils literal notranslate"><span class="pre">self</span></code> 変数であってもコピーが実行されます。ストレージ参照の変数が使われた時だけ、コピーは実行されません。</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="assembly.html" class="btn btn-neutral float-right" title="Solidity Assembly" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="control-structures.html" class="btn btn-neutral float-left" title="Expressions and Control Structures" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016-2019, Ethereum

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>