

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Types &mdash; Solidity 0.5.4 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Units and Globally Available Variables" href="units-and-global-variables.html" />
    <link rel="prev" title="Structure of a Contract" href="structure-of-a-contract.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Solidity
          

          
          </a>

          
            
            
              <div class="version">
                0.5.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
    
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction-to-smart-contracts.html">Introduction to Smart Contracts</a></li>
<li class="toctree-l1"><a class="reference internal" href="installing-solidity.html">Installing the Solidity Compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="solidity-by-example.html">Solidity by Example</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="solidity-in-depth.html">Solidity in Depth</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="layout-of-source-files.html">Layout of a Solidity Source File</a></li>
<li class="toctree-l2"><a class="reference internal" href="structure-of-a-contract.html">Structure of a Contract</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#value-types">Value Types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#booleans">Booleans</a></li>
<li class="toctree-l4"><a class="reference internal" href="#integers">Integers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fixed-point-numbers">Fixed Point Numbers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#address">Address</a></li>
<li class="toctree-l4"><a class="reference internal" href="#contract-types">Contract Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fixed-size-byte-arrays">Fixed-size byte arrays</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dynamically-sized-byte-array">Dynamically-sized byte array</a></li>
<li class="toctree-l4"><a class="reference internal" href="#address-literals">Address Literals</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rational-and-integer-literals">Rational and Integer Literals</a></li>
<li class="toctree-l4"><a class="reference internal" href="#string-literals-and-types">String Literals and Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hexadecimal-literals">Hexadecimal Literals</a></li>
<li class="toctree-l4"><a class="reference internal" href="#enums">Enums</a></li>
<li class="toctree-l4"><a class="reference internal" href="#function-types">Function Types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#reference-types">Reference Types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#data-location">Data location</a></li>
<li class="toctree-l4"><a class="reference internal" href="#arrays">Arrays</a></li>
<li class="toctree-l4"><a class="reference internal" href="#structs">Structs</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#mapping-types">Mapping Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#operators-involving-lvalues">Operators Involving LValues</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#delete">delete</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#conversions-between-elementary-types">Conversions between Elementary Types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#implicit-conversions">Implicit Conversions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#explicit-conversions">Explicit Conversions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#conversions-between-literals-and-elementary-types">Conversions between Literals and Elementary Types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#integer-types">Integer Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id19">Fixed-Size Byte Arrays</a></li>
<li class="toctree-l4"><a class="reference internal" href="#addresses">Addresses</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="units-and-global-variables.html">Units and Globally Available Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="control-structures.html">Expressions and Control Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="contracts.html">Contracts</a></li>
<li class="toctree-l2"><a class="reference internal" href="assembly.html">Solidity Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html">Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="050-breaking-changes.html">Solidity v0.5.0 Breaking Changes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="security-considerations.html">Security Considerations</a></li>
<li class="toctree-l1"><a class="reference internal" href="resources.html">Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="using-the-compiler.html">Using the compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="metadata.html">Contract Metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="abi-spec.html">Basic Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="abi-spec.html#function-selector">Function selector</a></li>
<li class="toctree-l1"><a class="reference internal" href="abi-spec.html#argument-encoding">Argument Encoding</a></li>
<li class="toctree-l1"><a class="reference internal" href="abi-spec.html#types">Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="abi-spec.html#design-criteria-for-the-encoding">Design Criteria for the Encoding</a></li>
<li class="toctree-l1"><a class="reference internal" href="abi-spec.html#formal-specification-of-the-encoding">Formal Specification of the Encoding</a></li>
<li class="toctree-l1"><a class="reference internal" href="abi-spec.html#function-selector-and-argument-encoding">Function Selector and Argument Encoding</a></li>
<li class="toctree-l1"><a class="reference internal" href="abi-spec.html#examples">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="abi-spec.html#use-of-dynamic-types">Use of Dynamic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="abi-spec.html#events">Events</a></li>
<li class="toctree-l1"><a class="reference internal" href="abi-spec.html#json">JSON</a></li>
<li class="toctree-l1"><a class="reference internal" href="abi-spec.html#strict-encoding-mode">Strict Encoding Mode</a></li>
<li class="toctree-l1"><a class="reference internal" href="abi-spec.html#non-standard-packed-mode">Non-standard Packed Mode</a></li>
<li class="toctree-l1"><a class="reference internal" href="yul.html">Yul</a></li>
<li class="toctree-l1"><a class="reference internal" href="style-guide.html">Style Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="common-patterns.html">Common Patterns</a></li>
<li class="toctree-l1"><a class="reference internal" href="bugs.html">List of Known Bugs</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="frequently-asked-questions.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="lll.html">LLL</a></li>
</ul>

            
          
    <a href="genindex.html">Keyword Index</a>
  
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Solidity</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="solidity-in-depth.html">Solidity in Depth</a> &raquo;</li>
        
      <li>Types</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/types.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="types">
<span id="index-0"></span><span id="id1"></span><h1>Types<a class="headerlink" href="#types" title="Permalink to this headline">¶</a></h1>
<p>Solidityは静的タイプの言語です。つまり各状態変数やローカルな変数のタイプは指定される必要があります。
Solidityはいくつかの基本的なタイプを持ち、それらは結びつき複雑なタイプを構成することができます。</p>
<p>加えて、オペレータを含む表現でタイプは互いに干渉することができます。変数のオペレータのクイックリファレンスは <a class="reference internal" href="miscellaneous.html#order"><span class="std std-ref">Order of Precedence of Operators</span></a> を参照ください。</p>
<div class="section" id="value-types">
<span id="index-1"></span><span id="id2"></span><h2>Value Types<a class="headerlink" href="#value-types" title="Permalink to this headline">¶</a></h2>
<p>次の型も常に値として渡されるため値型と呼ばれています。引数や割り当て時にはこれらは常にコピーされます。</p>
<div class="section" id="booleans">
<span id="index-2"></span><h3>Booleans<a class="headerlink" href="#booleans" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">bool</span></code>: 取りうる値は <code class="docutils literal notranslate"><span class="pre">true</span></code> と <code class="docutils literal notranslate"><span class="pre">false</span></code></p>
<p>Operators:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">!</span></code> (論理否定)</li>
<li><code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> (論理積, “and”)</li>
<li><code class="docutils literal notranslate"><span class="pre">||</span></code> (論理和, “or”)</li>
<li><code class="docutils literal notranslate"><span class="pre">==</span></code> (等価)</li>
<li><code class="docutils literal notranslate"><span class="pre">!=</span></code> (不等価)</li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">||</span></code> と <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> 演算子は一般的な短絡評価のルールに従います。つまり、<code class="docutils literal notranslate"><span class="pre">f(x)</span> <span class="pre">||</span> <span class="pre">g(y)</span></code> という表現において、もし <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> が``true`` と評価された場合、たとえ副次的な作用があったとしても <code class="docutils literal notranslate"><span class="pre">g(y)</span></code> は評価されません。</p>
</div>
<div class="section" id="integers">
<span id="index-3"></span><h3>Integers<a class="headerlink" href="#integers" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">int</span></code> / <code class="docutils literal notranslate"><span class="pre">uint</span></code>: 色々なサイズの符号付と符号なし整数です。<code class="docutils literal notranslate"><span class="pre">uint8</span></code> から <code class="docutils literal notranslate"><span class="pre">uint256</span></code> まで8ずつ（符号なしの8から256ビットまで）と``int8`` から <code class="docutils literal notranslate"><span class="pre">int256</span></code> まで上がっていきます。<code class="docutils literal notranslate"><span class="pre">uint</span></code> と <code class="docutils literal notranslate"><span class="pre">int</span></code> はそれぞれ <code class="docutils literal notranslate"><span class="pre">uint256</span></code> と <code class="docutils literal notranslate"><span class="pre">int256</span></code> のエイリアスです。</p>
<p>Operators:</p>
<ul class="simple">
<li>比較: <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> (<code class="docutils literal notranslate"><span class="pre">bool</span></code> で評価)</li>
<li>ビット演算子: <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code> (ビット排他論理和), <code class="docutils literal notranslate"><span class="pre">~</span></code> (ビット否定)</li>
<li>シフト演算子: <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> (左シフト), <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> (右シフト)</li>
<li>算術演算子: <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, unary <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code> (modulo), <code class="docutils literal notranslate"><span class="pre">**</span></code> (累乗)</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Solidityの整数はある範囲に制限されています。例えば、<code class="docutils literal notranslate"><span class="pre">uint32</span></code> であれば <code class="docutils literal notranslate"><span class="pre">0</span></code> から最大 <code class="docutils literal notranslate"><span class="pre">2**32</span> <span class="pre">-</span> <span class="pre">1</span></code> までです。
もし計算結果がこの範囲に収まらない場合には、切り捨てられます。この切り捨てによって起こる結果は <a class="reference internal" href="security-considerations.html#underflow-overflow"><span class="std std-ref">be 知っておくべきです</span></a> 。</p>
</div>
<div class="section" id="comparisons">
<h4>Comparisons<a class="headerlink" href="#comparisons" title="Permalink to this headline">¶</a></h4>
<p>比較の値は整数値を比較することによって得られます。</p>
</div>
<div class="section" id="bit-operations">
<h4>Bit operations<a class="headerlink" href="#bit-operations" title="Permalink to this headline">¶</a></h4>
<p>ビット演算子の計算は2の補数表現で行われます。例えば、 <code class="docutils literal notranslate"><span class="pre">~int256(0)</span> <span class="pre">==</span> <span class="pre">int256(-1)</span></code> です。</p>
</div>
<div class="section" id="shifts">
<h4>Shifts<a class="headerlink" href="#shifts" title="Permalink to this headline">¶</a></h4>
<p>シフト演算の結果は左オペランドの型となります。<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;&lt;</span> <span class="pre">y</span></code> という表現は <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">2**y</span></code> と等価です。さらに正の整数に関しては <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;&gt;</span> <span class="pre">y</span></code> と <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">2**y</span></code> が等価です。負の <code class="docutils literal notranslate"><span class="pre">x</span></code> に対して <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;&gt;</span> <span class="pre">y</span></code> は、<code class="docutils literal notranslate"><span class="pre">2</span></code> のべき乗で除し、切り捨てしたもの（負の無限大で）と等価です。
負の数でシフトするとランタイム例外が投げられます。</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">バージョン``0.5.0``の前までは、負の <code class="docutils literal notranslate"><span class="pre">x</span></code> に対して右シフト <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;&gt;</span> <span class="pre">y</span></code> は <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">2**y</span></code> と等価でした。例えば右シフトは負の無限大での切り捨ての代わりに、0の位での切り捨てを行なっていました。</p>
</div>
</div>
<div class="section" id="addition-subtraction-and-multiplication">
<h4>Addition, Subtraction and Multiplication<a class="headerlink" href="#addition-subtraction-and-multiplication" title="Permalink to this headline">¶</a></h4>
<p>加算、減算、乗算は通常のセマンティクスです。
これらは2の補数表現で使用されます。つまり、例えば <code class="docutils literal notranslate"><span class="pre">uint256(0)</span> <span class="pre">-</span> <span class="pre">uint256(1)</span> <span class="pre">==</span> <span class="pre">2**256</span> <span class="pre">-</span> <span class="pre">1</span></code> です。安全なスマートコントラクトを作成するときには、このオーバーフローを考慮する必要があります。</p>
<p><code class="docutils literal notranslate"><span class="pre">T</span></code> が <code class="docutils literal notranslate"><span class="pre">x</span></code> の型であるとき <code class="docutils literal notranslate"><span class="pre">-x</span></code> という表現は <code class="docutils literal notranslate"><span class="pre">(T(0)</span> <span class="pre">-</span> <span class="pre">x)</span></code> と等価です。つまり、<code class="docutils literal notranslate"><span class="pre">x</span></code> の型が符号なし整数のときに <code class="docutils literal notranslate"><span class="pre">-x</span></code> は負の数にはなりません。また、<code class="docutils literal notranslate"><span class="pre">x</span></code> が負の数であれば <code class="docutils literal notranslate"><span class="pre">-x</span></code> は正の数になりえます。さらに、別の2の補数表現による注意があります:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">**</span><span class="mi">255</span><span class="p">;</span>
<span class="nf">assert</span><span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="o">==</span> <span class="n">x</span><span class="p">);</span>
</pre></div>
</div>
<p>これが意味するのは、たとえある数字が負の数でも、それにマイナスをつけたものが正の数になるとは限らないということです。</p>
</div>
<div class="section" id="division">
<h4>Division<a class="headerlink" href="#division" title="Permalink to this headline">¶</a></h4>
<p>ある演算の出力の型は常に演算対象の型と同じなので、整数の除算の結果は整数になります。Solidityでは、除算は1の位までの概算になります。つまり、<code class="docutils literal notranslate"><span class="pre">int256(-5)</span> <span class="pre">/</span> <span class="pre">int256(2)</span> <span class="pre">==</span> <span class="pre">int256(-2)</span></code> となります。</p>
<p>一方で、<a class="reference internal" href="#rational-literals"><span class="std std-ref">リテラル</span></a> での除算は任意の精度での少数値が結果として出力されるということに注意して下さい。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">ゼロでの除算はフェイルアサーションが発生します。</p>
</div>
</div>
<div class="section" id="modulo">
<h4>Modulo<a class="headerlink" href="#modulo" title="Permalink to this headline">¶</a></h4>
<p>剰余演算 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">%</span> <span class="pre">n</span></code> は <code class="docutils literal notranslate"><span class="pre">a</span></code> を <code class="docutils literal notranslate"><span class="pre">n</span></code> で割ったときの 余り <code class="docutils literal notranslate"><span class="pre">r</span></code> を結果として返します（<code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">=</span> <span class="pre">int(a</span> <span class="pre">/</span> <span class="pre">n)</span></code> で <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">-</span> <span class="pre">(n</span> <span class="pre">*</span> <span class="pre">q)</span></code> です）。つまり、剰余演算の答えは左オペランドと同じ符号（もしくはゼロ）で、負の数 <code class="docutils literal notranslate"><span class="pre">a</span></code> に対して <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">%</span> <span class="pre">n</span> <span class="pre">==</span> <span class="pre">-(abs(a)</span> <span class="pre">%</span> <span class="pre">n)</span></code> となります:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">int256(5)</span> <span class="pre">%</span> <span class="pre">int256(2)</span> <span class="pre">==</span> <span class="pre">int256(1)</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">int256(5)</span> <span class="pre">%</span> <span class="pre">int256(-2)</span> <span class="pre">==</span> <span class="pre">int256(1)</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">int256(-5)</span> <span class="pre">%</span> <span class="pre">int256(2)</span> <span class="pre">==</span> <span class="pre">int256(-1)</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">int256(-5)</span> <span class="pre">%</span> <span class="pre">int256(-2)</span> <span class="pre">==</span> <span class="pre">int256(-1)</span></code></li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">0での剰余演算はフェイルアサーションが発生します。</p>
</div>
</div>
<div class="section" id="exponentiation">
<h4>Exponentiation<a class="headerlink" href="#exponentiation" title="Permalink to this headline">¶</a></h4>
<p>指数演算は符号なしの型でのみ使用可能です。使っている型が指数演算の結果を包括するのに、また将来的に起こりうるラッピングに対して十分な大きさであることを確認してください。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">EVMでは <code class="docutils literal notranslate"><span class="pre">0**0</span></code> は <code class="docutils literal notranslate"><span class="pre">1</span></code> と定義されています。</p>
</div>
</div>
</div>
<div class="section" id="fixed-point-numbers">
<span id="index-4"></span><h3>Fixed Point Numbers<a class="headerlink" href="#fixed-point-numbers" title="Permalink to this headline">¶</a></h3>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">固定小数点はまだSolidityでは完全にサポートされていません。宣言はできますが、値を割り当てたりはできません。</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">fixed</span></code> / <code class="docutils literal notranslate"><span class="pre">ufixed</span></code>: いくつかのサイズがある符号付、符号なし固定小数点です。<code class="docutils literal notranslate"><span class="pre">ufixedMxN</span></code> と <code class="docutils literal notranslate"><span class="pre">fixedMxN</span></code> で <code class="docutils literal notranslate"><span class="pre">M</span></code> はその型で取れるビットの数で、<code class="docutils literal notranslate"><span class="pre">N</span></code> は、何桁の10進数少数点が取れるかを表しています。<code class="docutils literal notranslate"><span class="pre">M</span></code> は8で割り切れる数で、8から256ビットまでとれます。<code class="docutils literal notranslate"><span class="pre">N</span></code> は0から80までとることができます。<code class="docutils literal notranslate"><span class="pre">ufixed</span></code> と <code class="docutils literal notranslate"><span class="pre">fixed</span></code> はそれぞれ <code class="docutils literal notranslate"><span class="pre">ufixed128x18</span></code> と <code class="docutils literal notranslate"><span class="pre">fixed128x18</span></code> のエイリアスです。</p>
<p>Operators:</p>
<ul class="simple">
<li>Comparisons: <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> (evaluate to <code class="docutils literal notranslate"><span class="pre">bool</span></code>)</li>
<li>Arithmetic operators: <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, unary <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code> (modulo)</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">浮動小数と固定小数の主な違いですが、前者では整数部分と小数部分（多くの言語では <code class="docutils literal notranslate"><span class="pre">float</span></code> と <code class="docutils literal notranslate"><span class="pre">double</span></code> です。より詳細な情報はIEEE 754で確認してください）の桁数がフレキシブルで、後者では厳密に決められていることです。一般的に、浮動小数点数はほぼ全てのスペースをその数を表すのに使用し、少しのビットで小数点の長さを表します。</p>
</div>
</div>
<div class="section" id="address">
<span id="index-5"></span><span id="id3"></span><h3>Address<a class="headerlink" href="#address" title="Permalink to this headline">¶</a></h3>
<p>アドレス型は広義的には同じである2つの種類があります:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">address</span></code>: 20バイトの値 (Ethereumアドレスの大きさ)です。</li>
<li><code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code>: <code class="docutils literal notranslate"><span class="pre">address</span></code> と同じですが、追加のメンバ <code class="docutils literal notranslate"><span class="pre">transfer</span></code> と <code class="docutils literal notranslate"><span class="pre">send</span></code> が使えます。</li>
</ul>
</div></blockquote>
<p>この特徴が意味するのは、<code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> にはEtherを送ることができますが、ただの <code class="docutils literal notranslate"><span class="pre">address</span></code> にはできません。</p>
<p>Type conversions:</p>
<p><code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> から <code class="docutils literal notranslate"><span class="pre">address</span></code> への暗黙的な変換は可能ですが、<code class="docutils literal notranslate"><span class="pre">address</span></code> から <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> にはできません（唯一 <code class="docutils literal notranslate"><span class="pre">uint160</span></code> を中継することで変換可能です）。</p>
<p><a class="reference internal" href="#address-literals"><span class="std std-ref">アドレスリテラル</span></a> は暗黙的に <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> に変換可能です。</p>
<p><code class="docutils literal notranslate"><span class="pre">address</span></code> への、もしくは <code class="docutils literal notranslate"><span class="pre">address</span></code> からの明示的な変換は整数、整数リテラル、<code class="docutils literal notranslate"><span class="pre">bytes20</span></code>、コントラクト型で可能ですが下記の注意事項を参照ください:
<code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable(x)</span></code> という形での変換はできません。代わりに、<code class="docutils literal notranslate"><span class="pre">address(x)</span></code> という変換結果が <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> もしくは、もし <code class="docutils literal notranslate"><span class="pre">x</span></code> が整数もしくは固定サイズのバイト型であれば、リテラルかpayableのフォールバックファンクションを持つコントラクトになります。
もし <code class="docutils literal notranslate"><span class="pre">x</span></code> がpayableのフォールバックファンクションを持たないコントラクトであれば、<code class="docutils literal notranslate"><span class="pre">address(x)</span></code> は <code class="docutils literal notranslate"><span class="pre">address</span></code> になります。
外部のファンクションの署名では、<code class="docutils literal notranslate"><span class="pre">address</span></code> は <code class="docutils literal notranslate"><span class="pre">address</span></code> 型、<code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> 型両方で使用されます。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">おそらく、<code class="docutils literal notranslate"><span class="pre">address</span></code> と <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> の違いを気にする必要はあまりなく、どこでも <code class="docutils literal notranslate"><span class="pre">address</span></code> を使うことになるでしょう。例えば、もし、<a class="reference internal" href="common-patterns.html#withdrawal-pattern"><span class="std std-ref">withdrawal pattern</span></a> を使うと、<code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> である <code class="docutils literal notranslate"><span class="pre">msg.sender</span></code> で <code class="docutils literal notranslate"><span class="pre">transfer</span></code> を使うので、<code class="docutils literal notranslate"><span class="pre">address</span></code> としてアドレスを保存できます（するべきです）。</p>
</div>
<p>Operators:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> and <code class="docutils literal notranslate"><span class="pre">&gt;</span></code></li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>もし <code class="docutils literal notranslate"><span class="pre">address</span></code> 型よりも大きなサイズの型、例えば、<code class="docutils literal notranslate"><span class="pre">bytes32</span></code>、から変換しようとすると、<code class="docutils literal notranslate"><span class="pre">address</span></code> は切り詰められます。
変換時の曖昧さを減らすためにバージョン0.4.24からは変換時にコンパイラは切り捨てを明示的にすることを要求します。例えば、<code class="docutils literal notranslate"><span class="pre">0x111122223333444455556666777788889999AAAABBBBCCCCDDDDEEEEFFFFCCCC</span></code> です。</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">0x111122223333444455556666777788889999aAaa</span></code> となる <code class="docutils literal notranslate"><span class="pre">address(uint160(bytes20(b)))</span></code> もしくは、<code class="docutils literal notranslate"><span class="pre">0x777788889999AaAAbBbbCcccddDdeeeEfFFfCcCc</span></code> となる <code class="docutils literal notranslate"><span class="pre">address(uint160(uint256(b)))</span></code> が使えます。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">address</span></code> と <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> の違いはバージョン0.5.0で導入されました。
また、コントラクトはアドレス型からは生成されませんが、もしpayableのフォールバックファンクションを持っていれば、<code class="docutils literal notranslate"><span class="pre">address</span></code> もしくは <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> に明示的に変換できるという機能がバージョン0.5.0から導入されました。</p>
</div>
<div class="section" id="members-of-addresses">
<span id="id4"></span><h4>Members of Addresses<a class="headerlink" href="#members-of-addresses" title="Permalink to this headline">¶</a></h4>
<p>アドレス型の全てのメンバのクイックリファレンスは  <a class="reference internal" href="units-and-global-variables.html#address-related"><span class="std std-ref">Members of Address Types</span></a> を参照ください。</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">balance</span></code> and <code class="docutils literal notranslate"><span class="pre">transfer</span></code></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">balance</span></code> プロパティであるアドレスのバランスを確認できます。また、<code class="docutils literal notranslate"><span class="pre">transfer</span></code> でpayableなアドレスにEther（単位はwei）を送ることができます:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">address</span> <span class="kr">payable</span> <span class="n">x</span> <span class="o">=</span> <span class="kt">address</span><span class="p">(</span><span class="mh">0x123</span><span class="p">);</span>
<span class="kt">address</span> <span class="n">myAddress</span> <span class="o">=</span> <span class="kt">address</span><span class="p">(</span><span class="nb">this</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="nb">balance</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">myAddress</span><span class="p">.</span><span class="nb">balance</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">)</span> <span class="n">x</span><span class="p">.</span><span class="nf">transfer</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</pre></div>
</div>
<p>現在のコントラクトのバランスが十分大きくないか、受け取り側のアカウントでEtherの送金が拒否された場合、<a href="#id5"><span class="problematic" id="id6">``</span></a>transfer``ファンクションは失敗し、送金前の状態に戻ります。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">もし <code class="docutils literal notranslate"><span class="pre">x</span></code> がコントラクトアドレスだった場合、そのコード（具体的には、もしあれば <a class="reference internal" href="contracts.html#fallback-function"><span class="std std-ref">Fallback Function</span></a>）は <code class="docutils literal notranslate"><span class="pre">transfer</span></code> と一緒に実行されます（これはEVMの特徴で、止めることはできません）。もしこの実行時にガス不足になったり、他の理由でフェイルした場合は、Etherの送金はキャンセル、元の状態に戻り、現在のコントラクトは例外と共にストップします。</p>
</div>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">send</span></code></li>
</ul>
<p>Sendは <code class="docutils literal notranslate"><span class="pre">transfer</span></code> の低レベルバージョンです。もし実行が失敗したら、現在のコントラクトは例外と共にストップしない代わりに、<code class="docutils literal notranslate"><span class="pre">send</span></code> が <code class="docutils literal notranslate"><span class="pre">false</span></code> を返します。</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">send</span></code> を使うといくつかの危険が伴います:
送金はコールスタックの深さが1024でフェイルします（これは常に呼び出し元によって行われます）。そして、もし受領者がガスを使い切ってもフェイルします。そのため、安全なEtherの送金のために、常に <code class="docutils literal notranslate"><span class="pre">send</span></code> の返り値を確認する、もしくは <code class="docutils literal notranslate"><span class="pre">transfer</span></code> を使ってください。さらに良いのは:
受領者がお金を引き出す時の様式を使用することです。</p>
</div>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">call</span></code>, <code class="docutils literal notranslate"><span class="pre">delegatecall</span></code> and <code class="docutils literal notranslate"><span class="pre">staticcall</span></code></li>
</ul>
<p>ABIに従わないコントラクトと繋げるために、もしくはエンコードに対してもっと直接的なコントロールを得るために、<code class="docutils literal notranslate"><span class="pre">call</span></code>、<code class="docutils literal notranslate"><span class="pre">delegatecall</span></code>、<code class="docutils literal notranslate"><span class="pre">staticcall</span></code> ファンクションを使うことができます。
これらは全て一つの <code class="docutils literal notranslate"><span class="pre">bytes</span> <span class="pre">memory</span></code> パラメータを引数とし、（<code class="docutils literal notranslate"><span class="pre">bool</span></code> で）成否と <code class="docutils literal notranslate"><span class="pre">bytes</span> <span class="pre">memory</span></code> の返ってきたデータを返します。
<code class="docutils literal notranslate"><span class="pre">abi.encode</span></code>、<code class="docutils literal notranslate"><span class="pre">abi.encodePacked</span></code>、<code class="docutils literal notranslate"><span class="pre">abi.encodeWithSelector</span></code>、<code class="docutils literal notranslate"><span class="pre">abi.encodeWithSignature</span></code> は体系的なデータをエンコードするために使用することができます。</p>
<p>Example:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">bytes</span> <span class="kr">memory</span> <span class="n">payload</span> <span class="o">=</span> <span class="nb">abi.encodeWithSignature</span><span class="p">(</span><span class="s">&quot;register(string)&quot;</span><span class="p">,</span> <span class="s">&quot;MyName&quot;</span><span class="p">);</span>
<span class="p">(</span><span class="kt">bool</span> <span class="n">success</span><span class="p">,</span> <span class="kt">bytes</span> <span class="kr">memory</span> <span class="n">returnData</span><span class="p">)</span> <span class="o">=</span> <span class="kt">address</span><span class="p">(</span><span class="n">nameReg</span><span class="p">).</span><span class="nf">call</span><span class="p">(</span><span class="n">payload</span><span class="p">);</span>
<span class="nf">require</span><span class="p">(</span><span class="n">success</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">これら全てのファンクションは低級のファンクションで、使う際には注意が必要です。特に、未知のコントラクトは悪意を持っている可能性があり、もしそのコントラクトを呼び出すと、あなたのコントラクトに次々とコールバックを投げるコントラクトにコントロールを渡してしまうかもしれません。そのため、その呼び出しが返ってきたときに、状態変数の変化に対して準備をしておいてください。他のコントラクトと繋がる一般的な方法はコントラクトオブジェクト(<code class="docutils literal notranslate"><span class="pre">x.f()</span></code>)上でファンクションを呼び出すことです。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">以前のバージョンではこれらのファンクションで任意の引数を取ることができ、<code class="docutils literal notranslate"><span class="pre">bytes4</span></code> 型の第一引数を異なる方法で処理することができました。そのようなエッジケースはバージョン0.5.0で削除されました。</p>
</div>
<p>供給されたガスを <code class="docutils literal notranslate"><span class="pre">.gas()</span></code> modifierで調整することができます:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">address</span><span class="p">(</span><span class="n">nameReg</span><span class="p">).</span><span class="nf">call</span><span class="p">.</span><span class="n">gas</span><span class="p">(</span><span class="mi">1000000</span><span class="p">)(</span><span class="nb">abi.encodeWithSignature</span><span class="p">(</span><span class="s">&quot;register(string)&quot;</span><span class="p">,</span> <span class="s">&quot;MyName&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>同様に、供給されたEtherの値もコントロールすることができます:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">address</span><span class="p">(</span><span class="n">nameReg</span><span class="p">).</span><span class="nf">call</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="mi">1</span> <span class="kc">ether</span><span class="p">)(</span><span class="nb">abi.encodeWithSignature</span><span class="p">(</span><span class="s">&quot;register(string)&quot;</span><span class="p">,</span> <span class="s">&quot;MyName&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>最後に、これらのmodifierは結合させることができます。順番は関係ありません:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">address</span><span class="p">(</span><span class="n">nameReg</span><span class="p">).</span><span class="nf">call</span><span class="p">.</span><span class="n">gas</span><span class="p">(</span><span class="mi">1000000</span><span class="p">).</span><span class="n">value</span><span class="p">(</span><span class="mi">1</span> <span class="kc">ether</span><span class="p">)(</span><span class="nb">abi.encodeWithSignature</span><span class="p">(</span><span class="s">&quot;register(string)&quot;</span><span class="p">,</span> <span class="s">&quot;MyName&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>似たような方法で、<code class="docutils literal notranslate"><span class="pre">delegatecall</span></code> は使用されます: 違いは与えられたアドレスのコードだけ使われ、他の要素（storage、balance等）は現在のコントラクトから使われます。<code class="docutils literal notranslate"><span class="pre">delegatecall</span></code> の目的は別のコントラクトに保存されているライブラリを使用することです。ユーザはstorageの構造がどちらのコントラクトでもdelegatecallを使用するのに適切であることを確認しなければいけません。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">homestead以前は、<code class="docutils literal notranslate"><span class="pre">callcode</span></code> という制限のある変形型のみが使用可能でしたが、オリジナルの <code class="docutils literal notranslate"><span class="pre">msg.sender</span></code> と <code class="docutils literal notranslate"><span class="pre">msg.value</span></code> にアクセス不可でした。このファンクションはバージョン0.5.0で削除されました。</p>
</div>
<p>Byzantiumから <code class="docutils literal notranslate"><span class="pre">staticcall</span></code> も使うことができます。基本的には <code class="docutils literal notranslate"><span class="pre">call</span></code> と同じですが、もし呼ばれたファンクションがステートを変更したらリバートします。</p>
<p><code class="docutils literal notranslate"><span class="pre">call</span></code>、<code class="docutils literal notranslate"><span class="pre">delegatecall</span></code>、<code class="docutils literal notranslate"><span class="pre">staticcall</span></code> の3つのファンクションは全てとても低級のファンクションで、Solidityの型安全性を破るため、<em>最終手段</em> として使用してください。</p>
<p><code class="docutils literal notranslate"><span class="pre">.gas()</span></code> オプションは全てのメソッドで使用可能ですが、<code class="docutils literal notranslate"><span class="pre">.value()</span></code> は <code class="docutils literal notranslate"><span class="pre">delegatecall</span></code> ではサポートされません。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">全てのコントラクトは <code class="docutils literal notranslate"><span class="pre">address</span></code> に変換できるため、<code class="docutils literal notranslate"><span class="pre">address(this).balance</span></code> で現在のコントラクトにそのバランスをクエリすることができます。</p>
</div>
</div>
</div>
<div class="section" id="contract-types">
<span id="index-6"></span><span id="id7"></span><h3>Contract Types<a class="headerlink" href="#contract-types" title="Permalink to this headline">¶</a></h3>
<p>全ての <a class="reference internal" href="contracts.html#contracts"><span class="std std-ref">contract</span></a> は自分自身の型を定義します。
あるコントラクトからそのコントラクトが継承しているコントラクトへ暗黙的に変換することができます。
コントラクトは他のコントラクト型から、もしくは他のコントラクト型へ明示的に変換することができます。さらに <code class="docutils literal notranslate"><span class="pre">address</span></code> 型への変換も可能です。</p>
<p>コントラクト型がpayableのフォールバックファンクションを持っている時のみ、<code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> 型から、もしくは <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> 型への明示的な変換が可能です。
その変換は <code class="docutils literal notranslate"><span class="pre">address(x)</span></code> では行われますが、<code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable(x)</span></code> では行われません。詳細な情報は　<a class="reference internal" href="#address"><span class="std std-ref">address type</span></a> を参照ください。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">バージョン0.5.0以前では、コントラクトは直接アドレス型から得られており、<code class="docutils literal notranslate"><span class="pre">address</span></code> と <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> に違いはありませんでした。</p>
</div>
<p>もしコントラクト型（<cite>MyContract c</cite>）のローカル変数を宣言した場合、そのコントラクト上でファンクションを呼び出すことができます。同じコントラクト型からその変数を割り当てる様にして下さい。</p>
<p>コントラクトのインスタンスも作成可能です（つまり新しくそのコントラクトが作られるということです）。詳細は <a class="reference internal" href="control-structures.html#creating-contracts"><span class="std std-ref">‘Contracts via new’</span></a> を参照ください。</p>
<p>コントラクトのデータ表現は <code class="docutils literal notranslate"><span class="pre">address</span></code> 型のデータ表現と同じで、この型は <a class="reference internal" href="abi-spec.html#abi"><span class="std std-ref">ABI</span></a> でも使われています。</p>
<p>コントラクト型はどんな演算子もサポートしません。</p>
<p>コントラクト型のメンバはpublicの状態変数を含んだそのコントラクトのexternalのファンクションです。</p>
<p>あるコントラクト <code class="docutils literal notranslate"><span class="pre">C</span></code> に対して、そのコントラクトの <a class="reference internal" href="units-and-global-variables.html#meta-type"><span class="std std-ref">type information</span></a> にアクセスするために <code class="docutils literal notranslate"><span class="pre">type(C)</span></code> を使うことができます。</p>
</div>
<div class="section" id="fixed-size-byte-arrays">
<span id="index-7"></span><h3>Fixed-size byte arrays<a class="headerlink" href="#fixed-size-byte-arrays" title="Permalink to this headline">¶</a></h3>
<p>値型である <code class="docutils literal notranslate"><span class="pre">bytes1</span></code>、<code class="docutils literal notranslate"><span class="pre">bytes2</span></code>、<code class="docutils literal notranslate"><span class="pre">bytes3</span></code> … <code class="docutils literal notranslate"><span class="pre">bytes32</span></code> は1から32までバイト列を保持しています。
<code class="docutils literal notranslate"><span class="pre">byte</span></code> は <code class="docutils literal notranslate"><span class="pre">byte1</span></code> のエイリアスです。</p>
<p>Operators:</p>
<ul class="simple">
<li>Comparisons: <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> (<code class="docutils literal notranslate"><span class="pre">bool</span></code> を返します)</li>
<li>Bit operators: <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code> (bitwise exclusive or), <code class="docutils literal notranslate"><span class="pre">~</span></code> (bitwise negation)</li>
<li>Shift operators: <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> (left shift), <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> (right shift)</li>
<li>Index access: If <code class="docutils literal notranslate"><span class="pre">x</span></code> is of type <code class="docutils literal notranslate"><span class="pre">bytesI</span></code>, then <code class="docutils literal notranslate"><span class="pre">x[k]</span></code> for <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">I</span></code> returns the <code class="docutils literal notranslate"><span class="pre">k</span></code> th byte (read-only).</li>
<li>比較: <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> (<code class="docutils literal notranslate"><span class="pre">bool</span></code> で評価)</li>
<li>ビット演算子: <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code> (ビット排他論理和), <code class="docutils literal notranslate"><span class="pre">~</span></code> (ビット否定)</li>
<li>シフト演算子: <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> (左シフト), <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> (右シフト)</li>
<li>インデックスアクセス: もし <code class="docutils literal notranslate"><span class="pre">x</span></code> が <code class="docutils literal notranslate"><span class="pre">bytesI</span></code> 型なら <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">I</span></code> の元で <code class="docutils literal notranslate"><span class="pre">x[k]</span></code> は <code class="docutils literal notranslate"><span class="pre">k</span></code> 番目のバイトを返します（読み取り専用）。</li>
</ul>
<p>どれだけのビット数をシフトさせるか決める右オペランドがどの整数型でもシフト演算子は動作します（結果は左オペランドの型で返ります）。
負の数でのシフトはランタイムの例外を生成します。</p>
<p>Members:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">.length</span></code> は固定長さのバイト配列を返します（読み取り専用）。</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">byte[]</span></code> はバイトの配列ですがパディングのため、各要素の間の31バイトを無駄にしています（storage以外）。代わりに、<code class="docutils literal notranslate"><span class="pre">bytes</span></code> を使用する方が良いでしょう。</p>
</div>
</div>
<div class="section" id="dynamically-sized-byte-array">
<h3>Dynamically-sized byte array<a class="headerlink" href="#dynamically-sized-byte-array" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">bytes</span></code>:</dt>
<dd>動的サイズのバイト配列です。<a class="reference internal" href="#arrays"><span class="std std-ref">Arrays</span></a> を参照ください。値型ではありません。</dd>
<dt><code class="docutils literal notranslate"><span class="pre">string</span></code>:</dt>
<dd>動的サイズのUTF-8でエンコードされた文字列です。<a class="reference internal" href="#arrays"><span class="std std-ref">Arrays</span></a> を参照ください。値型ではありません。</dd>
</dl>
</div>
<div class="section" id="address-literals">
<span id="index-8"></span><span id="id8"></span><h3>Address Literals<a class="headerlink" href="#address-literals" title="Permalink to this headline">¶</a></h3>
<p>アドレスのチェックサムをパスする16進数のリテラル、例えば <code class="docutils literal notranslate"><span class="pre">0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF</span></code> は <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> 型です。
39から41文字で、チェックサムにパスしない16進数リテラルは警告を発し、通常の有理数リテラルとして扱われます。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The mixed-case address checksum format is defined in <a class="reference external" href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md">EIP-55</a>.</p>
</div>
</div>
<div class="section" id="rational-and-integer-literals">
<span id="rational-literals"></span><span id="index-9"></span><h3>Rational and Integer Literals<a class="headerlink" href="#rational-and-integer-literals" title="Permalink to this headline">¶</a></h3>
<p>整数リテラルは0から9までの数字から形成され、10進数として認識されます。例えば、<code class="docutils literal notranslate"><span class="pre">69</span></code> は六十九のことです。</p>
<p>10進数の小数リテラルは <code class="docutils literal notranslate"><span class="pre">.</span></code> を使って形成され、少なくとも1文字片側に数字があります。例えば、<code class="docutils literal notranslate"><span class="pre">1.</span></code>、<code class="docutils literal notranslate"><span class="pre">.1</span></code>、<code class="docutils literal notranslate"><span class="pre">1.3</span></code> です。</p>
<p>指数表記もサポートされています。基数は小数を取れますが、指数はできません。
例えば、<code class="docutils literal notranslate"><span class="pre">2e10</span></code>、<code class="docutils literal notranslate"><span class="pre">-2e10</span></code>、<code class="docutils literal notranslate"><span class="pre">2e-10</span></code>、<a href="#id9"><span class="problematic" id="id10">``</span></a>2.5e1``です。</p>
<p>アンダースコアは数字リテラルの読みやすさを改善するために数字を分けるのに使用することができます。
例えば、10進数 <code class="docutils literal notranslate"><span class="pre">123_000</span></code>、16進数の <code class="docutils literal notranslate"><span class="pre">0x2eff_abde</span></code>、10進数の指数表記 <code class="docutils literal notranslate"><span class="pre">1_2e345_678</span></code> は全て有効です。
アンダースコアは2つの数字の間でのみ有効で、1つのアンダースコアしか使うことができません（2つ連続でアンダースコアを使うことはできません）。セマンティクス的な意味は何もありません。アンダースコアを含む数字リテラルでアンダースコアは無視されます。</p>
<p>数字リテラルは非リテラル型に（例えば非リテラル型と一緒に使うか、明示的な変換によって）変換されるまで任意の精度を持ちます。
つまり数字リテラル表現では、計算してもオーバーフローしませんし、除算では切り捨ては起きません。</p>
<p>例えば、中間の計算結果は機械語のサイズに収まっていませんが、<code class="docutils literal notranslate"><span class="pre">(2**800</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">-</span> <span class="pre">2**800</span></code> の結果は（<code class="docutils literal notranslate"><span class="pre">uint8</span></code> 型の）定数 <code class="docutils literal notranslate"><span class="pre">1</span></code> になります。さらに（非整数が使われていますが）``.5 * 8`` の結果は整数 <code class="docutils literal notranslate"><span class="pre">4</span></code> になります。</p>
<p>計算対象が整数で有る限り、整数に使える演算子は全て数字リテラルで使用することができます。
もし片方でも小数を含んでいた場合、ビット演算子は使うことはできません。また、指数部分に小数は使えません（結果が非有理数になる可能性があるため）。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Solidityは各有理数に対して数字リテラル型が使えます。整数リテラルと有理数リテラルは数字リテラル型に属します。
さらに、全ての数字リテラル表現（数字リテラルと演算子のみを含む表現）は数字リテラル型に属します。そのため、数字リテラル表現の <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">2</span></code> と <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">+</span> <span class="pre">1</span></code> の結果である有理数の3は両方とも同じ数字リテラル型に属します。</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">バージョン0.4.0以前では整数リテラルの除算の結果は切り捨てされていましたが、現在は有理数に変換されます。例えば、<code class="docutils literal notranslate"><span class="pre">5</span> <span class="pre">/</span> <span class="pre">2</span></code> は <code class="docutils literal notranslate"><span class="pre">2</span></code> ではなく、<code class="docutils literal notranslate"><span class="pre">2.5</span></code> です。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">数字リテラル表現は非数字リテラル表現が使われたタイミングで非数字リテラル型に変換されます。
型を無視し、下記の <code class="docutils literal notranslate"><span class="pre">b</span></code> に割り当てられている式の値は整数となります。<code class="docutils literal notranslate"><span class="pre">a</span></code> は <code class="docutils literal notranslate"><span class="pre">uint128</span></code> 型であるため、<code class="docutils literal notranslate"><span class="pre">2.5</span> <span class="pre">+</span> <span class="pre">a</span></code> はある適切な型を持っていなければいけませんが、<code class="docutils literal notranslate"><span class="pre">2.5</span></code> の型と <code class="docutils literal notranslate"><span class="pre">uint128</span></code> 型に共通した型が存在しないため、Solidityのコンパイラはこのコードを処理しません。</p>
</div>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">uint128</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">uint128</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">2.5</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="string-literals-and-types">
<span id="string-literals"></span><span id="index-10"></span><h3>String Literals and Types<a class="headerlink" href="#string-literals-and-types" title="Permalink to this headline">¶</a></h3>
<p>文字列リテラルはダブルもしくはシングルクオテーション(<code class="docutils literal notranslate"><span class="pre">&quot;foo&quot;</span></code> もしくは <code class="docutils literal notranslate"><span class="pre">'bar'</span></code>)で記述されます。これらはC言語の様な後置ゼロにはなりません。<code class="docutils literal notranslate"><span class="pre">&quot;foo&quot;</span></code> は3バイトを表します。4バイトではありません。整数リテラルは複数の型をとりうりますが、<code class="docutils literal notranslate"><span class="pre">bytes1</span></code> … <code class="docutils literal notranslate"><span class="pre">bytes32</span></code> に暗黙的に変換可能です。もしサイズが合えば <code class="docutils literal notranslate"><span class="pre">bytes</span></code> と <code class="docutils literal notranslate"><span class="pre">string</span></code> にも変換可能です。</p>
<p>例えば、<code class="docutils literal notranslate"><span class="pre">bytes32</span> <span class="pre">samevar</span> <span class="pre">=</span> <span class="pre">&quot;stringliteral&quot;</span></code> では、文字列リテラルは <code class="docutils literal notranslate"><span class="pre">bytes32</span></code> 型に割り当てられる時に、その生のバイト構造で解釈されます。</p>
<p>文字列リテラルは以下のエスケープキャラクターをサポートします:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">\&lt;newline&gt;</span></code> (escapes an actual newline)</li>
<li><code class="docutils literal notranslate"><span class="pre">\\</span></code> (backslash)</li>
<li><code class="docutils literal notranslate"><span class="pre">\'</span></code> (single quote)</li>
<li><code class="docutils literal notranslate"><span class="pre">\&quot;</span></code> (double quote)</li>
<li><code class="docutils literal notranslate"><span class="pre">\b</span></code> (backspace)</li>
<li><code class="docutils literal notranslate"><span class="pre">\f</span></code> (form feed)</li>
<li><code class="docutils literal notranslate"><span class="pre">\n</span></code> (newline)</li>
<li><code class="docutils literal notranslate"><span class="pre">\r</span></code> (carriage return)</li>
<li><code class="docutils literal notranslate"><span class="pre">\t</span></code> (tab)</li>
<li><code class="docutils literal notranslate"><span class="pre">\v</span></code> (vertical tab)</li>
<li><code class="docutils literal notranslate"><span class="pre">\xNN</span></code> (hex escape, see below)</li>
<li><code class="docutils literal notranslate"><span class="pre">\uNNNN</span></code> (unicode escape, see below)</li>
</ul>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">\xNN</span></code> は16進数をとり、適切なバイトを挿入します。一方で、<code class="docutils literal notranslate"><span class="pre">\uNNNN</span></code> はUnicodeのコードポイントをとり、UTF-8のシーケンスを挿入します。</p>
<p>以下の例の中の文字列は10バイトの長さを持ちます。
新しい行で始まり、ダブルクオート、シングルクオート、バックスラッシュと続き、（区切りなく）``abcdef`` という文字が続きます。</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="s">&quot;</span><span class="se">\n\&quot;\&#39;\\</span><span class="s">abc</span><span class="se">\</span>
<span class="s">def&quot;</span>
</pre></div>
</div>
<p>改行コード(例えばLF、VF、FF、CR、NEL、LS、PS)でないどんなユニコードのラインターミネータは文字列リテラルを終了させると考えられています。もし <code class="docutils literal notranslate"><span class="pre">\</span></code> で処理されていないのであれば、改行は文字列リテラルを終了させるだけです。</p>
</div>
<div class="section" id="hexadecimal-literals">
<span id="index-11"></span><h3>Hexadecimal Literals<a class="headerlink" href="#hexadecimal-literals" title="Permalink to this headline">¶</a></h3>
<p>16進数リテラルは <code class="docutils literal notranslate"><span class="pre">hex</span></code> という接頭辞をつけて、ダブルかシングルクオートで囲まれます（<code class="docutils literal notranslate"><span class="pre">hex&quot;001122FF&quot;</span></code>）。中身は16進数の文字列でなければなりません。そしてその値は2進数表現になります。</p>
<p>16進数リテラルは <a class="reference internal" href="#string-literals"><span class="std std-ref">string literals</span></a> の様に振る舞い、変換に関して同じ制限を持っています。</p>
</div>
<div class="section" id="enums">
<span id="index-12"></span><span id="id11"></span><h3>Enums<a class="headerlink" href="#enums" title="Permalink to this headline">¶</a></h3>
<p>列挙型はSolidityでのユーザー定義型の1つです。明示的に整数型から、もしくは整数型に変換可能ですが、暗黙的には変換できません。整数型からの明示的な変換では実行時にその値が列挙型の範囲内に収まっているかチェックし、範囲外である場合にはフェイルアサーションを起こします。
列挙型は少なくとも1つの要素が必要です。</p>
<p>そのデータ表現はC言語の列挙型と同じです。オプションは <code class="docutils literal notranslate"><span class="pre">0</span></code> で始まる符号なし整数値によって表されます。</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">test</span> <span class="p">{</span>
    <span class="kd">enum</span> <span class="n">ActionChoices</span> <span class="p">{</span> <span class="n">GoLeft</span><span class="p">,</span> <span class="n">GoRight</span><span class="p">,</span> <span class="n">GoStraight</span><span class="p">,</span> <span class="n">SitStill</span> <span class="p">}</span>
    <span class="n">ActionChoices</span> <span class="n">choice</span><span class="p">;</span>
    <span class="n">ActionChoices</span> <span class="kr">constant</span> <span class="n">defaultChoice</span> <span class="o">=</span> <span class="n">ActionChoices</span><span class="p">.</span><span class="n">GoStraight</span><span class="p">;</span>

    <span class="kd">function</span> <span class="n">setGoStraight</span><span class="p">()</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="n">choice</span> <span class="o">=</span> <span class="n">ActionChoices</span><span class="p">.</span><span class="n">GoStraight</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Since enum types are not part of the ABI, the signature of &quot;getChoice&quot;</span>
    <span class="c1">// will automatically be changed to &quot;getChoice() returns (uint8)&quot;</span>
    <span class="c1">// for all matters external to Solidity. The integer type used is just</span>
    <span class="c1">// large enough to hold all enum values, i.e. if you have more than 256 values,</span>
    <span class="c1">// `uint16` will be used and so on.</span>
    <span class="kd">function</span> <span class="n">getChoice</span><span class="p">()</span> <span class="kr">public</span> <span class="kr">view</span> <span class="k">returns</span> <span class="p">(</span><span class="n">ActionChoices</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">choice</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">getDefaultChoice</span><span class="p">()</span> <span class="kr">public</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">uint</span><span class="p">(</span><span class="n">defaultChoice</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="function-types">
<span id="index-13"></span><span id="id12"></span><h3>Function Types<a class="headerlink" href="#function-types" title="Permalink to this headline">¶</a></h3>
<p>ファンクション型はファンクションの型です。
ファンクション型の変数はファンクションから割り当てられ、ファンクションコールにファンクションを渡す、またはファンクションコールからファンクションをリターンするためにファンクション型のパラメータは使用されます。
ファンクション型は2種類あります - <em>internal</em> と <em>external</em> ファンクションです:</p>
<p>現在のコントラクトの外からは実行することができないため、internalファンクションは現在のコントラクト内でのみ呼び出すことができます（具体的には、internalのライブラリファンクションや継承したファンクションも含むコード内）。internalのファンクションは、現在のコントラクト内部でファンクションを呼び出す様に、そのファンクションのエントリポイントにジャンプすることによって実行されます。</p>
<p>Externalファンクションはアドレスとファンクションの署名によって構成され、外部からのファンクションコールを通し、返ってきます。</p>
<p>ファンクションの種類は下記の様に表されます:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">parameter</span> <span class="n">types</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span><span class="kr">internal</span><span class="o">|</span><span class="kr">external</span><span class="p">}</span> <span class="p">[</span><span class="kr">pure</span><span class="o">|</span><span class="kr">view</span><span class="o">|</span><span class="kr">payable</span><span class="p">]</span> <span class="p">[</span><span class="k">returns</span> <span class="p">(</span><span class="o">&lt;</span><span class="k">return</span> <span class="n">types</span><span class="o">&gt;</span><span class="p">)]</span>
</pre></div>
</div>
<p>parameter typesと異なり、return typesは空ではいけません。もしファンクションが何も返さないのであれば、<code class="docutils literal notranslate"><span class="pre">returns</span> <span class="pre">(&lt;return</span> <span class="pre">types&gt;)</span></code> 部分は除外しなければなりません。</p>
<p>デフォルトでは、ファンクション型はinternalで、<code class="docutils literal notranslate"><span class="pre">internal</span></code> というキーワードは削除できます。これはファンクション型でのみ可能です。コントラクト内で定義されたファンクションはデフォルトで定義されておらず、可視性を明示しなければいけません。</p>
<p>Conversions:</p>
<p>externalファンクション型の値は明示的に <code class="docutils literal notranslate"><span class="pre">address</span></code> に変換可能で、そのファンクションのコントラクトのアドレスになります。</p>
<p>もしパラメータの型、返り値の型が同じであり、internal/externalのプロパティも同じ、さらに <code class="docutils literal notranslate"><span class="pre">A</span></code> のミュータビリティの制限が <code class="docutils literal notranslate"><span class="pre">B</span></code> に比べて厳しくない場合あるファンクション型 <code class="docutils literal notranslate"><span class="pre">A</span></code> は 別のファンクション型 <code class="docutils literal notranslate"><span class="pre">B</span></code> に暗黙的に変換可能です。特に:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">pure</span></code> ファンクションは <code class="docutils literal notranslate"><span class="pre">view</span></code> と <code class="docutils literal notranslate"><span class="pre">non-payable</span></code> ファンクションに変換可能</li>
<li><code class="docutils literal notranslate"><span class="pre">view</span></code> ファンクションは <code class="docutils literal notranslate"><span class="pre">non-payable</span></code> ファンクションに変換可能</li>
<li><code class="docutils literal notranslate"><span class="pre">payable</span></code> は <code class="docutils literal notranslate"><span class="pre">non-payable</span></code> ファンクションに変換可能</li>
</ul>
</div></blockquote>
<p>他のファンクション型間の変換はできません。</p>
<p><code class="docutils literal notranslate"><span class="pre">payable</span></code> と <code class="docutils literal notranslate"><span class="pre">non-payable</span></code> 間のルールは少し分かりづらいかもしれません。しかし、大事なことは、<code class="docutils literal notranslate"><span class="pre">payable</span></code> ファンクションは0 etherの支払いを容認し、同様に <code class="docutils literal notranslate"><span class="pre">non-payable</span></code> ファンクションもそれを容認することです。一方で、<code class="docutils literal notranslate"><span class="pre">non-payable</span></code> はEtherの受け取りを拒否するため、<code class="docutils literal notranslate"><span class="pre">non-payable</span></code> ファンクションは <code class="docutils literal notranslate"><span class="pre">payable</span></code> ファンクションに変換できません。</p>
<p>ファンクション型の変数が初期化されていない場合、その変数を呼び出してもフェイルアサーションとなります。<code class="docutils literal notranslate"><span class="pre">delete</span></code> をその変数に対して使った後に呼び出した場合も同じことが起きます。</p>
<p>もしexternalのファンクション型がSolidityのコンテキスト外で使用された場合、ファンクション型として扱われます。そして、それはそのファンクションの識別子とその後のアドレスを一緒に1つの <code class="docutils literal notranslate"><span class="pre">bytes24</span></code> 型にエンコードします。</p>
<p>現在のコントラクトのpublicのファンクションはinternalファンクションとしてもexternalファンクションとしても使用可能です。<code class="docutils literal notranslate"><span class="pre">f</span></code> をinternalファンクションとして使用したい場合には、単純に <code class="docutils literal notranslate"><span class="pre">f</span></code> を、もしexternalファンクションとして使用した場合には、<code class="docutils literal notranslate"><span class="pre">this.f</span></code> を使用してください。</p>
<p>Members:</p>
<p>Public（もしくはexternal）のファンクションは <code class="docutils literal notranslate"><span class="pre">selector</span></code> という特別なメンバも持っています。これは <a class="reference internal" href="abi-spec.html#abi-function-selector"><span class="std std-ref">ABI function selector</span></a> を返します:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">Selector</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="n">f</span><span class="p">()</span> <span class="kr">public</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes4</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">this</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="nb">selector</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>internalのファンクション型の使用例です:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">library</span> <span class="n">ArrayUtils</span> <span class="p">{</span>
  <span class="c1">// internal functions can be used in internal library functions because</span>
  <span class="c1">// they will be part of the same code context</span>
  <span class="kd">function</span> <span class="n">map</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="kr">memory</span> <span class="n">self</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="n">f</span><span class="p">)</span>
    <span class="kr">internal</span>
    <span class="kr">pure</span>
    <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="kr">memory</span> <span class="n">r</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">r</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">uint</span><span class="p">[](</span><span class="n">self</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">self</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">self</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="n">reduce</span><span class="p">(</span>
    <span class="kt">uint</span><span class="p">[]</span> <span class="kr">memory</span> <span class="n">self</span><span class="p">,</span>
    <span class="kd">function</span> <span class="p">(</span><span class="kt">uint</span><span class="p">,</span> <span class="kt">uint</span><span class="p">)</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="n">f</span>
  <span class="p">)</span>
    <span class="kr">internal</span>
    <span class="kr">pure</span>
    <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">r</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">self</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">self</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">r</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">self</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="n">range</span><span class="p">(</span><span class="kt">uint</span> <span class="n">length</span><span class="p">)</span> <span class="kr">internal</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="kr">memory</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">r</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">uint</span><span class="p">[](</span><span class="n">length</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">Pyramid</span> <span class="p">{</span>
  <span class="kn">using</span> <span class="n">ArrayUtils</span> <span class="k">for</span> <span class="o">*</span><span class="p">;</span>
  <span class="kd">function</span> <span class="n">pyramid</span><span class="p">(</span><span class="kt">uint</span> <span class="n">l</span><span class="p">)</span> <span class="kr">public</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">ArrayUtils</span><span class="p">.</span><span class="n">range</span><span class="p">(</span><span class="n">l</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="n">square</span><span class="p">).</span><span class="n">reduce</span><span class="p">(</span><span class="n">sum</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="n">square</span><span class="p">(</span><span class="kt">uint</span> <span class="n">x</span><span class="p">)</span> <span class="kr">internal</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="n">sum</span><span class="p">(</span><span class="kt">uint</span> <span class="n">x</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">y</span><span class="p">)</span> <span class="kr">internal</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>externalファンクション型の別の使用例です:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">22</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">Oracle</span> <span class="p">{</span>
  <span class="kd">struct</span> <span class="n">Request</span> <span class="p">{</span>
    <span class="kt">bytes</span> <span class="n">data</span><span class="p">;</span>
    <span class="kd">function</span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="kr">external</span> <span class="n">callback</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">Request</span><span class="p">[]</span> <span class="n">requests</span><span class="p">;</span>
  <span class="kd">event</span> <span class="n">NewRequest</span><span class="p">(</span><span class="kt">uint</span><span class="p">);</span>
  <span class="kd">function</span> <span class="n">query</span><span class="p">(</span><span class="kt">bytes</span> <span class="kr">memory</span> <span class="n">data</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="kr">external</span> <span class="n">callback</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
    <span class="n">requests</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">Request</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">callback</span><span class="p">));</span>
    <span class="kr">emit</span> <span class="n">NewRequest</span><span class="p">(</span><span class="n">requests</span><span class="p">.</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="n">reply</span><span class="p">(</span><span class="kt">uint</span> <span class="n">requestID</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">response</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
    <span class="c1">// Here goes the check that the reply comes from a trusted source</span>
    <span class="n">requests</span><span class="p">[</span><span class="n">requestID</span><span class="p">].</span><span class="n">callback</span><span class="p">(</span><span class="n">response</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">OracleUser</span> <span class="p">{</span>
  <span class="n">Oracle</span> <span class="kr">constant</span> <span class="n">oracle</span> <span class="o">=</span> <span class="n">Oracle</span><span class="p">(</span><span class="mh">0x1234567</span><span class="p">);</span> <span class="c1">// known contract</span>
  <span class="kt">uint</span> <span class="n">exchangeRate</span><span class="p">;</span>
  <span class="kd">function</span> <span class="n">buySomething</span><span class="p">()</span> <span class="kr">public</span> <span class="p">{</span>
    <span class="n">oracle</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="s">&quot;USD&quot;</span><span class="p">,</span> <span class="nb">this</span><span class="p">.</span><span class="n">oracleResponse</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="n">oracleResponse</span><span class="p">(</span><span class="kt">uint</span> <span class="n">response</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
    <span class="nf">require</span><span class="p">(</span>
        <span class="nb">msg.sender</span> <span class="o">==</span> <span class="kt">address</span><span class="p">(</span><span class="n">oracle</span><span class="p">),</span>
        <span class="s">&quot;Only oracle can call this.&quot;</span>
    <span class="p">);</span>
    <span class="n">exchangeRate</span> <span class="o">=</span> <span class="n">response</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">ラムダ式もしくはインラインファンクションの導入が予定されていますが、まだサポートされていません。</p>
</div>
</div>
</div>
<div class="section" id="reference-types">
<span id="index-14"></span><span id="id13"></span><h2>Reference Types<a class="headerlink" href="#reference-types" title="Permalink to this headline">¶</a></h2>
<p>参照型の値は複数の異なった名前で修正できます。値型の変数が使用される度に、独立したコピーをとった値型と比較してみて下さい。このことから参照型は値型より気をつけて扱う必要があります。現在、構造体、配列、マッピングは参照型です。もし参照型を使用しているのであれば、値が保存されるデータ領域を常に明示する必要があります: <code class="docutils literal notranslate"><span class="pre">memory</span></code> (ライフタイムはファンクションの呼び出し時のみに制限されます)、<code class="docutils literal notranslate"><span class="pre">storage</span></code> （状態変数が保存されている場所）、もしくは <code class="docutils literal notranslate"><span class="pre">calldata</span></code> （特別なデータロケーションで、ファンクションの引数を含み、externalのファンクションコールのパラメータでのみ使用可能です）。</p>
<p>データロケーションを変える値の割り当てや型変換では常に自動でコピー操作が行われる一方で、
同じデータロケーション内での値の割り当てはただコピーするだけです（いくつかの例ではstorage型で）。</p>
<div class="section" id="data-location">
<span id="id14"></span><h3>Data location<a class="headerlink" href="#data-location" title="Permalink to this headline">¶</a></h3>
<p><em>配列</em>、<em>構造体</em> の様な全ての参照型は”data location”というそれが保存されている場所を表す追加のアノテーションを持っています。<code class="docutils literal notranslate"><span class="pre">memory</span></code>, <code class="docutils literal notranslate"><span class="pre">storage</span></code> and <code class="docutils literal notranslate"><span class="pre">calldata</span></code> という3つのデータロケーションがあります。Calldataは外部コントラクトのファンクションの参照型のパラメータとして要求される場合にのみ有効です。Calldataは修正不可で、ファンクションの引数が保存される非永続的なエリアで、基本的にはmemoryの様に振舞います。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">バージョン0.5.0以前では、データロケーションは省略可能ですが、変数の種類やファンクションの種類などによってデフォルトで異なる場所に保存されます。しかし、現在は全ての複雑な型は明示的にデータロケーションを示す必要があります。</p>
</div>
<div class="section" id="data-location-and-assignment-behaviour">
<span id="data-location-assignment"></span><h4>Data location and assignment behaviour<a class="headerlink" href="#data-location-and-assignment-behaviour" title="Permalink to this headline">¶</a></h4>
<p>データロケーションはデータの持続性だけではなく、割り当てのセマンティクスにも関係しています:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">storage</span></code> と <code class="docutils literal notranslate"><span class="pre">memory</span></code> (もしくは <code class="docutils literal notranslate"><span class="pre">calldata</span></code> から)の間での割り当ては常に独立したコピーを作成します。</li>
<li><code class="docutils literal notranslate"><span class="pre">memory</span></code> から <code class="docutils literal notranslate"><span class="pre">memory</span></code> への割り当てでは参照のみ作られます。つまり、memory変数への変化は同じデータを参照している他のmemory変数からも可視であるということです。</li>
<li><code class="docutils literal notranslate"><span class="pre">storage</span></code> からローカル変数へは参照のみ割り当てられます。</li>
<li>他の <code class="docutils literal notranslate"><span class="pre">storage</span></code> への割り当ては常に全てコピーとなります。この例としては、状態変数への割り当てや、たとえローカル変数がただの参照だったとしてもstorageの構造型の要素への割り当てはコピーになります。</li>
</ul>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kt">uint</span><span class="p">[]</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// the data location of x is storage</span>

    <span class="c1">// the data location of memoryArray is memory</span>
    <span class="kd">function</span> <span class="n">f</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="kr">memory</span> <span class="n">memoryArray</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">memoryArray</span><span class="p">;</span> <span class="c1">// works, copies the whole array to storage</span>
        <span class="kt">uint</span><span class="p">[]</span> <span class="kr">storage</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// works, assigns a pointer, data location of y is storage</span>
        <span class="n">y</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span> <span class="c1">// fine, returns the 8th element</span>
        <span class="n">y</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// fine, modifies x through y</span>
        <span class="k">delete</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// fine, clears the array, also modifies y</span>
        <span class="c1">// The following does not work; it would need to create a new temporary /</span>
        <span class="c1">// unnamed array in storage, but storage is &quot;statically&quot; allocated:</span>
        <span class="c1">// y = memoryArray;</span>
        <span class="c1">// This does not work either, since it would &quot;reset&quot; the pointer, but there</span>
        <span class="c1">// is no sensible location it could point to.</span>
        <span class="c1">// delete y;</span>
        <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// calls g, handing over a reference to x</span>
        <span class="n">h</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// calls h and creates an independent, temporary copy in memory</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">g</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="kr">storage</span><span class="p">)</span> <span class="kr">internal</span> <span class="kr">pure</span> <span class="p">{}</span>
    <span class="kd">function</span> <span class="n">h</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="kr">memory</span><span class="p">)</span> <span class="kr">public</span> <span class="kr">pure</span> <span class="p">{}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="arrays">
<span id="index-15"></span><span id="id15"></span><h3>Arrays<a class="headerlink" href="#arrays" title="Permalink to this headline">¶</a></h3>
<p>配列はコンパイル時での固定サイズか動的サイズです。</p>
<p>固定サイズ <code class="docutils literal notranslate"><span class="pre">k</span></code> で要素の型が <code class="docutils literal notranslate"><span class="pre">T</span></code> の配列は <code class="docutils literal notranslate"><span class="pre">T[k]</span></code> の様に記述されます。そして動的サイズの配列は <code class="docutils literal notranslate"><span class="pre">T[]</span></code> の様に書けます。</p>
<p>例えば、5個の <code class="docutils literal notranslate"><span class="pre">uint</span></code> 動的配列の配列は <code class="docutils literal notranslate"><span class="pre">uint[][5]</span></code> の様に書けます。この記法は他の記法でも使われています。Solidityでは、たとえ <code class="docutils literal notranslate"><span class="pre">X</span></code> 自体が配列だとしても <code class="docutils literal notranslate"><span class="pre">X[3]</span></code> は常に3つの要素を含んだ <code class="docutils literal notranslate"><span class="pre">X</span></code> 型となります。これは例えばC言語の様な他の言語とは異なっています。</p>
<p>インデックスはゼロベースで、アクセスする際には宣言とは逆方向でアクセスします。</p>
<p>例えば、もし <code class="docutils literal notranslate"><span class="pre">uint[][5]</span> <span class="pre">x</span> <span class="pre">memory</span></code> を持っていたら、3つ目の動的配列に入っている2つ目の <code class="docutils literal notranslate"><span class="pre">uint</span></code> には <code class="docutils literal notranslate"><span class="pre">x[2][1]</span></code> でアクセスできます。また、3つ目の動的配列自体には <code class="docutils literal notranslate"><span class="pre">x[2]</span></code> でアクセスします。繰り返しですが、<code class="docutils literal notranslate"><span class="pre">T[5]</span> <span class="pre">a</span></code> という配列（<code class="docutils literal notranslate"><span class="pre">T</span></code> 自体は配列でも良い）を持っていたら、<code class="docutils literal notranslate"><span class="pre">a[2]</span></code> というのは常に <code class="docutils literal notranslate"><span class="pre">T</span></code> という型になります。</p>
<p>配列の要素はマッピングや構造体含めてどの型でも構いません。全般的な制限として、マッピングは <code class="docutils literal notranslate"><span class="pre">storage</span></code> にのみ保存され、publicなファンクションは <a class="reference internal" href="abi-spec.html#abi"><span class="std std-ref">ABI types</span></a> であるパラメータが必要になります。</p>
<p>配列に <code class="docutils literal notranslate"><span class="pre">public</span></code> をつけることでSolidityが <a class="reference internal" href="contracts.html#visibility-and-getters"><span class="std std-ref">getter</span></a> を生成します。
インデックスがgetterのパラメータになります。</p>
<p>そのサイズ以上の配列要素にアクセスしようとするとフェイルアサーションが発生します。新しい要素を配列の最後に追加するために <code class="docutils literal notranslate"><span class="pre">.push()</span></code> が、新しいサイズを指定するのに <code class="docutils literal notranslate"><span class="pre">.length</span></code> <a class="reference internal" href="#array-members"><span class="std std-ref">member</span></a> が使用できます（下記補足を参照ください）。</p>
<div class="section" id="bytes-and-strings-as-arrays">
<h4><code class="docutils literal notranslate"><span class="pre">bytes</span></code> and <code class="docutils literal notranslate"><span class="pre">strings</span></code> as Arrays<a class="headerlink" href="#bytes-and-strings-as-arrays" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">bytes</span></code> と <code class="docutils literal notranslate"><span class="pre">string</span></code> 型の変数は特別な配列となります。<code class="docutils literal notranslate"><span class="pre">bytes</span></code> は <code class="docutils literal notranslate"><span class="pre">byte[]</span></code> と似ていますが、calldataとmemoryに保存されています。<code class="docutils literal notranslate"><span class="pre">string</span></code> は <code class="docutils literal notranslate"><span class="pre">bytes</span></code> と等価ですが、lengthとインデックスによるアクセスができません。</p>
<p>SolidityはStringを操作するファンクションがありませんが、同じ機能を使うための暗黙の変換が使えます。例えば、2つのstringを比較するためには <code class="docutils literal notranslate"><span class="pre">keccak256(abi.encode(s1))</span> <span class="pre">==</span> <span class="pre">keccak256(abi.encode(s2))</span></code>、エンコードされた2つのstringを連結させるには <code class="docutils literal notranslate"><span class="pre">abi.encodePacked(s1,</span> <span class="pre">s2);</span></code> を使うことができます。</p>
<p><code class="docutils literal notranslate"><span class="pre">byte[]</span></code> は要素間を埋めるのに31バイト追加するので、<code class="docutils literal notranslate"><span class="pre">byte[]</span></code> よりその分安い <code class="docutils literal notranslate"><span class="pre">bytes</span></code> を使用する方が良いでしょう。全般的なルールとして、<code class="docutils literal notranslate"><span class="pre">bytes</span></code> は任意の長さの生のバイトデータを、<code class="docutils literal notranslate"><span class="pre">string</span></code> を任意の長さのstring (UTF-8)データを使用するために使ってください。もしバイト長に制限を咥えられるのであれば、非常に低コストに抑えられるため、常に``bytes1`` から <code class="docutils literal notranslate"><span class="pre">bytes32</span></code> までのいずれかを使用してください。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">もしバイト表現のある文字列 <code class="docutils literal notranslate"><span class="pre">s</span></code> にアクセスしたい場合は、<code class="docutils literal notranslate"><span class="pre">bytes(s).length</span></code> / <code class="docutils literal notranslate"><span class="pre">bytes(s)[7]</span> <span class="pre">=</span> <span class="pre">'x';</span></code> を使ってください。この際、低レベルのUTF-8表現にアクセスしているのであって、個々の文字にアクセスしている訳ではないということを覚えておいてください。</p>
</div>
</div>
<div class="section" id="allocating-memory-arrays">
<span id="index-16"></span><h4>Allocating Memory Arrays<a class="headerlink" href="#allocating-memory-arrays" title="Permalink to this headline">¶</a></h4>
<p>メモリー内のランタイム依存の長さを持つ配列を作成するには <code class="docutils literal notranslate"><span class="pre">new</span></code> というキーワードを使う必要があります。storageの配列とは逆で、（<code class="docutils literal notranslate"><span class="pre">.length</span></code> を使ったりして）memoryの配列の長さを変えることはできません。事前に長さを計算しておくか、新しいmemoryの配列を作成して全ての要素をコピーする必要があります。</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">f</span><span class="p">(</span><span class="kt">uint</span> <span class="n">len</span><span class="p">)</span> <span class="kr">public</span> <span class="kr">pure</span> <span class="p">{</span>
        <span class="kt">uint</span><span class="p">[]</span> <span class="kr">memory</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">uint</span><span class="p">[](</span><span class="mi">7</span><span class="p">);</span>
        <span class="kt">bytes</span> <span class="kr">memory</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">bytes</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
        <span class="nf">assert</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">7</span><span class="p">);</span>
        <span class="nf">assert</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">length</span> <span class="o">==</span> <span class="n">len</span><span class="p">);</span>
        <span class="n">a</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="array-literals">
<span id="index-17"></span><h4>Array Literals<a class="headerlink" href="#array-literals" title="Permalink to this headline">¶</a></h4>
<p>配列リテラルは角括弧 (<code class="docutils literal notranslate"><span class="pre">[...]</span></code>)で囲まれ、カンマで区切られた1つ以上のリストを持っています（例えば <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">a,</span> <span class="pre">f(3)]</span></code>）。全ての要素が暗黙的に変換できる共通の型が存在しなければなりません。これはその配列の基本型になります。</p>
<p>配列リテラルは常に静的サイズのmemoryの配列となります。</p>
<p>下記の例で、<code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code> の型は <code class="docutils literal notranslate"><span class="pre">uint8[3]</span> <span class="pre">memory</span></code> です。各値の型が <code class="docutils literal notranslate"><span class="pre">uint8</span></code> ですので、もし <code class="docutils literal notranslate"><span class="pre">uint[3]</span> <span class="pre">memory</span></code> の結果が欲しい場合には、最初の要素を <code class="docutils literal notranslate"><span class="pre">uint</span></code> 型に変換する必要があります。</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">f</span><span class="p">()</span> <span class="kr">public</span> <span class="kr">pure</span> <span class="p">{</span>
        <span class="n">g</span><span class="p">([</span><span class="kt">uint</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="kd">function</span> <span class="n">g</span><span class="p">(</span><span class="kt">uint</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="kr">memory</span><span class="p">)</span> <span class="kr">public</span> <span class="kr">pure</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>固定サイズのmemoryの配列は可変サイズのmemoryの配列に割り当てることはできません。例えば、次の例の様なことはできません:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="c1">// This will not compile.</span>
<span class="kd">contract</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">f</span><span class="p">()</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="c1">// The next line creates a type error because uint[3] memory</span>
        <span class="c1">// cannot be converted to uint[] memory.</span>
        <span class="kt">uint</span><span class="p">[]</span> <span class="kr">memory</span> <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="kt">uint</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この制約は将来的には削除する予定ですが、ABI内で配列の受け渡し方で複雑になってしまいます。</p>
</div>
<div class="section" id="array-members">
<span id="index-18"></span><span id="id16"></span><h4>Array Members<a class="headerlink" href="#array-members" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt><strong>length</strong>:</dt>
<dd>配列はその要素の長さを含む <code class="docutils literal notranslate"><span class="pre">length</span></code> というメンバを持っています。
memory配列の長さは作成時に固定されます（動的配列はランタイムのパラメータによります）。
動的配列（storageでのみ使用可）に関して、このメンバは配列のサイズを変えるのに使用できます。
そのサイズ以上の配列要素にアクセスしようとすると、自動でサイズを変更するのではなく、フェイルアサーションが発生します。
長さを大きくすると、ゼロ初期化された要素が配列に加わります。長さを減らすと、削除された各要素に対して <code class="docutils literal notranslate"><span class="pre">delete</span></code> を暗黙的に行います。もしstorage出ない非動的配列のリサイズを行おうとすると、<code class="docutils literal notranslate"><span class="pre">Value</span> <span class="pre">must</span> <span class="pre">be</span> <span class="pre">an</span> <span class="pre">lvalue</span></code> というエラーが発生します。</dd>
<dt><strong>push</strong>:</dt>
<dd>動的storage配列と <code class="docutils literal notranslate"><span class="pre">bytes``（</span> <span class="pre">``string</span></code> ではなく）は <code class="docutils literal notranslate"><span class="pre">push</span></code> というファンクションを持ち、配列の最後に要素を追加することができます。その要素はゼロ初期化されます。ファンクションは新しい長さを返します。</dd>
<dt><strong>pop</strong>:</dt>
<dd>動的storage配列と <code class="docutils literal notranslate"><span class="pre">bytes``（</span> <span class="pre">``string</span></code> ではなく）は <code class="docutils literal notranslate"><span class="pre">pop</span></code> というファンクションを持ち、配列の最後から一つの要素を削除することができます。これも暗黙的に削除する要素に対して <code class="docutils literal notranslate"><span class="pre">delete</span></code> を呼び出しています。</dd>
</dl>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">もし <code class="docutils literal notranslate"><span class="pre">.length--</span></code> を空の配列に対して使うのと、アンダーフローし、長さが <code class="docutils literal notranslate"><span class="pre">2**256-1</span></code> となってしまいます。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">storageの配列の長さを増やすことで一定のガスがかかります。これはstorageがゼロ初期化されているとみなされているためです。一方で、長さを減らすのは少なくとも比例関数的にコストがかかります（しかしほとんどの場合比例関数より高くなります）。これは、<code class="docutils literal notranslate"><span class="pre">delete</span></code> を呼び出す様に明示的に削除した要素をクリアする工程を含んでいるためです。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">まだ配列の配列をexternalのファンクションで使用することはできません（ただし、publicのファンクションではサポートされています）。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Byzantiumの前のEVMのバージョンではファンクションコールからの返り値として動的配列にはアクセスできませんでした。もし動的配列を返すファンクションんを呼び出すときは、ByzantiumモードがセットされているEVMを使っていることを確認して下さい。</p>
</div>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">ArrayContract</span> <span class="p">{</span>
    <span class="kt">uint</span><span class="p">[</span><span class="mi">2</span><span class="o">**</span><span class="mi">20</span><span class="p">]</span> <span class="n">m_aLotOfIntegers</span><span class="p">;</span>
    <span class="c1">// Note that the following is not a pair of dynamic arrays but a</span>
    <span class="c1">// dynamic array of pairs (i.e. of fixed size arrays of length two).</span>
    <span class="c1">// Because of that, T[] is always a dynamic array of T, even if T</span>
    <span class="c1">// itself is an array.</span>
    <span class="c1">// Data location for all state variables is storage.</span>
    <span class="kt">bool</span><span class="p">[</span><span class="mi">2</span><span class="p">][]</span> <span class="n">m_pairsOfFlags</span><span class="p">;</span>

    <span class="c1">// newPairs is stored in memory - the only possibility</span>
    <span class="c1">// for public contract function arguments</span>
    <span class="kd">function</span> <span class="n">setAllFlagPairs</span><span class="p">(</span><span class="kt">bool</span><span class="p">[</span><span class="mi">2</span><span class="p">][]</span> <span class="kr">memory</span> <span class="n">newPairs</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="c1">// assignment to a storage array performs a copy of ``newPairs`` and</span>
        <span class="c1">// replaces the complete array ``m_pairsOfFlags``.</span>
        <span class="n">m_pairsOfFlags</span> <span class="o">=</span> <span class="n">newPairs</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">struct</span> <span class="n">StructType</span> <span class="p">{</span>
        <span class="kt">uint</span><span class="p">[]</span> <span class="n">contents</span><span class="p">;</span>
        <span class="kt">uint</span> <span class="n">moreInfo</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">StructType</span> <span class="n">s</span><span class="p">;</span>

    <span class="kd">function</span> <span class="n">f</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="kr">memory</span> <span class="n">c</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="c1">// stores a reference to ``s`` in ``g``</span>
        <span class="n">StructType</span> <span class="kr">storage</span> <span class="n">g</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
        <span class="c1">// also changes ``s.moreInfo``.</span>
        <span class="n">g</span><span class="p">.</span><span class="n">moreInfo</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="c1">// assigns a copy because ``g.contents``</span>
        <span class="c1">// is not a local variable, but a member of</span>
        <span class="c1">// a local variable.</span>
        <span class="n">g</span><span class="p">.</span><span class="n">contents</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">setFlagPair</span><span class="p">(</span><span class="kt">uint</span> <span class="n">index</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">flagA</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">flagB</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="c1">// access to a non-existing index will throw an exception</span>
        <span class="n">m_pairsOfFlags</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">flagA</span><span class="p">;</span>
        <span class="n">m_pairsOfFlags</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">flagB</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">changeFlagArraySize</span><span class="p">(</span><span class="kt">uint</span> <span class="n">newSize</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="c1">// if the new size is smaller, removed array elements will be cleared</span>
        <span class="n">m_pairsOfFlags</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">newSize</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">clear</span><span class="p">()</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="c1">// these clear the arrays completely</span>
        <span class="k">delete</span> <span class="n">m_pairsOfFlags</span><span class="p">;</span>
        <span class="k">delete</span> <span class="n">m_aLotOfIntegers</span><span class="p">;</span>
        <span class="c1">// identical effect here</span>
        <span class="n">m_pairsOfFlags</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bytes</span> <span class="n">m_byteData</span><span class="p">;</span>

    <span class="kd">function</span> <span class="n">byteArrays</span><span class="p">(</span><span class="kt">bytes</span> <span class="kr">memory</span> <span class="n">data</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="c1">// byte arrays (&quot;bytes&quot;) are different as they are stored without padding,</span>
        <span class="c1">// but can be treated identical to &quot;uint8[]&quot;</span>
        <span class="n">m_byteData</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
        <span class="n">m_byteData</span><span class="p">.</span><span class="n">length</span> <span class="o">+=</span> <span class="mi">7</span><span class="p">;</span>
        <span class="n">m_byteData</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x08</span><span class="p">;</span>
        <span class="k">delete</span> <span class="n">m_byteData</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">addFlag</span><span class="p">(</span><span class="kt">bool</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="kr">memory</span> <span class="n">flag</span><span class="p">)</span> <span class="kr">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_pairsOfFlags</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">flag</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">createMemoryArray</span><span class="p">(</span><span class="kt">uint</span> <span class="n">size</span><span class="p">)</span> <span class="kr">public</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes</span> <span class="kr">memory</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Dynamic memory arrays are created using `new`:</span>
        <span class="kt">uint</span><span class="p">[</span><span class="mi">2</span><span class="p">][]</span> <span class="kr">memory</span> <span class="n">arrayOfPairs</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">uint</span><span class="p">[</span><span class="mi">2</span><span class="p">][](</span><span class="n">size</span><span class="p">);</span>

        <span class="c1">// Inline arrays are always statically-sized and if you only</span>
        <span class="c1">// use literals, you have to provide at least one type.</span>
        <span class="n">arrayOfPairs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kt">uint</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">2</span><span class="p">];</span>

        <span class="c1">// Create a dynamic byte array:</span>
        <span class="kt">bytes</span> <span class="kr">memory</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">bytes</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kt">byte</span><span class="p">(</span><span class="kt">uint8</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
        <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="structs">
<span id="index-19"></span><span id="id17"></span><h3>Structs<a class="headerlink" href="#structs" title="Permalink to this headline">¶</a></h3>
<p>Solidityでは次の例の様に構造体として新しい型を定義する方法があります:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">11</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">CrowdFunding</span> <span class="p">{</span>
    <span class="c1">// Defines a new type with two fields.</span>
    <span class="kd">struct</span> <span class="n">Funder</span> <span class="p">{</span>
        <span class="kt">address</span> <span class="n">addr</span><span class="p">;</span>
        <span class="kt">uint</span> <span class="n">amount</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">struct</span> <span class="n">Campaign</span> <span class="p">{</span>
        <span class="kt">address</span> <span class="kr">payable</span> <span class="n">beneficiary</span><span class="p">;</span>
        <span class="kt">uint</span> <span class="n">fundingGoal</span><span class="p">;</span>
        <span class="kt">uint</span> <span class="n">numFunders</span><span class="p">;</span>
        <span class="kt">uint</span> <span class="n">amount</span><span class="p">;</span>
        <span class="kd">mapping</span> <span class="p">(</span><span class="kt">uint</span> <span class="o">=&gt;</span> <span class="n">Funder</span><span class="p">)</span> <span class="n">funders</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">uint</span> <span class="n">numCampaigns</span><span class="p">;</span>
    <span class="kd">mapping</span> <span class="p">(</span><span class="kt">uint</span> <span class="o">=&gt;</span> <span class="n">Campaign</span><span class="p">)</span> <span class="n">campaigns</span><span class="p">;</span>

    <span class="kd">function</span> <span class="n">newCampaign</span><span class="p">(</span><span class="kt">address</span> <span class="kr">payable</span> <span class="n">beneficiary</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">goal</span><span class="p">)</span> <span class="kr">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">campaignID</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">campaignID</span> <span class="o">=</span> <span class="n">numCampaigns</span><span class="o">++</span><span class="p">;</span> <span class="c1">// campaignID is return variable</span>
        <span class="c1">// Creates new struct in memory and copies it to storage.</span>
        <span class="c1">// We leave out the mapping type, because it is not valid in memory.</span>
        <span class="c1">// If structs are copied (even from storage to storage), mapping types</span>
        <span class="c1">// are always omitted, because they cannot be enumerated.</span>
        <span class="n">campaigns</span><span class="p">[</span><span class="n">campaignID</span><span class="p">]</span> <span class="o">=</span> <span class="n">Campaign</span><span class="p">(</span><span class="n">beneficiary</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">contribute</span><span class="p">(</span><span class="kt">uint</span> <span class="n">campaignID</span><span class="p">)</span> <span class="kr">public</span> <span class="kr">payable</span> <span class="p">{</span>
        <span class="n">Campaign</span> <span class="kr">storage</span> <span class="n">c</span> <span class="o">=</span> <span class="n">campaigns</span><span class="p">[</span><span class="n">campaignID</span><span class="p">];</span>
        <span class="c1">// Creates a new temporary memory struct, initialised with the given values</span>
        <span class="c1">// and copies it over to storage.</span>
        <span class="c1">// Note that you can also use Funder(msg.sender, msg.value) to initialise.</span>
        <span class="n">c</span><span class="p">.</span><span class="n">funders</span><span class="p">[</span><span class="n">c</span><span class="p">.</span><span class="n">numFunders</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">Funder</span><span class="p">({</span><span class="n">addr</span><span class="o">:</span> <span class="nb">msg.sender</span><span class="p">,</span> <span class="n">amount</span><span class="o">:</span> <span class="nb">msg.value</span><span class="p">});</span>
        <span class="n">c</span><span class="p">.</span><span class="n">amount</span> <span class="o">+=</span> <span class="nb">msg.value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">checkGoalReached</span><span class="p">(</span><span class="kt">uint</span> <span class="n">campaignID</span><span class="p">)</span> <span class="kr">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span> <span class="n">reached</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Campaign</span> <span class="kr">storage</span> <span class="n">c</span> <span class="o">=</span> <span class="n">campaigns</span><span class="p">[</span><span class="n">campaignID</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">amount</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">fundingGoal</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="kt">uint</span> <span class="n">amount</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">amount</span><span class="p">;</span>
        <span class="n">c</span><span class="p">.</span><span class="n">amount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">c</span><span class="p">.</span><span class="n">beneficiary</span><span class="p">.</span><span class="nf">transfer</span><span class="p">(</span><span class="n">amount</span><span class="p">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このコントラクトはクラウドファンディングの全機能を備えている訳ではありませんが、構造体を理解するために必要な基本的な概念を含んでいます。構造体型はマッピングや配列の中でも使えますし、構造体の中にマッピングや配列を含むこともできます。</p>
<p>構造体自身はマッピングの要素の値型になったり、自分自身の型の動的配列を含むことはできますが、構造体の中に自分自身の構造体型を含めることはできません。構造体のサイズが有限である様にするためにこの制限が必要となっています。</p>
<p>これらの全てのファンクションの中で、構造体型がどの様にデータの保存場所である <code class="docutils literal notranslate"><span class="pre">storage</span></code> が付いているローカル変数に割り当てられているか注意してください。構造体をコピーしているのではなく、参照先を保存しているだけなので、ローカル変数への割り当ては実際は状態のみを記述しています。</p>
<p>もちろん、<code class="docutils literal notranslate"><span class="pre">campaigns[campaignID].amount</span> <span class="pre">=</span> <span class="pre">0</span></code> の様にローカル変数への割り当てをせずに直接構造体へアクセスすることもできます。</p>
</div>
</div>
<div class="section" id="mapping-types">
<span id="index-20"></span><span id="id18"></span><h2>Mapping Types<a class="headerlink" href="#mapping-types" title="Permalink to this headline">¶</a></h2>
<p>マッピング型は <code class="docutils literal notranslate"><span class="pre">mapping(_KeyType</span> <span class="pre">=&gt;</span> <span class="pre">_ValueType)</span></code> という構文で宣言します。<code class="docutils literal notranslate"><span class="pre">_KeyType</span></code> はどの基本型でも入ります。つまりどのビルトインの型に加え、<code class="docutils literal notranslate"><span class="pre">bytes</span></code> と <code class="docutils literal notranslate"><span class="pre">string</span></code> が使えます。ユーザー定義、もしくはコントラクト型、enum、マッピング、構造体、<code class="docutils literal notranslate"><span class="pre">bytes</span></code> と <code class="docutils literal notranslate"><span class="pre">string</span></code> を除いた配列は使用できません。<code class="docutils literal notranslate"><span class="pre">_ValueType</span></code> はマッピングを含めて、どの型でもとることができます。</p>
<p>マッピングはどんなキーも存在し、そのバイト表現は全てゼロ（型の <a class="reference internal" href="control-structures.html#default-value"><span class="std std-ref">デフォルト値</span></a>）で実質的に初期化されている <a class="reference external" href="https://en.wikipedia.org/wiki/Hash_table">hash tables</a> の様に考えることができます。ただ似ているのはそれだけで、キーデータはマッピングには保存されず、その <code class="docutils literal notranslate"><span class="pre">keccak256</span></code> ハッシュだけが値を検索するのに使用されます。</p>
<p>そのため、マッピングは長さを持たず、キーの概念やセットする値などはありません。</p>
<p>マッピングは <code class="docutils literal notranslate"><span class="pre">storage</span></code> にのみデータを置けるため、ファンクション内のstorage参照型、もしくはライブラリファンクションのパラメータとしての状態変数として使用されます。パラメータやパブリックにアクセスできるコントラクトファンクションの返り値としては使用できません。</p>
<p>マッピングタイプに <code class="docutils literal notranslate"><span class="pre">public</span></code> 修飾子をつけることができます。Solidityはそれにより <a class="reference internal" href="contracts.html#visibility-and-getters"><span class="std std-ref">getter</span></a> を生成します。<code class="docutils literal notranslate"><span class="pre">_KeyType</span></code> はゲッターのパラメータになります。もし <code class="docutils literal notranslate"><span class="pre">_ValueType</span></code> が値型か構造体の場合、ゲッターは <code class="docutils literal notranslate"><span class="pre">_ValueType</span></code> を返します。もし <code class="docutils literal notranslate"><span class="pre">_ValueType</span></code> が配列かマッピングであれば、ゲッターは各 <code class="docutils literal notranslate"><span class="pre">_KeyType</span></code> に対して一つのパラメータを再帰的に持ちます。以下マッピングの例です:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">MappingExample</span> <span class="p">{</span>
    <span class="kd">mapping</span><span class="p">(</span><span class="kt">address</span> <span class="o">=&gt;</span> <span class="kt">uint</span><span class="p">)</span> <span class="kr">public</span> <span class="n">balances</span><span class="p">;</span>

    <span class="kd">function</span> <span class="n">update</span><span class="p">(</span><span class="kt">uint</span> <span class="n">newBalance</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="n">balances</span><span class="p">[</span><span class="nb">msg.sender</span><span class="p">]</span> <span class="o">=</span> <span class="n">newBalance</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">MappingUser</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">f</span><span class="p">()</span> <span class="kr">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">MappingExample</span> <span class="n">m</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MappingExample</span><span class="p">();</span>
        <span class="n">m</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">m</span><span class="p">.</span><span class="n">balances</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="nb">this</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">マッピングはiterableではありませんが、マッピング上のデータ構造を実装することは可能です。具体例は <a class="reference external" href="https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol">iterable mapping</a> を参照ください。</p>
</div>
</div>
<div class="section" id="operators-involving-lvalues">
<span id="index-21"></span><h2>Operators Involving LValues<a class="headerlink" href="#operators-involving-lvalues" title="Permalink to this headline">¶</a></h2>
<p>もし <code class="docutils literal notranslate"><span class="pre">a</span></code> がLValue（変数もしくは何か割り当てが行えるもの）であれば、以下の演算子が短縮記法として使えます:</p>
<p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+=</span> <span class="pre">e</span></code> は <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">e</span></code> と等価です。 演算子 <code class="docutils literal notranslate"><span class="pre">-=</span></code>, <code class="docutils literal notranslate"><span class="pre">*=</span></code>, <code class="docutils literal notranslate"><span class="pre">/=</span></code>, <code class="docutils literal notranslate"><span class="pre">%=</span></code>, <code class="docutils literal notranslate"><span class="pre">|=</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;=</span></code>, <code class="docutils literal notranslate"><span class="pre">^=</span></code> も同様に定義されます。<code class="docutils literal notranslate"><span class="pre">a++</span></code> と <code class="docutils literal notranslate"><span class="pre">a--</span></code> は <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+=</span> <span class="pre">1</span></code> / <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-=</span> <span class="pre">1</span></code> と等価ですがこの式自体は計算前の値 <code class="docutils literal notranslate"><span class="pre">a</span></code> です。一方、<code class="docutils literal notranslate"><span class="pre">--a</span></code> と <code class="docutils literal notranslate"><span class="pre">++a</span></code> は <code class="docutils literal notranslate"><span class="pre">a</span></code> に対して同じ計算を行いますが、この式自体は計算後の値を持ちます。</p>
<div class="section" id="delete">
<h3>delete<a class="headerlink" href="#delete" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">delete</span> <span class="pre">a</span></code> は <code class="docutils literal notranslate"><span class="pre">a</span></code> に初期値を割り当てます。例えば、整数型であれば <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">0</span></code> に相当します。しかし、長さゼロの動的配列や全ての要素が初期値で同じ長さの静的配列も使用可能です。<code class="docutils literal notranslate"><span class="pre">delete</span> <span class="pre">a[x]</span></code> はインデックス <code class="docutils literal notranslate"><span class="pre">x</span></code> の配列の要素を削除し、他のは残し配列の長さは変えません。つまり配列に空白を残します。もし要素を削除する予定であれば、おそらくマッピングの方がよいでしょう。</p>
<p>構造体に対しては全ての要素をリセットした上で初期値を割り当てます。言い換えると、<code class="docutils literal notranslate"><span class="pre">delete</span> <span class="pre">a</span></code>　の後は <code class="docutils literal notranslate"><span class="pre">a</span></code> があたかも値の代入されていないただ宣言されただけの <code class="docutils literal notranslate"><span class="pre">a</span></code> と同じ扱いができます。ただし、以下の様に注意が必要です:</p>
<p><code class="docutils literal notranslate"><span class="pre">delete</span></code> はマッピングには効きません（マッピングのキーはおそらく任意であり、一般に未知のためです）。そのため、もし構造体を削除したら、マッピングではない全ての要素はリセットされ、マッピング以外の要素は再帰的に処理されます。しかし、個々のキーと、マッピングしたものは削除することができます: <code class="docutils literal notranslate"><span class="pre">a</span></code> がマッピングであれば、<code class="docutils literal notranslate"><span class="pre">delete</span> <span class="pre">a[x]</span></code> で <code class="docutils literal notranslate"><span class="pre">x</span></code> に保存されている値は削除されます。</p>
<p>覚えておきたいのは <code class="docutils literal notranslate"><span class="pre">delete</span> <span class="pre">a</span></code> は <code class="docutils literal notranslate"><span class="pre">a</span></code> への値の代入の様に振舞うことです。<code class="docutils literal notranslate"><span class="pre">a</span></code> に新しいオブジェクトを保存します。この特徴は <code class="docutils literal notranslate"><span class="pre">a</span></code> が参照型の場合分かりやすいです: <code class="docutils literal notranslate"><span class="pre">a</span></code> そのものだけリセットし、元々参照していた値はリセットしません。</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span> <span class="o">&lt;</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">DeleteExample</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="n">data</span><span class="p">;</span>
    <span class="kt">uint</span><span class="p">[]</span> <span class="n">dataArray</span><span class="p">;</span>

    <span class="kd">function</span> <span class="n">f</span><span class="p">()</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="kt">uint</span> <span class="n">x</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
        <span class="k">delete</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// sets x to 0, does not affect data</span>
        <span class="k">delete</span> <span class="n">data</span><span class="p">;</span> <span class="c1">// sets data to 0, does not affect x</span>
        <span class="kt">uint</span><span class="p">[]</span> <span class="kr">storage</span> <span class="n">y</span> <span class="o">=</span> <span class="n">dataArray</span><span class="p">;</span>
        <span class="k">delete</span> <span class="n">dataArray</span><span class="p">;</span> <span class="c1">// this sets dataArray.length to zero, but as uint[] is a complex object, also</span>
        <span class="c1">// y is affected which is an alias to the storage object</span>
        <span class="c1">// On the other hand: &quot;delete y&quot; is not valid, as assignments to local variables</span>
        <span class="c1">// referencing storage objects can only be made from existing storage objects.</span>
        <span class="nf">assert</span><span class="p">(</span><span class="n">y</span><span class="p">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="conversions-between-elementary-types">
<span id="types-conversion-elementary-types"></span><span id="index-22"></span><h2>Conversions between Elementary Types<a class="headerlink" href="#conversions-between-elementary-types" title="Permalink to this headline">¶</a></h2>
<div class="section" id="implicit-conversions">
<h3>Implicit Conversions<a class="headerlink" href="#implicit-conversions" title="Permalink to this headline">¶</a></h3>
<p>もし演算子が違う型に使われた場合、コンパイラは暗黙のうちに演算対象の型を変換します（代入、割り当て時も同様です）。一般に、セマンティック的に同じ扱いができ、何の情報も失われないのであれば、暗黙の値型の変換は可能です: <code class="docutils literal notranslate"><span class="pre">uint8</span></code> は <code class="docutils literal notranslate"><span class="pre">uint16</span></code>　に、<code class="docutils literal notranslate"><span class="pre">int128</span></code> は <code class="docutils literal notranslate"><span class="pre">int256</span></code> に変換可能ですが、<code class="docutils literal notranslate"><span class="pre">int8</span></code> は <code class="docutils literal notranslate"><span class="pre">uint256</span></code> に変換不可です（<code class="docutils literal notranslate"><span class="pre">uint256</span></code> は例えば <code class="docutils literal notranslate"><span class="pre">-1</span></code> を持てないからです）。</p>
<p>詳細は型のセクションを参照してください。</p>
</div>
<div class="section" id="explicit-conversions">
<h3>Explicit Conversions<a class="headerlink" href="#explicit-conversions" title="Permalink to this headline">¶</a></h3>
<p>もしコンパイラが暗黙の型変換を行わず、しかしあなたが何をしようとしているのか自分で理解しているのであれば、明示的な型変換は可能な時もあります。しかし、これは予想しない挙動や、コンパイラのセキュリティ的な機能をバイパスする可能性もあるので、結果が予想通りになるかテストを行ってください。以下の例は、負の <code class="docutils literal notranslate"><span class="pre">int8</span></code> を <code class="docutils literal notranslate"><span class="pre">uint</span></code> に変換しています。</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">int8</span> <span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span><span class="p">;</span>
<span class="kt">uint</span> <span class="n">x</span> <span class="o">=</span> <span class="kt">uint</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
</pre></div>
</div>
<p>このコードスニペットの最後では <code class="docutils literal notranslate"><span class="pre">x</span></code> は <code class="docutils literal notranslate"><span class="pre">0xfffff..fd</span></code> (64文字の16進数)という値を持ち、これは256ビットの2の補数表現です。</p>
<p>もしある整数が明示的に小さい型に変換された場合、上側のビットがカットされます:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32</span> <span class="n">a</span> <span class="o">=</span> <span class="mh">0x12345678</span><span class="p">;</span>
<span class="kt">uint16</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">uint16</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">// b will be 0x5678 now</span>
</pre></div>
</div>
<p>もしある整数が大きい型に明示的に変換され場合は、左側に（上側のビットに）パディングされます。変換後の結果と元の整数を比較した場合、それらは等しいものとして扱われます:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">uint16</span> <span class="n">a</span> <span class="o">=</span> <span class="mh">0x1234</span><span class="p">;</span>
<span class="kt">uint32</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">uint32</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">// b will be 0x00001234 now</span>
<span class="nf">assert</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
<p>固定長のバイト型の変換は異なった挙動をします。個々のバイトのシーケンスとして扱われ、小さいサイズへの型変換時にはそのシーケンスがカットされます:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">bytes2</span> <span class="n">a</span> <span class="o">=</span> <span class="mh">0x1234</span><span class="p">;</span>
<span class="kt">bytes1</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">bytes1</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">// b will be 0x12</span>
</pre></div>
</div>
<p>もし固定サイズのバイト型が明示的に大きい型に変換された場合、右側がパディングされます。（もしインデックスが範囲内にあるのであれば）変換前後で同じインデックスで同じ値を返します:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">bytes2</span> <span class="n">a</span> <span class="o">=</span> <span class="mh">0x1234</span><span class="p">;</span>
<span class="kt">bytes4</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">bytes4</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">// b will be 0x12340000</span>
<span class="nf">assert</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="nf">assert</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</pre></div>
</div>
<p>切り取りやパディングの際に、整数と固定サイズのバイト配列は異なった挙動を示すため、整数と固定サイズのバイト配列の明示的な変換は二つが同じサイズである場合のみ許可されます。もし異なるサイズの整数と固定サイズのバイト配列を変換したい時は、理想的な切り取りやパディングルールを明示的にする中継的な変換を使用する必要があります:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">bytes2</span> <span class="n">a</span> <span class="o">=</span> <span class="mh">0x1234</span><span class="p">;</span>
<span class="kt">uint32</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">uint16</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">// b will be 0x00001234</span>
<span class="kt">uint32</span> <span class="n">c</span> <span class="o">=</span> <span class="kt">uint32</span><span class="p">(</span><span class="kt">bytes4</span><span class="p">(</span><span class="n">a</span><span class="p">));</span> <span class="c1">// c will be 0x12340000</span>
<span class="kt">uint8</span> <span class="n">d</span> <span class="o">=</span> <span class="kt">uint8</span><span class="p">(</span><span class="kt">uint16</span><span class="p">(</span><span class="n">a</span><span class="p">));</span> <span class="c1">// d will be 0x34</span>
<span class="kt">uint8</span> <span class="n">e</span> <span class="o">=</span> <span class="kt">uint8</span><span class="p">(</span><span class="kt">bytes1</span><span class="p">(</span><span class="n">a</span><span class="p">));</span> <span class="c1">// e will be 0x12</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="conversions-between-literals-and-elementary-types">
<span id="types-conversion-literals"></span><h2>Conversions between Literals and Elementary Types<a class="headerlink" href="#conversions-between-literals-and-elementary-types" title="Permalink to this headline">¶</a></h2>
<div class="section" id="integer-types">
<h3>Integer Types<a class="headerlink" href="#integer-types" title="Permalink to this headline">¶</a></h3>
<p>切り捨てなしに表せるほど十分大きければ10進数と16進数のリテラルは暗黙的にどの整数型にも変換可能です:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">uint8</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span> <span class="c1">// fine</span>
<span class="kt">uint32</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1234</span><span class="p">;</span> <span class="c1">// fine</span>
<span class="kt">uint16</span> <span class="n">c</span> <span class="o">=</span> <span class="mh">0x123456</span><span class="p">;</span> <span class="c1">// fails, since it would have to truncate to 0x3456</span>
</pre></div>
</div>
</div>
<div class="section" id="id19">
<h3>Fixed-Size Byte Arrays<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h3>
<p>10進数の数字リテラルは暗黙的に固定サイズのバイト配列に変換できません。16進数の数字リテラルはバイト型のサイズと桁数がぴったり合っている場合のみ変換可能です。10進数、16進数両者の唯一の例外として、値が0であればどの固定サイズのバイト型に変換できます:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">bytes2</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">54321</span><span class="p">;</span> <span class="c1">// not allowed</span>
<span class="kt">bytes2</span> <span class="n">b</span> <span class="o">=</span> <span class="mh">0x12</span><span class="p">;</span> <span class="c1">// not allowed</span>
<span class="kt">bytes2</span> <span class="n">c</span> <span class="o">=</span> <span class="mh">0x123</span><span class="p">;</span> <span class="c1">// not allowed</span>
<span class="kt">bytes2</span> <span class="n">d</span> <span class="o">=</span> <span class="mh">0x1234</span><span class="p">;</span> <span class="c1">// fine</span>
<span class="kt">bytes2</span> <span class="n">e</span> <span class="o">=</span> <span class="mh">0x0012</span><span class="p">;</span> <span class="c1">// fine</span>
<span class="kt">bytes4</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// fine</span>
<span class="kt">bytes4</span> <span class="n">g</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span> <span class="c1">// fine</span>
</pre></div>
</div>
<p>文字数とバイト型のサイズが合っていれば、文字列リテラルと16進数文字列リテラルは暗黙的に固定サイズバイト配列に変換できます:</p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">bytes2</span> <span class="n">a</span> <span class="o">=</span> <span class="s">hex&quot;1234&quot;</span><span class="p">;</span> <span class="c1">// fine</span>
<span class="kt">bytes2</span> <span class="n">b</span> <span class="o">=</span> <span class="s">&quot;xy&quot;</span><span class="p">;</span> <span class="c1">// fine</span>
<span class="kt">bytes2</span> <span class="n">c</span> <span class="o">=</span> <span class="s">hex&quot;12&quot;</span><span class="p">;</span> <span class="c1">// not allowed</span>
<span class="kt">bytes2</span> <span class="n">d</span> <span class="o">=</span> <span class="s">hex&quot;123&quot;</span><span class="p">;</span> <span class="c1">// not allowed</span>
<span class="kt">bytes2</span> <span class="n">e</span> <span class="o">=</span> <span class="s">&quot;x&quot;</span><span class="p">;</span> <span class="c1">// not allowed</span>
<span class="kt">bytes2</span> <span class="n">f</span> <span class="o">=</span> <span class="s">&quot;xyz&quot;</span><span class="p">;</span> <span class="c1">// not allowed</span>
</pre></div>
</div>
</div>
<div class="section" id="addresses">
<h3>Addresses<a class="headerlink" href="#addresses" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="#address-literals"><span class="std std-ref">Address Literals</span></a> で説明したように、チェックサムテストが通る正しいサイズの16進数リテラルは <code class="docutils literal notranslate"><span class="pre">アドレス</span></code> 型です。他のリテラルは暗黙的に <code class="docutils literal notranslate"><span class="pre">アドレス</span></code> 型への変換はできません。</p>
<p><code class="docutils literal notranslate"><span class="pre">bytes20</span></code> もしくは他の整数型から <code class="docutils literal notranslate"><span class="pre">address</span></code> への明示的な変換を行うと <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> になります。</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="units-and-global-variables.html" class="btn btn-neutral float-right" title="Units and Globally Available Variables" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="structure-of-a-contract.html" class="btn btn-neutral float-left" title="Structure of a Contract" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016-2019, Ethereum

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>