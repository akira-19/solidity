###
Yul
###

.. _yul:

.. index:: ! assembly, ! asm, ! evmasm, ! yul, julia, iulia

Yul(以前JULIAやIULIAと呼ばれていたものです)は複数の異なるバックエンド(EVM1.0やEVM1.5、eWASM)でコンパイルできる中間言語です。
そのため、Yulは3つのプラットフォームすべての使用可能な共通分母になるように設計されています。
YulはすでにSolidity内の"inline assembly"としても使用されており、Solidityコンパイラの将来のバージョンではYulを中間言語として使用できるようになります。
また、Yul用の高水準オプティマイザステージを構築するのは簡単です。

.. note::

    "inline assembly"として使用されるときに型を持つわけではありません(すべて ``u256``になります)。
    そして、組み込み関数はEVMオペコードと同じです。詳細についてはinline assemblyのドキュメントを参照してください。

Yulのコアコンポーネントは関数、ブロック、変数、リテラル、forループ、if文、switch文、式と変数への代入です。

Yulは型付けされ、変数とリテラルの両方が後置記法で型を指定しなければなりません。
サポートしている型は、 ``bool``、 ``u8``、 ``s8``、 ``u32``、 ``s32``、 ``u64``、 ``s64``、 ``u128``、 ``s128``、 ``u256``、 ``s256``です。

Yul自体は、演算子すら持ちません。もしあるEVMが指定された場合、オペコードは組み込み関数として利用可能になりますが、バックエンドが変更された場合は再実装することができます。
マンダトリーなビルドイン関数のリストは下のセクションを参照ください。

次のプログラムの例では、EVMのオペコード ``mul``、 ``div``、および ``mod``がネイティブでも関数としても利用可能であると仮定して、べき乗を計算します。

.. code::

    {
        function power(base:u256, exponent:u256) -> result:u256
        {
            switch exponent
            case 0:u256 { result := 1:u256 }
            case 1:u256 { result := base }
            default
            {
                result := power(mul(base, base), div(exponent, 2:u256))
                switch mod(exponent, 2:u256)
                    case 1:u256 { result := mul(base, result) }
            }
        }
    }


また、再帰ではなくforループを使用して同じ関数を実装することも可能です。
ここで、利用可能なEVMオペコードの ``lt``(less-than)と ``add``が必要になります。

.. code::

    {
        function power(base:u256, exponent:u256) -> result:u256
        {
            result := 1:u256
            for { let i := 0:u256 } lt(i, exponent) { i := add(i, 1:u256) }
            {
                result := mul(result, base)
            }
        }
    }

Specification of Yul
====================

この章では、Yulのコードを記述します。通常、Yulオブジェクトの中に置かれるものです。これについては次の章で説明します。

Grammar::

    Block = '{' Statement* '}'
    Statement =
        Block |
        FunctionDefinition |
        VariableDeclaration |
        Assignment |
        If |
        Expression |
        Switch |
        ForLoop |
        BreakContinue
    FunctionDefinition =
        'function' Identifier '(' TypedIdentifierList? ')'
        ( '->' TypedIdentifierList )? Block
    VariableDeclaration =
        'let' TypedIdentifierList ( ':=' Expression )?
    Assignment =
        IdentifierList ':=' Expression
    Expression =
        FunctionCall | Identifier | Literal
    If =
        'if' Expression Block
    Switch =
        'switch' Expression ( Case+ Default? | Default )
    Case =
        'case' Literal Block
    Default =
        'default' Block
    ForLoop =
        'for' Block Expression Block Block
    BreakContinue =
        'break' | 'continue'
    FunctionCall =
        Identifier '(' ( Expression ( ',' Expression )* )? ')'
    Identifier = [a-zA-Z_$] [a-zA-Z_$0-9]*
    IdentifierList = Identifier ( ',' Identifier)*
    TypeName = Identifier | BuiltinTypeName
    BuiltinTypeName = 'bool' | [us] ( '8' | '32' | '64' | '128' | '256' )
    TypedIdentifierList = Identifier ':' TypeName ( ',' Identifier ':' TypeName )*
    Literal =
        (NumberLiteral | StringLiteral | HexLiteral | TrueLiteral | FalseLiteral) ':' TypeName
    NumberLiteral = HexNumber | DecimalNumber
    HexLiteral = 'hex' ('"' ([0-9a-fA-F]{2})* '"' | '\'' ([0-9a-fA-F]{2})* '\'')
    StringLiteral = '"' ([^"\r\n\\] | '\\' .)* '"'
    TrueLiteral = 'true'
    FalseLiteral = 'false'
    HexNumber = '0x' [0-9a-fA-F]+
    DecimalNumber = [0-9]+

Restrictions on the Grammar
---------------------------

Switch文はdefault caseを含む最低でも1つのcaseを持ちます。
もし式のすべての可能な値がカバーされている場合、defaultのcaseは許容するべきではありません(すなわち、真と偽の両方のケースを持つ ``bool`` を持つSwitch文)。
また、すべてのcaseの値は同じ型である必要があります。

すべての式はゼロ以上の値に評価されます。識別子とリテラルは厳密に1つの値であると評価され、関数呼び出しは呼び出された関数の戻り値の数と等しい数の値であると評価されます。

変数宣言時や代入時、右辺の式は、左辺の変数の数と等しい数の値であると評価される必要があります。
これが、複数の値に評価される式が許可される唯一の状況です。

ステートメント(すなわち、ブロックレベル)でもある式は、0として評価される必要があります。
そして、その他のすべてのシチュエーションにおいて、式は単一の値として評価する必要があります。

 ``continue``や ``break``文はループ文中でのみ使用でき、ループ文と同じ関数内になければなりません(もしくは両方ともトップレベルになければなりません)。

for文の条件は、単一の値で評価される必要があります。

リテラルは、その型以上に大きくなることはありません。最大値の型は、256ビット長であることが決められています。

Scoping Rules
-------------

Yulのスコープはブロックと結びついており(関数とforループは例外です)、すべての宣言( ``FunctionDefinition``、 ``VariableDeclaration``)はこれらのスコープに新たな識別子をもたらします。

識別子は、定義されたブロック内で表示することができます(すべてのサブノートやサブブロックを含みます)。
例外として、forループの"init"部分(最初のブロック)で定義された識別子は、forループの他のすべての部分で表示することができます(ただし、ループの外側では表示できません)。
関数のパラメータと戻り値は関数本体に表示され、それらの名前は同じものを使用することはできません。

変数は宣言後に参照することができます。特に、変数はそれ自身の変数宣言の右側では参照できません。
関数は宣言前にすでに参照できます(可視性である場合に限ります)。

シャドーイングは使用できません。つまり、たとえアクセスできない場合でも、同じ名前の別の識別子も表示されている場所で識別子を宣言することはできません。

また、関数の外側で宣言された変数にアクセスすることはできません。

Formal Specification
--------------------

私たちは、ASTのさまざまなノードにオーバーロードされた評価関数Eを提供して、Yulを形式的に指定します。
どの関数にも副作用がある可能性があるため、評価関数Eは2つのステートオブジェクトとASTノードを取り、2つの新しいステートオブジェクトと可変数の他の値を返します。
2つの状態オブジェクトとはグローバルステートオブジェクト(EVMのコンテキストではブロックチェーンのメモリ、ストレージ、およびステート)とローカルステートオブジェクト(ローカル変数のステート、つまりEVM内のスタックのセグメント)です。

もしASTノードがステートメントである場合、評価関数Eは2つのステートオブジェクトと、 ``break``と ``continue``に使用される "mode"を返します。
もしASTノードが式である場合、評価関数Eは2つのステートオブジェクトと式が評価する同じ数の値を返します。

グローバルステートの正確な性質は、この上位レベルの説明では規定されていません。
ローカルステート ``L``は、識別子 ``i``から値 ``v``へのマッピングで、``L[i] = v``と表されます。

識別子 `` v``の場合、 `` $ v``を識別子の名前とします。

また、ASTノードには分割表記を使用します。

.. code::

    E(G, L, <{St1, ..., Stn}>: Block) =
        let G1, L1, mode = E(G, L, St1, ..., Stn)
        let L2 be a restriction of L1 to the identifiers of L
        G1, L2, mode
    E(G, L, St1, ..., Stn: Statement) =
        if n is zero:
            G, L, regular
        else:
            let G1, L1, mode = E(G, L, St1)
            if mode is regular then
                E(G1, L1, St2, ..., Stn)
            otherwise
                G1, L1, mode
    E(G, L, FunctionDefinition) =
        G, L, regular
    E(G, L, <let var1, ..., varn := rhs>: VariableDeclaration) =
        E(G, L, <var1, ..., varn := rhs>: Assignment)
    E(G, L, <let var1, ..., varn>: VariableDeclaration) =
        let L1 be a copy of L where L1[$vari] = 0 for i = 1, ..., n
        G, L1, regular
    E(G, L, <var1, ..., varn := rhs>: Assignment) =
        let G1, L1, v1, ..., vn = E(G, L, rhs)
        let L2 be a copy of L1 where L2[$vari] = vi for i = 1, ..., n
        G, L2, regular
    E(G, L, <for { i1, ..., in } condition post body>: ForLoop) =
        if n >= 1:
            let G1, L1, mode = E(G, L, i1, ..., in)
            // 構文上の制限のため、modeは規則的でなければなりません
            let G2, L2, mode = E(G1, L1, for {} condition post body)
            // 構文上の制限のため、modeは規則的でなければなりません
            let L3 be the restriction of L2 to only variables of L
            G2, L3, regular
        else:
            let G1, L1, v = E(G, L, condition)
            if v is false:
                G1, L1, regular
            else:
                let G2, L2, mode = E(G1, L, body)
                if mode is break:
                    G2, L2, regular
                else:
                    G3, L3, mode = E(G2, L2, post)
                    E(G3, L3, for {} condition post body)
    E(G, L, break: BreakContinue) =
        G, L, break
    E(G, L, continue: BreakContinue) =
        G, L, continue
    E(G, L, <if condition body>: If) =
        let G0, L0, v = E(G, L, condition)
        if v is true:
            E(G0, L0, body)
        else:
            G0, L0, regular
    E(G, L, <switch condition case l1:t1 st1 ... case ln:tn stn>: Switch) =
        E(G, L, switch condition case l1:t1 st1 ... case ln:tn stn default {})
    E(G, L, <switch condition case l1:t1 st1 ... case ln:tn stn default st'>: Switch) =
        let G0, L0, v = E(G, L, condition)
        // i = 1 .. n
        // コンテキストに関係なくリテラルを評価します
        let _, _, v1 = E(G0, L0, l1)
        ...
        let _, _, vn = E(G0, L0, ln)
        if there exists smallest i such that vi = v:
            E(G0, L0, sti)
        else:
            E(G0, L0, st')

    E(G, L, <name>: Identifier) =
        G, L, L[$name]
    E(G, L, <fname(arg1, ..., argn)>: FunctionCall) =
        G1, L1, vn = E(G, L, argn)
        ...
        G(n-1), L(n-1), v2 = E(G(n-2), L(n-2), arg2)
        Gn, Ln, v1 = E(G(n-1), L(n-1), arg1)
        Let <function fname (param1, ..., paramn) -> ret1, ..., retm block>
        be the function of name $fname visible at the point of the call.
        Let L' be a new local state such that
        L'[$parami] = vi and L'[$reti] = 0 for all i.
        Let G'', L'', mode = E(Gn, L', block)
        G'', Ln, L''[$ret1], ..., L''[$retm]
    E(G, L, l: HexLiteral) = G, L, hexString(l),
        where hexString decodes l from hex and left-aligns it into 32 bytes
    E(G, L, l: StringLiteral) = G, L, utf8EncodeLeftAligned(l),
        where utf8EncodeLeftAligned performs a utf8 encoding of l
        and aligns it left into 32 bytes
    E(G, L, n: HexNumber) = G, L, hex(n)
        where hex is the hexadecimal decoding function
    E(G, L, n: DecimalNumber) = G, L, dec(n),
        where dec is the decimal decoding function

Type Conversion Functions
-------------------------

Yulは暗黙的型変換をサポートしていないため、明示的変換を提供するための関数が存在します。
大きな型からより小さな型へ変換するとき、オーバーフローの場合にruntime exceptionが発生する可能性があります。

以下の型間での変換の切り捨てがサポートされています:
 - ``bool``
 - ``u32``
 - ``u64``
 - ``u256``
 - ``s256``

これらのそれぞれに対して、型変換関数は、 ``u32tobool(x:u32) -> y:bool``、 ``u256tou32(x:u256) -> y:u32`` や ``s256tou256(x:s256) -> y:u256`` などといった ``<input_type>to<output_type>(x:<input_type>) -> y:<output_type>``形式のプロトタイプを持ちます。

.. note::

    ``u32tobool(x:u32) -> y:bool`` は ``y := not(iszerou256(x))`` として実行され、
    ``booltou32(x:bool) -> y:u32`` は ``switch x case true:bool { y := 1:u32 } case false:bool { y := 0:u32 }`` として実行されます。

Low-level Functions
-------------------

以下の関数が利用可能でなければなりません:

+---------------------------------------------------------------------------------------------------------------+
| *Logic*                                                                                                       |
+---------------------------------------------+-----------------------------------------------------------------+
| not(x:bool) -> z:bool                       | 論理否定                                                         |
+---------------------------------------------+-----------------------------------------------------------------+
| and(x:bool, y:bool) -> z:bool               | 論理否定                                                         |
+---------------------------------------------+-----------------------------------------------------------------+
| or(x:bool, y:bool) -> z:bool                | 論理和                                                           |
+---------------------------------------------+-----------------------------------------------------------------+
| xor(x:bool, y:bool) -> z:bool               | 排他的論理和                                                      |
+---------------------------------------------+-----------------------------------------------------------------+
| *Arithmetic*                                                                                                  |
+---------------------------------------------+-----------------------------------------------------------------+
| addu256(x:u256, y:u256) -> z:u256           | x + y                                                           |
+---------------------------------------------+-----------------------------------------------------------------+
| subu256(x:u256, y:u256) -> z:u256           | x - y                                                           |
+---------------------------------------------+-----------------------------------------------------------------+
| mulu256(x:u256, y:u256) -> z:u256           | x * y                                                           |
+---------------------------------------------+-----------------------------------------------------------------+
| divu256(x:u256, y:u256) -> z:u256           | x / y                                                           |
+---------------------------------------------+-----------------------------------------------------------------+
| divs256(x:s256, y:s256) -> z:s256           | x / y、 2の補数の符号付き数値用　　　　　　　　　　　                  |
+---------------------------------------------+-----------------------------------------------------------------+
| modu256(x:u256, y:u256) -> z:u256           | x % y                                                           |
+---------------------------------------------+-----------------------------------------------------------------+
| mods256(x:s256, y:s256) -> z:s256           | x % y、 2の補数の符号付き数値用　　　　　　　　　　　                  |
+---------------------------------------------+-----------------------------------------------------------------+
| signextendu256(i:u256, x:u256) -> z:u256    | 最下位から数えて（i * 8 + 7）番目のビットからの符号拡張               |
+---------------------------------------------+-----------------------------------------------------------------+
| expu256(x:u256, y:u256) -> z:u256           | xのy乗　　　　　　　　                                             |
+---------------------------------------------+-----------------------------------------------------------------+
| addmodu256(x:u256, y:u256, m:u256) -> z:u256| (x + y）% m の任意精度演算　　　　　　　　　　　　　　                |
+---------------------------------------------+-----------------------------------------------------------------+
| mulmodu256(x:u256, y:u256, m:u256) -> z:u256| (x * y) % m の任意精度演算　　　　　　　　　　　　　                 |
+---------------------------------------------+-----------------------------------------------------------------+
| ltu256(x:u256, y:u256) -> z:bool            | x < yであればtrue、そうでないならfalse                              |
+---------------------------------------------+-----------------------------------------------------------------+
| gtu256(x:u256, y:u256) -> z:bool            | x < yであればtrue、そうでないならfalse                             |
+---------------------------------------------+-----------------------------------------------------------------+
| lts256(x:s256, y:s256) -> z:bool            | x < yであればtrue、そうでないならfalse                             |
|                                             | (2の補数の符号付き数値用)                                          |
+---------------------------------------------+-----------------------------------------------------------------+
| gts256(x:s256, y:s256) -> z:bool            | x < yであればtrue、そうでないならfalse                             |
|                                             | (2の補数の符号付き数値用)                                          |
+---------------------------------------------+-----------------------------------------------------------------+
| equ256(x:u256, y:u256) -> z:bool            | x == yであればtrue、そうでないならfalse                             |
+---------------------------------------------+-----------------------------------------------------------------+
| iszerou256(x:u256) -> z:bool                | x == 0であればtrue、そうでないならfalse                             |
+---------------------------------------------+-----------------------------------------------------------------+
| notu256(x:u256) -> z:u256                   | xまでのすべてのビットを否定                                         |
+---------------------------------------------+-----------------------------------------------------------------+
| andu256(x:u256, y:u256) -> z:u256           | xとyのビットごとのand                                             |
+---------------------------------------------+-----------------------------------------------------------------+
| oru256(x:u256, y:u256) -> z:u256            | xとyのビットごとのor                                              |
+---------------------------------------------+-----------------------------------------------------------------+
| xoru256(x:u256, y:u256) -> z:u256           | xとyのビットごとのxor                                             |
+---------------------------------------------+-----------------------------------------------------------------+
| shlu256(x:u256, y:u256) -> z:u256           | xをyだけ左シフト　　  　　　　　　                                  |
+---------------------------------------------+-----------------------------------------------------------------+
| shru256(x:u256, y:u256) -> z:u256           | xをyだけ右シフト                                                  |
+---------------------------------------------+-----------------------------------------------------------------+
| sars256(x:s256, y:u256) -> z:u256           | yによるxの算術右シフト                                             |
+---------------------------------------------+-----------------------------------------------------------------+
| byte(n:u256, x:u256) -> v:u256              | xのn番目のバイト。最上位バイトは0番目のバイトです。                    |
|                                             | これをand256（shr256（n、x）、0xff）に置き換えて、                   |
|                                             | EVMバックエンドによって最適化されるようにすることはできませんか？        |
+---------------------------------------------+-----------------------------------------------------------------+
| *Memory and storage*                                                                                          |
+---------------------------------------------+-----------------------------------------------------------------+
| mload(p:u256) -> v:u256                     | mem[p..(p+32))                                                  |
+---------------------------------------------+-----------------------------------------------------------------+
| mstore(p:u256, v:u256)                      | mem[p..(p+32)) := v                                             |
+---------------------------------------------+-----------------------------------------------------------------+
| mstore8(p:u256, v:u256)                     | mem[p] := v & 0xff    - シングルバイトのみを変更                   |
+---------------------------------------------+-----------------------------------------------------------------+
| sload(p:u256) -> v:u256                     | storage[p]                                                      |
+---------------------------------------------+-----------------------------------------------------------------+
| sstore(p:u256, v:u256)                      | storage[p] := v                                                 |
+---------------------------------------------+-----------------------------------------------------------------+
| msize() -> size:u256                        | メモリサイズ。つまり、メモリ拡張関数はワード単位で拡張されるため、        |
|                                             | アクセスされた最大メモリインデックスのことです。                       |
|                                             | ただし、これは常に32バイトの倍数になります。                          |
+---------------------------------------------+-----------------------------------------------------------------+
| *Execution control*                                                                                           |
+---------------------------------------------+-----------------------------------------------------------------+
| create(v:u256, p:u256, n:u256)              | mem [p ..（p + n））で新しいコントラクトを作成し、                   |
|                                             | v weiを送信して新しいアドレスを返します。                            |
+---------------------------------------------+-----------------------------------------------------------------+
| create2(v:u256, p:u256, n:u256, s:u256)     | keccak256(0xff . this . s . keccak256(mem[p...(p+n)))のアドレス  |
|                                             | mem[p...(p+n))を使いコントラクトを生成します。                      |
|                                             | そして、v weiを送って新しいアドレスを返します。                       |
|                                             | ここでは ``0xff``は8バイトの値、 ``this``はカレントコントラクトにおける|
|                                             | 20バイトの値、そして ``s``は256ビットのビッグエンディアンです。        |
+---------------------------------------------+-----------------------------------------------------------------+
| call(g:u256, a:u256, v:u256, in:u256,       | 入力値mem[in..(in+insize))を用いてコントラクトを呼び出します。        |
| insize:u256, out:u256,                      | また、このときg gasとv weiを引数とします。                           |
| outsize:u256)                               | そして、mem[out..(out+outsize))は失敗時には(ガス代が足りないときなど)  |
| -> r:u256                                   | 0を、成功時には1を返します。                                        |
+---------------------------------------------+-----------------------------------------------------------------+
| callcode(g:u256, a:u256, v:u256, in:u256,   | ``call``と同一ですが、                                            |
| insize:u256, out:u256,                      | aからのコードのみを使用し、                                         |
| outsize:u256) -> r:u256                     | それ以外は現在のコントラクトのコンテキストに留まります。                |
+---------------------------------------------+-----------------------------------------------------------------+
| delegatecall(g:u256, a:u256, in:u256,       | ``callcode``と同一ですが、                                      　|
| insize:u256, out:u256,                      | ``caller``と                                        　　　　　　  |
| outsize:u256) -> r:u256                     | ``callvalue``を保持します。                                       |
+---------------------------------------------+-----------------------------------------------------------------+
| abort()                                     | abort (EVMにおける無効な命令であるabortと同一です)                   |
+---------------------------------------------+-----------------------------------------------------------------+
| return(p:u256, s:u256)                      | 実行すると、mem[p..(p+s))を返します。                               |
+---------------------------------------------+-----------------------------------------------------------------+
| revert(p:u256, s:u256)                      | 実行すると、ステートチェンジをrevertし、mem[p..(p+s))を返します。      |
+---------------------------------------------+-----------------------------------------------------------------+
| selfdestruct(a:u256)                        | 実行すると、カレントコントラクトを破棄し、残高をaに送金します。          |
+---------------------------------------------+-----------------------------------------------------------------+
| log0(p:u256, s:u256)                        | mem[p..(p+s))のログを記録します。                                  |
+---------------------------------------------+-----------------------------------------------------------------+
| log1(p:u256, s:u256, t1:u256)               | t1におけるmem[p..(p+s))のログを記録します。                         |
+---------------------------------------------+-----------------------------------------------------------------+
| log2(p:u256, s:u256, t1:u256, t2:u256)      | t1とt2におけるmem[p..(p+s))のログを記録します。                     |
+---------------------------------------------+-----------------------------------------------------------------+
| log3(p:u256, s:u256, t1:u256, t2:u256,      | t、t2とt3におけるmem[p..(p+s))のログを記録します。                   |
| t3:u256)                                    |                                                                 |
+---------------------------------------------+-----------------------------------------------------------------+
| log4(p:u256, s:u256, t1:u256, t2:u256,      | t1、t2、t3とt4におけるmem[p..(p+s))のログを記録します。              |
| t3:u256, t4:u256)                           |                                                                 |
+---------------------------------------------+-----------------------------------------------------------------+
| *State queries*                                                                                               |
+---------------------------------------------+-----------------------------------------------------------------+
| blockcoinbase() -> address:u256             | 現在のマイナーアドレス                                             |
+---------------------------------------------+-----------------------------------------------------------------+
| blockdifficulty() -> difficulty:u256        | カレントブロックのdifficulty                                       |
+---------------------------------------------+-----------------------------------------------------------------+
| blockgaslimit() -> limit:u256               | カレントブロックのブロックガスリミット                                |
+---------------------------------------------+-----------------------------------------------------------------+
| blockhash(b:u256) -> hash:u256              | ブロックnr bのハッシュ、ただし現在を除く最新の256ブロックのみです。      |
+---------------------------------------------+-----------------------------------------------------------------+
| blocknumber() -> block:u256                 | カレントブロックナンバー                                            |
+---------------------------------------------+-----------------------------------------------------------------+
| blocktimestamp() -> timestamp:u256          | エポック以降の現在のブロックのタイムスタンプ(秒単位)                   |
+---------------------------------------------+-----------------------------------------------------------------+
| txorigin() -> address:u256                  | トランザクションの送信者                                            |
+---------------------------------------------+-----------------------------------------------------------------+
| txgasprice() -> price:u256                  | トランザクションに必要なガス代                                       |
+---------------------------------------------+-----------------------------------------------------------------+
| gasleft() -> gas:u256                       | 実行可能なガス代                                                   |
+---------------------------------------------+-----------------------------------------------------------------+
| balance(a:u256) -> v:u256                   | アドレスaのバランス                                                |
+---------------------------------------------+-----------------------------------------------------------------+
| this() -> address:u256                      | カレントコントラクトのアドレス                                       |
+---------------------------------------------+-----------------------------------------------------------------+
| caller() -> address:u256                    | 送金者をコールする(delegatecallを除く)                              |
+---------------------------------------------+-----------------------------------------------------------------+
| callvalue() -> v:u256                       | weiはカレントコールと共に送信されたwei                               |
+---------------------------------------------+-----------------------------------------------------------------+
| calldataload(p:u256) -> v:u256              | 位置pから始まるコールデータ(32バイト)                                |
+---------------------------------------------+-----------------------------------------------------------------+
| calldatasize() -> v:u256                    | 呼び出しデータのサイズ(バイト)                                      |
+---------------------------------------------+-----------------------------------------------------------------+
| calldatacopy(t:u256, f:u256, s:u256)        | 位置fのcalldataから位置tのmemにsバイトをコピーする。                 |
+---------------------------------------------+-----------------------------------------------------------------+
| codesize() -> size:u256                     | カレントコントラクトコードのサイズ                                   |
+---------------------------------------------+-----------------------------------------------------------------+
| codecopy(t:u256, f:u256, s:u256)            | 位置fのコードから位置tのmemにsバイトをコピーする。                    |
+---------------------------------------------+-----------------------------------------------------------------+
| extcodesize(a:u256) -> size:u256            | アドレスaのコードのサイズ                                           |
+---------------------------------------------+-----------------------------------------------------------------+
| extcodecopy(a:u256, t:u256, f:u256, s:u256) | codecopy(t, f, s)と同様ですが、アドレスaのコードを引数にとります。     |
+---------------------------------------------+-----------------------------------------------------------------+
| extcodehash(a:u256)                         | アドレスaのコードハッシュ                                          |
+---------------------------------------------+-----------------------------------------------------------------+
| *Others*                                                                                                      |
+---------------------------------------------+-----------------------------------------------------------------+
| discard(unused:bool)                        | 値を破棄します。                                                   |
+---------------------------------------------+-----------------------------------------------------------------+
| discardu256(unused:u256)                    | 値を破棄します。                                                   |
+---------------------------------------------+-----------------------------------------------------------------+
| splitu256tou64(x:u256) -> (x1:u64, x2:u64,  | u256値を4つのu64値に分割します。                                    |
| x3:u64, x4:u64)                             |                                                                 |
+---------------------------------------------+-----------------------------------------------------------------+
| combineu64tou256(x1:u64, x2:u64, x3:u64,    | 4つのu64値を1つのu256値に結合します                                 |
| x4:u64) -> (x:u256)                         |                                                                 |
+---------------------------------------------+-----------------------------------------------------------------+
| keccak256(p:u256, s:u256) -> v:u256         | keccak(mem[p...(p+s)))です。                                     |
+---------------------------------------------+-----------------------------------------------------------------+
| *Object access*                             |                                                                 |
+---------------------------------------------+-----------------------------------------------------------------+
| datasize(name:string) -> size:u256          | データオブジェクトのサイズ(バイト)です。                              |
|                                             | ただし、nameは文字列リテラルでなければなりません。                     |
+---------------------------------------------+-----------------------------------------------------------------+
| dataoffset(name:string) -> offset:u256      | データ領域内のデータオブジェクトのオフセット(バイト)です。              |
|                                             | ただし、nameは文字列リテラルでなければなりません。                     |
+---------------------------------------------+-----------------------------------------------------------------+
| datacopy(dst:u256, src:u256, len:u256)      | オフセットsrcバイトから始まるデータ領域から、                         |
|                                             | 位置dstのメモリにlenバイトをコピーする。                             |
+---------------------------------------------+-----------------------------------------------------------------+

Backends
--------

バックエンドやターゲットはYulから特定のバイトコードへのtranslatorとなります。各バックエンドは、バックエンドの名前を接頭辞として持つ関数を公開することができます。
また、バックエンドのために `` evm``と `` ewasm``の接頭辞を予約語としています。

Backend: EVM
------------

EVMターゲットは `evm_`接頭辞で公開されているすべての基底のEVMオペコードを持ちます。

Backend: "EVM 1.5"
------------------

TBD

Backend: eWASM
--------------

TBD

Specification of Yul Object
===========================

Yulオブジェクトは、名前付きコードとデータセクションをグループ化するために使用されます。
関数 ``datasize``、 ``dataoffset``および ``datacopy``は、コード内からこれらのセクションにアクセスするために使用できます。
また、16進数エンコーディングでデータを指定し、ネイティブエンコーディングで通常の文字列を指定するために16進数の文字列を使用できます。
コードの場合、 ``datacopy``はassembled binary representationにアクセスします。

Grammar::

    Object = 'object' StringLiteral '{' Code ( Object | Data )* '}'
    Code = 'code' Block
    Data = 'data' StringLiteral ( HexLiteral | StringLiteral )
    HexLiteral = 'hex' ('"' ([0-9a-fA-F]{2})* '"' | '\'' ([0-9a-fA-F]{2})* '\'')
    StringLiteral = '"' ([^"\r\n\\] | '\\' .)* '"'

以上において、``Block``は前の章で説明したYulコード文法の ``Block``を表します。

Yulオブジェクトの例を以下に示します:

.. code::

    // コードは単一のオブジェクトで構成されています。単一の "code"ノードはオブジェクトのコードです。
    // すべての（他の）名前付きオブジェクトまたはデータセクションはシリアライズされ、
    // 特別な組み込み関数 datacopy/dataoffset/datasize にアクセスできるようになります。    
    // ネストされたオブジェクトへのアクセスは ``.`` を使って名前を結合することによって可能です。
    // 現在のオブジェクト、現在のオブジェクト内のサブオブジェクト、およびデータ項目は、ネストアクセスなしでスコープ内にあります。
    object "Contract1" {
        code {
            // 最初に "runtime.Contract2" を作成します
            let size = datasize("runtime.Contract2")
            let offset = allocate(size)
            // 以下はeWASMの場合はmemory-> memory、
            // EVMの場合は "runtime.Contract2"のコードコピーになります
            datacopy(offset, dataoffset("runtime.Contract2"), size)
            // コンストラクタパラメータは単一値0x1234になります
            mstore(add(offset, size), 0x1234)
            create(offset, add(size, 32))

            // これでランタイムオブジェクトを返すようになりました（これはコンストラクタコードです）
            size := datasize("runtime")
            offset := allocate(size)
            // 以下はeWASMの場合はmemory-> memory、EVMの場合はcodecopyになります。
            datacopy(offset, dataoffset("runtime"), size)
            return(offset, size)
        }

        data "Table2" hex"4123"

        object "runtime" {
            code {
                // ランタイムコード

                let size = datasize("Contract2")
                let offset = allocate(size)
                // 以下はeWASMの場合はmemory-> memory、EVMの場合はcodecopyになります。
                datacopy(offset, dataoffset("Contract2"), size)
                // コンストラクタパラメータは単一値0x1234になります
                mstore(add(offset, size), 0x1234)
                create(offset, add(size, 32))
            }

            // 埋め込みオブジェクト。ユースケースとして、オブジェクト外においてファクトリコントラクトであり、
            // Contract2がファクトリによって作成されるコードです。
            object "Contract2" {
                code {
                    // コード...
                }

                object "runtime" {
                    code {
                        // コード...
                    }
                 }

                 data "Table1" hex"4123"
            }
        }
    }
